<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>servlet的使用</title>
    <url>/2020/01/11/servlet/</url>
    <content><![CDATA[<h1 id="servlet的定义"><a href="#servlet的定义" class="headerlink" title="servlet的定义"></a>servlet的定义</h1><ol>
<li>servlet是sun公司开发的一款用于开发动态web资源的技术，web资源分为动态和静态的两种。</li>
<li>动态和静态的区别</li>
</ol>
<ul>
<li>动态web资源是客户端请求的动态资源，先将资源交于web容器，在由web容器连接数据库，数据库处理数据后交由web容器返回给客户端解析渲染处理</li>
<li>静态资源是web容器从内存中直接调取返回给客户端</li>
<li>静态资源一般是设计好的html页面，而动态资源是根据设计好的程序按照需求来动态响应</li>
<li>静态资源的交互性差，动态资源的交互性好</li>
<li>静态资源不需要数据库参与程序处理，而动态资源需要</li>
</ul>
<h1 id="servlet的实现方法"><a href="#servlet的实现方法" class="headerlink" title="servlet的实现方法"></a>servlet的实现方法</h1><p>sun在java中提供了servlet的接口，只需要完成两个步骤</p>
<ul>
<li>编写Java类，实现servlet接口</li>
<li>将Java类部署到服务器上</li>
</ul>
<h1 id="一些杂谈"><a href="#一些杂谈" class="headerlink" title="一些杂谈"></a>一些杂谈</h1><ol>
<li>得到表单提交的数据用String name = request.getParameter(“name”);<br>这里request.getParameter(“name”)的作用是获得提交的表单中name值为“name”的value，这是通过表单标签的action属性完成，这个属性是规定了表单获得的数据发送到哪个页面</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat的问题及解决办法</title>
    <url>/2020/01/10/tomcat/</url>
    <content><![CDATA[<h1 id="tomcat匹配的jdk"><a href="#tomcat匹配的jdk" class="headerlink" title="tomcat匹配的jdk"></a>tomcat匹配的jdk</h1><ol>
<li>如果是用的how2j提供的tomcat，那么Java的jdk版本必须是1.8(我之前用的是13，打开tomcat就闪退)，具体安装教程how2j上也有。</li>
<li>如果想用url访问html文件，必须在tomcat/bin/webapps下手动新建一个ROOT(大写)文件夹，才能在网站上看见。</li>
<li>tomcat的乱码显示问题</li>
<li>部署项目时要加上端口号，并且在server配置文件里写文件路径时，要新建一个web项目文件</li>
<li>用eclipsse打开时，会发现报failed to find JDK….jvm,这是因为jdk版本与eclipse版本不一致导致，全部用how2j提供的版本进行下载</li>
</ol>
]]></content>
      <categories>
        <category>problem solution</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法实战</title>
    <url>/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ol>
<li>通过指针引用数组元素，<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a [<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p=&amp;a;</span><br><span class="line">(p+i)<span class="comment">//第i个元素的地址</span></span><br><span class="line">*(p+i)<span class="comment">//第i个元素</span></span><br></pre></td></tr></table></figure>
！！！！数组名为第一个元素a[i]的地址，是一个指针常量，不能进行a++运算，<br>要用a+1进行运算(递归注意，就是这里错的)。但是用<code>int *p=a</code>之后就可以用p++。</li>
<li>对数组进行操作的话，函数只要传入首个元素的地址就可以(数组是连续内存)，再知道数组的长度，就可以对数组进行索引和一系列操作<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">     <span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line">     <span class="keyword">int</span> x = <span class="built_in">max</span>(a,n);</span><br><span class="line">     <span class="keyword">double</span> m = average(a,n);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"max = %d,average =  %f"</span>,x,m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> *p;<span class="comment">//定义一个指针，指向a数组，这样可以执行p++操作（详见1）</span></span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">max</span> = *p;</span><br><span class="line">     <span class="keyword">for</span>(p=a;p&lt;a+n;p++)&#123;  <span class="comment">//n是数组长度，p向后一个不是二进制的+1，而是数组元素类型占用内存+1(这样就直观表现为数组元素向后+1)</span></span><br><span class="line">     	<span class="keyword">if</span>(*p&gt;<span class="built_in">max</span>)&#123;</span><br><span class="line">     		<span class="built_in">max</span>=*p;</span><br><span class="line">     	&#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       itn *p;</span><br><span class="line">       <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(p=a;p&lt;a+n;p++)&#123;</span><br><span class="line">       	sum+=(<span class="keyword">double</span>)*p;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">double</span> average = sum/(<span class="keyword">double</span>)n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> average;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>对字符串数组进行操作时，容易忘记最后加上一个中止符号(‘\0’),<br>先省略。。。。。。</li>
</ul>
<ol start="3">
<li>行指针和二维数组</li>
</ol>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><ol>
<li><p>概念：递归算法的思想实质就是分治策略，将一个问题拆解成不能再拆解的最小问题(递推分解)，再将最小问题的解返回给上一级(回归分治)。并且在运行到最小问题的时候一定要给出结束的条件，否则会无线递归，占用完内存最终导致程序崩溃。</p>
</li>
<li><p>递归与循环的区别：递归在底层实际上是对线程栈的压栈和出栈(递归是先调用的函数最后运算)，每调用一次都会压栈一次，并记录相关的局部变量信息，无限的递归耗用的是内存资源，而死循耗用的是CPU资源，死循环并不会引起程序的异常，但递归耗完内存就会引发程序的崩溃。</p>
</li>
<li><p>与循环十分类似，但是递归是通过不断打开新函数来运算的，效率上明显不如循环，实际上也是经常用循环而不是用递归。</p>
</li>
<li><p>实例：求n!阶乘</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factrial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//设立的终止条件</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n*factrial(n<span class="number">-1</span>);<span class="comment">//重复的步骤</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题分析：首先找出问题的重复步骤，此题中是n!=1<em>2</em>3<em>….n,那么可见每次n+1就是重复步骤。但是递归是由大问题向小问题分解，就变成了n!=n</em>n-1<em>n-1….</em>1(这也符合栈先进后出的特点)。终止条件显而易见，就是n==1，return 1。<br>程序分析：当n&gt;1时，程序运行到<code>return n*factrial(n-1)</code>时，会打开factrial(n-1)函数，以此类推，最后变为：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">n<span class="number">*fac</span>trial(n-1)<span class="number">*fac</span>trial(n-2)<span class="built_in">..</span><span class="built_in">..</span><span class="number">*fac</span>trial(1)</span><br></pre></td></tr></table></figure>
<p>其中<code>factrial(1) return 1</code>，那么返回上一级函数是2，在上一级就是3。</p>
</li>
</ol>
<p><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E9%80%92%E5%BD%921.jpeg" alt><br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E9%80%92%E5%BD%922.jpeg" alt></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>c语言，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title>java复习</title>
    <url>/2019/12/19/java/</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ol>
<li>局部变量(local variable):方法或语句块内的变量，其生命周期是从声明位置开始到方法或语句块结束为止。(和c的函数局部变量一样)。<a id="more"></a></li>
<li>成员变量(member variable)：也叫实例变量，方法外，类的内部的变量，其生命周期伴随对象始终。并且成员变量在定义时如果没有手动赋值，会默认赋初始值，数字是0，字符是null，布尔是false。</li>
<li>静态变量(类变量 static variable):用static关键字表示，从属于类，生命周期从类加载到卸载，伴随类的始终。</li>
<li>周期比较(小到大)：局部变量(从属于方法)&lt;成员变量(从属于对象)&lt;静态变量(从属于类)。而c中类似的只有局部变量和静态变量的概念。(c是面向过程编程，不同于面向对象，没有对象的概念)。</li>
</ol>
<hr>
<h1 id="变量和常量的命名规范"><a href="#变量和常量的命名规范" class="headerlink" title="变量和常量的命名规范"></a>变量和常量的命名规范</h1><ol>
<li>所有变量和方法名都是首字母小写和驼峰原则。</li>
<li>常量是大写字母和下划线。</li>
<li>类名大写字母和驼峰原则。</li>
</ol>
<hr>
<h1 id="自动转化"><a href="#自动转化" class="headerlink" title="自动转化"></a>自动转化</h1><ol>
<li>指容量小的数据类型自动转为容量大的数据类型，容量指的是表示范围，例如short a = 12 合法，但short a = 1234567不合法，超出了short的表示范围。<br>其中实线表示可以不损失精度直接转换，虚线是可能会有精度损失。<br><img src="/2019/12/19/java/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt></li>
</ol>
<h1 id="Scanner获取键盘输入"><a href="#Scanner获取键盘输入" class="headerlink" title="Scanner获取键盘输入"></a>Scanner获取键盘输入</h1><ol>
<li>首先要导入Scanner所在包</li>
<li>新建Scanner对象</li>
<li>建立变量存储键盘输入的值<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner<span class="comment">//引进包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">               Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//in是io流</span></span><br><span class="line">               System.out.println(<span class="string">"请输入名字"</span>);</span><br><span class="line">               String name = Scanner.nextline();<span class="comment">//字符串是nextline</span></span><br><span class="line">               System.out.println(<span class="string">"请输入爱好"</span>);</span><br><span class="line">               String favor = Scanner.nextline();</span><br><span class="line">               System.out.println(<span class="string">"请输入年龄"</span>);</span><br><span class="line">               <span class="keyword">int</span> age = Scanner.nextInt();<span class="comment">//数字是nextInt</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ol>
<li>主类中方法前加static，表名该方法是类的共享成员，可以被该类所有的实例化对象访问，当类加载时，static方法就被加载，其声明周期从属于类。若是不定义static，也可以通过对象调用普通方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testmethod</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">	<span class="keyword">int</span> m = scanner.nextInt();</span><br><span class="line">	<span class="keyword">int</span> x = sum(n,m);</span><br><span class="line">	System.out.println(<span class="string">"n+m="</span>+x);<span class="comment">//直接调用</span></span><br><span class="line">	</span><br><span class="line">	Testmethod th = <span class="keyword">new</span> Testmethod();</span><br><span class="line">	<span class="keyword">int</span> a = th.sum(<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">	System.out.println(a);<span class="comment">//对象调用</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">int</span> m)</span> </span>&#123; 	<span class="comment">//static 修饰的函数可以在主类中直接调用</span></span><br><span class="line">	<span class="keyword">return</span> m+n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//没有static要先创建对象，在通过对象调用方法</span></span><br><span class="line">	<span class="keyword">return</span> n+m+x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法的重载(overload)：函数名相同但参数列表不同(参数个数，顺序，类型)，只有返回值和形参名称不构成重载。</li>
</ol>
<h1 id="对象-object-instance"><a href="#对象-object-instance" class="headerlink" title="对象(object,instance)"></a>对象(object,instance)</h1><ol>
<li>对象是具体的事物;类是对对象的抽象;</li>
<li>类可以看成一类对象的模板，对象可以看成该类的一个具体实例。</li>
<li>类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性</li>
</ol>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ol>
<li>每个文件都只能由一个public class，且类名必须与文件名一致。可以定义多个普通类</li>
<li>类里由三个成员，属性(field),方法(method),构造方法(constructor)</li>
<li>类可以相互引用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testclass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line">	 grade ge;<span class="comment">//类名+属性名</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	grade g1 = <span class="keyword">new</span> grade();</span><br><span class="line">	Testclass stu1 = <span class="keyword">new</span> Testclass();</span><br><span class="line">	g1.grade = <span class="number">2</span>;</span><br><span class="line">	stu1.ge = g1;</span><br><span class="line">	System.out.printf(<span class="string">"年级"</span>+stu1.ge);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grade</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> grade;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>主类名唯一，其他类不能与主类重名，否则会报错找不到主类</li>
<li>传入一个类类型，在方法内进行改动，会对方法外的参数造成影响。<br>24行的引用 teemo与 第17行的引用hero，是不同的引用<br>通过调用garen.attack(teemo, 100); 使得这两个引用都指向了同一个对象<br>所以在第18行hero.hp = hero.hp - damage; 就使得该对象的hp值，发生了变化<br>因此第25行，打印该对象的Hp值就是变化后的值<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    String name; <span class="comment">// 姓名</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">float</span> hp; <span class="comment">// 血量</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">float</span> armor; <span class="comment">// 护甲</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> moveSpeed; <span class="comment">// 移动速度</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String name, <span class="keyword">float</span> hp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.hp = hp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 攻击一个英雄，并让他掉damage点血</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero hero, <span class="keyword">int</span> damage)</span> </span>&#123;</span><br><span class="line">        hero.hp = hero.hp - damage;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">"提莫"</span>, <span class="number">383</span>);</span><br><span class="line">        Hero garen = <span class="keyword">new</span> Hero(<span class="string">"盖伦"</span>, <span class="number">616</span>);</span><br><span class="line">        garen.attack(teemo, <span class="number">100</span>);</span><br><span class="line">        System.out.println(teemo.hp);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>类方法： 又叫做静态方法(加载类时和类一起加载)</li>
</ol>
<p>对象方法： 又叫实例方法，非静态方法(只有当对象调用是才会用)</p>
<p>访问一个对象方法，必须建立在有一个对象的前提的基础上<br>访问类方法，不需要对象的存在，直接就访问</p>
<h1 id="构造方法-constructor"><a href="#构造方法-constructor" class="headerlink" title="构造方法(constructor)"></a>构造方法(constructor)</h1><ol>
<li><p>用于对象的初始化，在对象创建时被调用，构造器的名称应该与类的名称一致，    虽然有返回值，但不能加return(返回值必然时本类)，即public+类名(不用加返回值类型名)</p>
</li>
<li><p>构造方法同样可以重载，但是当形参和实参重复时，就要用this关键字，this指代正在创建的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hero</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> hp ;</span><br><span class="line">   <span class="keyword">int</span> speed;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">hero</span> <span class="params">(<span class="keyword">int</span> hp,<span class="keyword">int</span> speed)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.hp = hp;  <span class="comment">//this.hp 指代创建对象的hp，等号后面的hp是形参hp</span></span><br><span class="line">		<span class="keyword">this</span>.speed = speed;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><ol>
<li>类和类之间的关系有5种，分别是：</li>
</ol>
<p><img src="/2019/12/19/java/%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt></p>
<ul>
<li>自身：hero类</li>
<li>同包子类：charactor包里继承了hero包的类(ADhero)</li>
<li>不同包子类：charactor1和property包里的继承了hero的类(support)</li>
<li>同包类：charactor包里除了hero的所有类</li>
<li>其他类：除上述类外的所有类</li>
</ul>
<ol start="2">
<li>修饰符类型：</li>
</ol>
<ul>
<li>private只能自己访问，其余任何类都不能访问或继承<br><img src="/2019/12/19/java/private.png" alt></li>
<li>package/friendly/default,没有修饰符是的默认修饰符，同包的子类和其他类可以继承和访问，但其他类的子类和类就不能访问和继承。<br><img src="/2019/12/19/java/default.png" alt></li>
<li>protected，除其他类不能访问外，同包和不同包都可以继承。<br><img src="/2019/12/19/java/protected.png" alt></li>
<li>public，任何地方，都可以访问<br><img src="/2019/12/19/java/public.png" alt></li>
</ul>
<ol start="3">
<li>适用范围：</li>
</ol>
<ul>
<li>属性通常使用private封装起来</li>
<li>方法一般使用public用于被调用</li>
<li>会被子类继承的方法，通常使用protected</li>
<li>package用的不多，一般新手会用package,因为还不知道有修饰符这个东西</li>
</ul>
<p>-再就是作用范围最小原则<br>  简单说，能用private就用private，不行就放大一级，用package,再不行就用protected，最后用public。这样就能把数据尽量的封装起来，没有必要露出来的，就不用露出来了</p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ol>
<li>又叫singleton，一个类在一个JVM里只有一个实例村在。有两种办法，两种办法的步骤都是</li>
</ol>
<ul>
<li>将构造方法私有化，使其不能被外部方法更改</li>
<li>将类属性实例化(二者主要区别就在这里)</li>
<li>写public static(类方法)，返回instance(实例)</li>
</ul>
<p>懒汉式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	giantDragon g1 = giantDragon.getInstance();</span><br><span class="line">	giantDragon g2 = giantDragon.getInstance();</span><br><span class="line">	System.out.println(g1==g2);<span class="comment">//返回true，两者是同一对象</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">giantDragon</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">giantDragon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;<span class="comment">//构造器私有化</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> giantDragon instance;<span class="comment">//定义一个类属性，</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> giantDragon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;<span class="comment">//调用getIstance函数，如果没有实例，就新建一个</span></span><br><span class="line">			instance = <span class="keyword">new</span> giantDragon();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;<span class="comment">//如果已经有的话就返回实例</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	giantDragon g1 = giantDragon.getInstance();</span><br><span class="line">	giantDragon g2 = giantDragon.getInstance();</span><br><span class="line">	System.out.println(g1==g2);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">giantDragon</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">giantDragon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> giantDragon instance = <span class="keyword">new</span> giantDragon();<span class="comment">//二者差别就在于此，饿汉式是加载类的时侯就加载完成的，即不管是否调用getInstance，类属性都被被实例化，而懒汉式只有当调用时才会实例化</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> giantDragon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>饿汉式是立即加载的方式，无论是否会用到这个对象，都会加载。<br>如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。</li>
</ol>
<p>懒汉式，是延迟加载的方式，只有使用的时候才会加载。 并且有线程安全的考量。<br>使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。</p>
<p>看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式</p>
<h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><ol>
<li>使用枚举类型时，要另外定义一个新的public类，因为一个Java文件只能有一个public类，常用于switch结构里(用来定义常量)，可以防止case越界引起程序的混乱。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hhh</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Season s: Season.Values())&#123;</span><br><span class="line">			System.out.println(s);<span class="comment">//增强型循环，变量类型+中间变量+要输出的内容</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在另外一个文件里定义枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season&#123;</span><br><span class="line">	SPRING,SUMMER,AUTUMN,WINTER<span class="comment">//没有分号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>MySQL数据库</p>
<ol>
<li>驱动程序包名：mysql-connector-Java-3.1.11-bin.jar</li>
</ol>
<ul>
<li>驱动类的名字：com.mysql.jdbc.Driver</li>
<li>JDBC URL：jdbc:mysql://dbip:port/databasename</li>
<li>说明：驱动程序包名有可能会变</li>
<li>JDBC URL其中各个部分含义如下：</li>
<li>dbip –为数据库服务器的IP地址，如果是本地可写：localhost或127.0.0.1。</li>
<li>port –为数据库的监听端口，需要看安装时的配置，缺省为3306。</li>
<li>databasename –数据库的名字。</li>
</ul>
<p>例如我的数据库就是jdbc:mysql://127.0.0.1:3306/how2java</p>
<ol start="2">
<li>数据库的增删改：</li>
</ol>
<ul>
<li>增加：insert into table_name (指定的列) values (值)<br>数据库不区分大小写，<br>ex：``` insert into hero values (null,”+”‘提莫’”+”，”+312+”,”+50+”)<br>insert into hero (hp) values (320)<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 删除：<span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> ...(<span class="keyword">where</span> 是用来定位用的)</span><br><span class="line">删除表内全部内容：<span class="keyword">delete</span> *<span class="keyword">from</span> table_name</span><br><span class="line">-改 ：<span class="keyword">UPDATE</span> 表名称 <span class="keyword">SET</span> 列名称 = 新值 <span class="keyword">WHERE</span> 列名称 = 某值</span><br><span class="line"><span class="symbol">``</span><span class="symbol">` update hero set id = 2 where hp = 59</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h1><ol>
<li>操作数据库的步骤：</li>
</ol>
<ul>
<li>根据how2j的教程将sql的jar包下好并导入</li>
<li>导入sql操作必要的包<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;<span class="comment">//创建数据库与Java的连接对象</span></span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;<span class="comment">//驱动管理类，用来获取数据库的连接</span></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;<span class="comment">//用于sql的操作，各种sql语句等</span></span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;<span class="comment">//建立statement才能对数据库进行操作，statement对象：用来进行一些简单的无参查询sql语句</span></span><br></pre></td></tr></table></figure></li>
<li>建立Connection和Statement对象，并赋空值<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection c=<span class="keyword">null</span>;</span><br><span class="line">Statement s = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li>
<li>try-catch语句，首先加载驱动类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(com.mysql.jdbc.Driver);</span><br></pre></td></tr></table></figure>
Class.forName(className)可以简单的理解为：获得字符串参数中指定的类，并初始化该类。返回与给定的字符串名称相关联类或接口的Class对象。</li>
</ul>
<p>Class.forName是一个静态方法，同样可以用来加载类。<br>该方法有两种形式：Class.forName(String name, boolean initialize,ClassLoader loader)和 Class.forName(String className)</p>
<p>第一种形式的参数 name表示的是类的全名；<br>initialize表示是否初始化类；loader表示加载时使用的类加载器。<br>第二种形式则相当于设置了参数 initialize的值为 true，loader的值为当前类的类加载器。</p>
<ul>
<li>用DriverManager.getConnection(…..)连接数据库，并赋给可操作对象S<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">		Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		 c = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8"</span>,</span><br><span class="line">				<span class="string">"root"</span>,<span class="string">"admin"</span>);</span><br><span class="line">	    	</span><br><span class="line">		  s = c.createStatement();</span><br></pre></td></tr></table></figure></li>
<li>写sql语句，并用execute函数执行sql语句<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">"delete from hero where id = 8"</span>;</span><br><span class="line">		execute(sql);</span><br></pre></td></tr></table></figure></li>
<li>由于数据库资源有限，需要结束时关闭数据库<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(s!=<span class="keyword">null</span>) </span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				s.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">try</span> &#123;</span><br><span class="line">        	    c.close();	</span><br><span class="line">        	&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">        		e.printStackTrace();</span><br><span class="line">        	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>或者用try流自动关闭，将操作写在try后的()内，这样在结束后会自动关闭括号内的操作。</p>
<ul>
<li>printStackTrace()和普通print(e)的区别在于普通报错只会提醒错了，而printStackTrace会指出错误行和错误信息。</li>
</ul>
<p>完整版</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testjdbc</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">"delete from hero where id = 8"</span>;</span><br><span class="line">		execute(sql);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="comment">//*************************************************</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">	Connection c=<span class="keyword">null</span>;</span><br><span class="line">	Statement s = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		 c = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8"</span>,</span><br><span class="line">				<span class="string">"root"</span>,<span class="string">"admin"</span>);</span><br><span class="line">	    	</span><br><span class="line">		  s = c.createStatement();</span><br><span class="line">		 </span><br><span class="line">			</span><br><span class="line">			 s.execute(sql);</span><br><span class="line">		 </span><br><span class="line">	&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(s!=<span class="keyword">null</span>) </span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				s.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">try</span> &#123;</span><br><span class="line">        	    c.close();	</span><br><span class="line">        	&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">        		e.printStackTrace();</span><br><span class="line">        	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**********************************************</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数据库的增删改：只要将sql语句改写即可，详见上一篇数据库的操作。</li>
<li>sql的查询：用ResultSet 结果集来收集来自数据库的信息，这样可以通过对结果集的操作来查询数据，方便操作。</li>
</ol>
<ul>
<li>首先导入结果集包：<code>import java.sql.ResultSet</code></li>
<li>写sql语句，即将表中所有数据都收集到结果集中</li>
<li>创建结果集对象，并用get函数得到所需信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">"select *form hero "</span>;</span><br><span class="line">ResultSet rs = s.executeQuery(sql);</span><br><span class="line"><span class="keyword">while</span> (rs.next())&#123;<span class="comment">//rs.next()是判断数据库内是否还有数据，有就执行，无就退出</span></span><br><span class="line">	<span class="keyword">int</span> hp = rs.getInt(<span class="number">4</span>);</span><br><span class="line">	String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用查询语句来验证账号密码是否正确：</li>
</ul>
<ol>
<li>将数据表中数据全部加载到结果集中，在查找，但是数据一旦大了之后，内存都放不下，不推荐这种放法</li>
<li>将账号密码写入sql语句中，在数据库中查找含有关键字的数据。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = <span class="string">"haha"</span>;</span><br><span class="line">String password = <span class="string">"thisispassword"</span>;</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">"select *from hero where name = '"</span>+name+<span class="string">"' and password = '"</span>+password+<span class="string">"';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ResultSet rs = s.executeQuery(sql);</span></span><br><span class="line"><span class="string">if(rs.next())&#123;</span></span><br><span class="line"><span class="string">	System.out.println("</span>账号密码正确<span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">else&#123;</span></span><br><span class="line"><span class="string">	System.out.println("</span>账号密码错误<span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>统计表中有多少条数据<code>select count(*)from hero</code></li>
<li>分页查询：<code>select form hero limit 0,5</code>每5个数据为一页查询。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode周赛题目</title>
    <url>/2019/12/02/leetcode/</url>
    <content><![CDATA[<h1 id="164周赛第1题"><a href="#164周赛第1题" class="headerlink" title="164周赛第1题"></a>164周赛第1题</h1><p> 访问所有点的最小时间（切比雪夫距离）</p>
<p>平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。请你计算访问所有这些点需要的最小时间（以秒为单位）。</p>
<p>你可以按照下面的规则在平面上移动：</p>
<p>每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。<br>必须按照数组中出现的顺序来访问这些点。</p>
<p>在二维坐标中，二个点之间的距离定义为其各座标数值差绝对值的最大值。以(x1,y1)和(x2,y2)二点为例，其切比雪夫距离为max(|x2-x1|,|y2-y1|)。</p>
<a id="more"></a>

<p><img src="/2019/12/02/leetcode/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB.png" alt><br><img src="/2019/12/02/leetcode/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB1.png" alt><br>points.length是点的个数，范围是[1,100]，points[i].length是坐标长度，为2（x，y）。x，y距离都是-1000，1000</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(<span class="keyword">int</span>** points, <span class="keyword">int</span> pointsSize, <span class="keyword">int</span>* pointsColSize)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!points)   <span class="comment">//是points（点个数）为0的特殊情况</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i;i&lt;pointsSize<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">a=<span class="built_in">abs</span>(points[i][<span class="number">0</span>]-points[i+<span class="number">1</span>][<span class="number">0</span>]);<span class="comment">//x的最大值，i表示第几个点，0是每个元素的第一个值，即横坐标</span></span><br><span class="line">b=<span class="built_in">abs</span>(points[i][<span class="number">1</span>]-points[i+<span class="number">1</span>][<span class="number">1</span>]);<span class="comment">//y的最大值，i表示第几个点，1是每个元素的第一个值，即纵坐标</span></span><br><span class="line"><span class="keyword">if</span> (a&gt;=b)    <span class="comment">//a的差值大，就加a</span></span><br><span class="line">&#123;</span><br><span class="line">sum=sum+a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sum=sum+b;  <span class="comment">//b的差值大，就加b</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="164周赛第2题"><a href="#164周赛第2题" class="headerlink" title="164周赛第2题"></a>164周赛第2题</h1><p> 统计参与通信的服务器（逆向思维，从反面，减法出发）<br> 类似求某种存在多少符合条件的结果时，有时用逆向思维，用总数减去不符合的结果可能更简便。</p>
<p> 这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。</p>
<p>如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。</p>
<p>请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。</p>
<p>示例 1：<br><img src="/2019/12/02/leetcode/%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4.jpg" alt></p>
<p>输入：grid = [[1,0],[0,1]]<br>输出：0<br>解释：没有一台服务器能与其他服务器进行通信。<br>示例 2：<br><img src="/2019/12/02/leetcode/%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B41.jpg" alt></p>
<p>输入：grid = [[1,0],[1,1]]<br>输出：3<br>解释：所有这些服务器都至少可以与一台别的服务器进行通信。<br>示例 3：</p>
<p><img src="/2019/12/02/leetcode/%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B42.jpg" alt></p>
<p>输入：grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]<br>输出：4<br>解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。</p>
<p>提示：<br>m == grid.length   //行数<br>n == grid[i].length  //列数<br>1 &lt;= m &lt;= 250<br>1 &lt;= n &lt;= 250<br>grid[i][j] == 0 or 1  //存在or不存在</p>
<p>思路：</p>
<ol>
<li>由第一题启发，先遍历数组，将服务器位置输入，在统计能通信的（先遍历行，存在两个以上的服务器就是一台，列同理，但是缺点明显，会有重复的不好甄别）。</li>
<li>因此选用第二种方法，统计总服务器数目，减去不合结果的服务器（就是那台服务器所在行和列都只有一个1。<br>建立row数组用来存放每行服务器的数目，col数组用来存放每列服务器的数目，遍历数组，如果grid[row][col]存在服务器，且row=1，col=1.则此服务器无法与其他服务器通信，总数减一。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计所有服务器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">			row[i]++;</span><br><span class="line">			col[j]++;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除不能通信的服务器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>&amp;&amp;col[j]==<span class="number">1</span>&amp;&amp;row[i]==<span class="number">1</span>)&#123;</span><br><span class="line">			count--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="leetcode数组算法"><a href="#leetcode数组算法" class="headerlink" title="leetcode数组算法"></a>leetcode数组算法</h1><ol>
<li>删除数组中重复元素：</li>
</ol>
<ul>
<li>复杂算法：对数组进行遍历，找出重复元素个数，并并将其后的元素依次覆盖。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span> <span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">//p是数组首元素的地址，即数组名，size是数组大小</span></span><br><span class="line">	<span class="keyword">int</span> i,count=<span class="number">0</span>,j,i1;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;<span class="built_in">size</span>;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]==a[j])&#123;</span><br><span class="line">			count++;</span><br><span class="line">			<span class="keyword">for</span> (i1=i;i1&lt;<span class="built_in">size</span><span class="number">-1</span>;i1++)&#123;</span><br><span class="line">                    a[i1]=a[i1+<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">size</span>-count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>循环比较前后两个数字，如果相同就跳过，如果不同就将这个数字存进当前数组(数组下标从0开始)，并且len++；<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span> <span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>各种工具的问题和解决办法</title>
    <url>/2019/12/01/problem/</url>
    <content><![CDATA[<h1 id="devc-中文乱码"><a href="#devc-中文乱码" class="headerlink" title="devc++中文乱码"></a>devc++中文乱码</h1><p>是因为dev采用ANCI编码，不是用UTF-8编码<br>解决办法： </p>
<ul>
<li><p>用notpadc++打开，选择ANCI编码。</p>
<a id="more"></a>
<p><img src="/2019/12/01/problem/devc++.png" alt></p>
<ul>
<li>直接在dev中编辑</li>
</ul>
</li>
</ul>
<hr>
<h1 id="dev中斜杠报错"><a href="#dev中斜杠报错" class="headerlink" title="dev中斜杠报错"></a>dev中斜杠报错</h1><p>是不支持c++注释语法，误点击编辑器选项<br>解决办法：将<code>支持所有ANCI标准设置为NO</code><br><img src="/2019/12/01/problem/devc++1.png" alt></p>
<hr>
<h1 id="hexo中出现的中文乱码现象"><a href="#hexo中出现的中文乱码现象" class="headerlink" title="hexo中出现的中文乱码现象"></a>hexo中出现的中文乱码现象</h1><p> 第一步： 首先找到根目录下_config.yml文件，将langue字段设为zh-Hans或者zh-CN（简体中文），具体何种类型取决于theme主题中source文件中的language文件夹中有何种语言文件。<br><img src="/2019/12/01/problem/config_language.png" alt></p>
<p><img src="/2019/12/01/problem/theme_language.png" alt><br> 第二步： 出现乱码可能是因为用记事本编辑没有使用UTF-8编码，解决办法：下载文本编辑器（例如sublime）进行编辑。</p>
<p><img src="/2019/12/01/problem/sublime_encode.png" alt><br> 第三步： 点击sublime中file下的save with Encoding，选择UTF-8，<br> 直接点击save可能会出现警告.</p>
<hr>
<h1 id="hexo的图片上传"><a href="#hexo的图片上传" class="headerlink" title="hexo的图片上传"></a>hexo的图片上传</h1><p>  在根目录下建立与文章同名的文件夹，将图片放进去引用即可，或者用网络地址引用。<br> <img src="/2019/12/01/problem/image_post.png" alt></p>
<hr>
<h1 id="图标点击显示找不到页面。"><a href="#图标点击显示找不到页面。" class="headerlink" title="图标点击显示找不到页面。"></a>图标点击显示找不到页面。</h1><p><img src="/2019/12/01/problem/icon.png" alt><br>第一步：打开主题目录设置文件，找到menu。<br><img src="/2019/12/01/problem/menu.png" alt><br>第二步：将每个图标斜杠/后的空格删去。<br><img src="/2019/12/01/problem/menu1.png" alt></p>
<hr>
<h1 id="文章添加多个tags"><a href="#文章添加多个tags" class="headerlink" title="文章添加多个tags"></a>文章添加多个tags</h1><p>不能直接在tags标签后用空格隔开标签，应该用方括号中间用逗号隔开,<br>否则会出现文章无法上传的问题。</p>
<hr>
<h1 id="hexo页面上传"><a href="#hexo页面上传" class="headerlink" title="hexo页面上传"></a>hexo页面上传</h1><ol>
<li>标签和其他页面的格式要符合hexo的表准，单个标签用双引号，多个用方括号，中间不用双引号，否则页面无法上传。</li>
</ol>
<hr>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><ol>
<li>navicat 10061(MySQL服务未开启，无法连接到数据库)，是由于再金山毒霸里开启了开机加速，导致MySQL被禁止开机自启动，取消限制后任然没有作用，就可以通过手动启动来解决。</li>
</ol>
<ul>
<li>win + R启动运行程序，输入services.msc<br><img src="/2019/12/01/problem/mysql.png" alt></li>
<li>找到mysql服务打开即可<br><img src="/2019/12/01/problem/mysql1.png" alt></li>
</ul>
]]></content>
      <categories>
        <category>problem solution</category>
      </categories>
      <tags>
        <tag>解决办法，工具软件</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希函数和哈希表（其他查找函数）</title>
    <url>/2019/11/29/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>定义：根据哈希函数和冲突处理办法将数据存储在一段连续的空间中。</p>
<p>不同于其他查找函数需要对值进行匹配，哈希表在建立时为每一个数据建立一个独一无二的关键字，这样查找时可以根据关键字直接找到数据。</p>
<a id="more"></a>

<hr>
<h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><p>哈希函数需要满足两个条件，假设哈希表有m个关键字，则取值范围是<br>[0，m-1]。</p>
<ol>
<li>哈希函数的值域必须在[0，m-1]的范围内。</li>
<li>保证哈希函数的每个值在[0,m-1]内的概率相等。</li>
</ol>
<hr>
<h1 id="哈希函数的几种办法"><a href="#哈希函数的几种办法" class="headerlink" title="哈希函数的几种办法"></a>哈希函数的几种办法</h1><ol>
<li>直接定址法：适用与线性数据，比如年龄，日期等</li>
<li>数字分析法：适用与某些数据中有大量重复字段，且可以预知全部的可能出现的值，取其中若干的字段作为关键字。</li>
<li>平方取中法：适用与字段较短，可以先平方，再取中间的字段作为关键字，因为中间的字段与每个数据都有关系，可以增加概率的平均性。</li>
<li>折叠法：将关键值分割为几个位数相同的部分，取这几个部分的叠加和作为哈希地址。</li>
</ol>
<ul>
<li>移位叠加<br>   各部分按照最低位对齐（舍去进位，即相加后多出切割位的数字），然后相加。</li>
<li>间界叠加<br>   关键字值从一端向另一端沿分界线来回折叠，然后对齐相加。</li>
</ul>
<ol start="5">
<li>除留余数法：被除数必须是素数，否则会出现关键字大量重复。（最大公倍数原理）</li>
</ol>
<hr>
<h1 id="处理冲突方法"><a href="#处理冲突方法" class="headerlink" title="处理冲突方法"></a>处理冲突方法</h1><p>当哈希函数值相同时，位置已经被其他数据占用，则按照冲突处理方法寻找下一个位置。</p>
<ol>
<li>开放定址法：令Hi=(H(key)+di)%m,其中H(key)时哈希函数，di是增量序列。</li>
</ol>
<ul>
<li>若di取1，2，3，4….m-1，则为线性探测再散列。</li>
<li>若di取1^2,-1^2,2^2,-2^2..+k^2,-k^2,则为二次探测再散列。</li>
<li>若di取伪随机数序列，则称伪随机探测再散列。</li>
</ul>
<ol start="2">
<li>链表寻址法： 对重复数据建立链表，并且将每个链表有序排列，</li>
<li>公共溢出区法： 将哈希表的一部分作为公共区，重复数据依次放入。</li>
</ol>
<hr>
<h1 id="哈希表中查找元素"><a href="#哈希表中查找元素" class="headerlink" title="哈希表中查找元素"></a>哈希表中查找元素</h1><p>  与插入的方法差不多，按关键字寻找，遇到冲突按照法则寻找。</p>
<hr>
<h1 id="链表-哈希表的基础"><a href="#链表-哈希表的基础" class="headerlink" title="链表(哈希表的基础)"></a>链表(哈希表的基础)</h1><ol>
<li><p>链表的实质就是由结构体转变而来，不过多了一个指针域。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; node ;<span class="comment">//重命名结构体变量，方便下一步</span></span><br></pre></td></tr></table></figure>
<p>重命名typedef可以避免字母打错等错误。</p>
</li>
<li><p>头节点：是链表的第一个节点，一般不存放数据(用来指向整个链表)。</p>
</li>
<li><p>malloc函数(动态内存分配，链表创建的基础)：其函数原型为void <em>malloc(unsigned int size)，size是输入数据的长度，返回类型是void</em>类型，需要指定类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Head = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));<span class="comment">//定义头节点</span></span><br><span class="line"><span class="comment">//node是重命名后的结构体变量名(即相当与指定int*类型指针一样，sizeof()*n用来计算n个结构体的长度。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>！！！链表建立时都是建的结构体指针，而不是结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node *Head;</span><br><span class="line">node *pend;</span><br><span class="line">node *pnew;</span><br></pre></td></tr></table></figure></li>
<li><p>建立流程：</p>
<ul>
<li>定义头节点(Head)，尾节点(pend)，新节点(pnew)<br>由于要用头节点来指向整个链表，数据域不赋值，因此需要一个节点来代替头节点进行节点的更替。</li>
<li>确定输入多少个值(由具体情况而定)，每次输入都要为pnew动态分配内存，输入值赋给新节点的数据域，旧节点的指针域指向新节点，新节点变为旧节点。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node *Head;<span class="comment">//创建头节点</span></span><br><span class="line">    Head = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">	Head-&gt;next = <span class="literal">NULL</span>;<span class="comment">// 头节点后面没有新节点，所以是NULL</span></span><br><span class="line">	node *pnew,*pend;</span><br><span class="line">	pend = Head;<span class="comment">// 当输入数据为0个时，尾节点就等于头节点，用尾节点代替头节点进行连接操作</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">for</span>(;n!=<span class="number">-1</span>;)&#123;</span><br><span class="line">		pnew = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));<span class="comment">//为新节点分配内存</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		pnew-&gt;data = n;<span class="comment">// 新节点的数据域赋值为n</span></span><br><span class="line">		pend-&gt;next = pnew; <span class="comment">//旧节点的指针域指向新节点，不然下一步无法完成，因为旧节点没有新节点的地址，没有办法找到新节点</span></span><br><span class="line">		pend = pnew; <span class="comment">//新节点变为旧节点</span></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">pend-&gt;next = <span class="literal">NULL</span>;<span class="comment">// 尾节点的指针域赋为NULL，表示后面没有新元素</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<hr>
<h1 id="顺序查找法"><a href="#顺序查找法" class="headerlink" title="顺序查找法"></a>顺序查找法</h1><p>顺序查找法：<br>特点：对每一个数据进行比较，如果符合就返回。<br>优点：空间复杂度小，数据小时处理有优势，思路简单。<br>缺点：时间复杂度大，数据一大运行时间会大大增加。<br>时间复杂度：最好是找1次就可以，最坏是找n次，平均是（n+1）/2.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">顺序查找法：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">200</span>];</span><br><span class="line">	<span class="keyword">int</span> number,i;</span><br><span class="line">	<span class="keyword">int</span> target;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);                <span class="comment">//输入数组</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;target);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]==target)&#123;                  <span class="comment">//判断是否相等</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d is in the list\n"</span>,target);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"target's location is %d(从1开始计数)"</span>,i+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找法：<br>特点：数据必须要有序排列。<br>优点：运行时间比顺序查找法少，数据大时有优势。<br>缺点：数据必须有序，先得排序，空间复杂度比顺序查找法高，思路不容易想到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s[<span class="number">200</span>];</span><br><span class="line">	<span class="keyword">int</span> number,i,j;</span><br><span class="line">	<span class="keyword">int</span> target,t,flag=<span class="number">0</span>,a,b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;number-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[j+<span class="number">1</span>]&lt;s[j])&#123;                  <span class="comment">//冒泡排序，对输入数组进行升序</span></span><br><span class="line">				t=s[j];</span><br><span class="line">				s[j]=s[j+<span class="number">1</span>];</span><br><span class="line">				s[j+<span class="number">1</span>]=t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	a=s[<span class="number">0</span>];</span><br><span class="line">	b=s[number<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;target);	</span><br><span class="line">		<span class="keyword">while</span>(a&lt;=b)&#123;</span><br><span class="line">			<span class="keyword">if</span>(target==(a+b)/<span class="number">2</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d is in the list"</span>,target);<span class="comment">//target与中间值相等则输出。</span></span><br><span class="line">				flag++;   <span class="comment">//在数组中则为1，不在则为0，输出notfind</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;(a+b)/<span class="number">2</span>)&#123;</span><br><span class="line">				b=(a+b)/<span class="number">2</span><span class="number">-1</span>;             <span class="comment">//如果target在中值的左边，则a不变，将中值-1作为b，即在中值左边的区间内查找 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;(a+b)/<span class="number">2</span>)&#123;</span><br><span class="line">				a=(a+b)/<span class="number">2</span>+<span class="number">1</span>;          <span class="comment">//同上，在中值右边查找</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"not find"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="选择排序法"><a href="#选择排序法" class="headerlink" title="选择排序法"></a>选择排序法</h1>]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c语言，数据结构，查找算法，链表</tag>
      </tags>
  </entry>
  <entry>
    <title>函数输出水仙花数（求各位数之和新解）</title>
    <url>/2019/11/24/pta/</url>
    <content><![CDATA[<h1 id="求各位数之和新解"><a href="#求各位数之和新解" class="headerlink" title="求各位数之和新解"></a>求各位数之和新解</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">          temp=x%<span class="number">10</span>;<span class="comment">//取出最后一位数</span></span><br><span class="line">          x=x/<span class="number">10</span>;<span class="comment">//去掉最后一位数</span></span><br><span class="line">          y=temp+y*<span class="number">10</span>;<span class="comment">//在还原</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是求出未知数各个位置的和。<br>与之前从第一位开始求不同，这种更方便，无需根据具体位数设置相应个数的变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* run this program using the console pauser or add your own getch, system("pause") or input loop */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line"><span class="keyword">int</span> i,a,b,c,d,e,f,g,t; </span><br><span class="line"><span class="keyword">if</span>(N==<span class="number">3</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">100</span>;i&lt;=<span class="number">999</span>;i++)&#123;</span><br><span class="line">		a=i/<span class="number">100</span>;</span><br><span class="line">		b=(i%<span class="number">100</span>)/<span class="number">10</span>;</span><br><span class="line">		c=(i%<span class="number">100</span>)%<span class="number">10</span>;</span><br><span class="line">	t=a*a*a+b*b*b+c*c*c;</span><br><span class="line">    <span class="keyword">if</span>((a*<span class="number">100</span>+b*<span class="number">10</span>+c)==t)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a*<span class="number">100</span>+b*<span class="number">10</span>+c);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(N==<span class="number">4</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1000</span>;i&lt;=<span class="number">9999</span>;i++)&#123;</span><br><span class="line">		a=i/<span class="number">1000</span>;</span><br><span class="line">		b=i%<span class="number">1000</span>/<span class="number">100</span>;</span><br><span class="line">		c=i%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">		d=i%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">	t=a*a*a*a+b*b*b*b+c*c*c*c+d*d*d*d;</span><br><span class="line">    <span class="keyword">if</span>((a*<span class="number">1000</span>+b*<span class="number">100</span>+c*<span class="number">10</span>+d)==t)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line"> <span class="keyword">if</span>(N==<span class="number">5</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">10000</span>;i&lt;<span class="number">99999</span>;i++)&#123;</span><br><span class="line">		a=i/<span class="number">10000</span>;</span><br><span class="line">		b=(i%<span class="number">10000</span>)/<span class="number">1000</span>;</span><br><span class="line">		c=(i%<span class="number">10000</span>)%<span class="number">1000</span>/<span class="number">100</span>;</span><br><span class="line">		d=(i%<span class="number">10000</span>)%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">		e=(i%<span class="number">10000</span>)%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">	t=a*a*a*a*a+b*b*b*b*b+c*c*c*c*c+d*d*d*d*d+e*e*e*e*e;</span><br><span class="line">    <span class="keyword">if</span>(a*<span class="number">10000</span>+b*<span class="number">1000</span>+c*<span class="number">100</span>+d*<span class="number">10</span>+e==t)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">if</span>(N==<span class="number">6</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">100000</span>;i&lt;<span class="number">999999</span>;i++)&#123;</span><br><span class="line">		a=i/<span class="number">100000</span>;</span><br><span class="line">		b=i%<span class="number">100000</span>/<span class="number">10000</span>;</span><br><span class="line">		c=i%<span class="number">100000</span>%<span class="number">10000</span>/<span class="number">1000</span>;</span><br><span class="line">		d=i%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>/<span class="number">100</span>;</span><br><span class="line">		e=i%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">		f=i%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">	t=a*a*a*a*a*a+b*b*b*b*b*b+c*c*c*c*c*c+d*d*d*d*d*d+e*e*e*e*e*e+f*f*f*f*f*f;</span><br><span class="line">    <span class="keyword">if</span>((a*<span class="number">100000</span>+b*<span class="number">10000</span>+c*<span class="number">1000</span>+d*<span class="number">100</span>+e*<span class="number">10</span>+f)==t)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a*<span class="number">100000</span>+b*<span class="number">10000</span>+c*<span class="number">1000</span>+d*<span class="number">100</span>+e*<span class="number">10</span>+f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">if</span>(N==<span class="number">7</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1741723</span>;i&lt;<span class="number">9999999</span>;i++)&#123;</span><br><span class="line">		a=i/<span class="number">1000000</span>;</span><br><span class="line">		b=i%<span class="number">1000000</span>/<span class="number">100000</span>;</span><br><span class="line">		c=i%<span class="number">1000000</span>%<span class="number">100000</span>/<span class="number">10000</span>;</span><br><span class="line">		d=i%<span class="number">1000000</span>%<span class="number">100000</span>%<span class="number">10000</span>/<span class="number">1000</span>;</span><br><span class="line">		e=i%<span class="number">1000000</span>%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>/<span class="number">100</span>;</span><br><span class="line">		f=i%<span class="number">1000000</span>%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">		g=i%<span class="number">1000000</span>%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">		t=a*a*a*a*a*a*a+b*b*b*b*b*b*b+c*c*c*c*c*c*c+d*d*d*d*d*d*d+e*e*e*e*e*e*e+f*f*f*f*f*f*f+g*g*g*g*g*g*g;</span><br><span class="line">	<span class="keyword">if</span>((a*<span class="number">1000000</span>+b*<span class="number">100000</span>+c*<span class="number">10000</span>+d*<span class="number">1000</span>+e*<span class="number">100</span>+f*<span class="number">10</span>+g)==t)</span><br><span class="line">	                        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a*<span class="number">1000000</span>+b*<span class="number">100000</span>+c*<span class="number">10000</span>+d*<span class="number">1000</span>+e*<span class="number">100</span>+f*<span class="number">10</span>+g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然上面也可以用for循环+pow函数但还是不够简便。</p>
<hr>
<h1 id="逆序数输出（由末位新解联想）"><a href="#逆序数输出（由末位新解联想）" class="headerlink" title="逆序数输出（由末位新解联想）"></a>逆序数输出（由末位新解联想）</h1><ol>
<li><p>数学法：通过末尾取余将末尾数取出，在依次*10，便能输出逆序数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number,x,t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">	<span class="keyword">while</span>(number!=<span class="number">0</span>)&#123;</span><br><span class="line">		t=t*<span class="number">10</span>+number%<span class="number">10</span>;  <span class="comment">//每次t向前移动一位</span></span><br><span class="line">	    number/=<span class="number">10</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,t);		</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串法：转为字符串逆序输出。。。。。</p>
</li>
</ol>
<hr>
<h1 id="另一种应用-回文数"><a href="#另一种应用-回文数" class="headerlink" title="另一种应用(回文数)"></a>另一种应用(回文数)</h1><ol>
<li><p>存为数组，用a[i]与a[n-i-1]相互比较</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(a[i]!=a[n-i<span class="number">-1</span>])&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"false"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		flag++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"true"</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>反转一半数：用末尾数新解，对输入数后一半进行逆序排序，将它和变化后的number比较。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> number,t=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">	<span class="keyword">if</span>(number&lt;<span class="number">0</span>||(number%<span class="number">10</span>==<span class="number">0</span>&amp;&amp;number!=<span class="number">0</span>))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"false"</span>);         <span class="comment">// 数字为负数或者末尾是0但首位肯定不是0，就不可能是回文数</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(number&gt;t)&#123; <span class="comment">//当number&gt;t时，说明t的位数比number小，即没有到中间，并且中间数肯定等于自身，不需判定。</span></span><br><span class="line">			t=t*<span class="number">10</span>+number%<span class="number">10</span>;</span><br><span class="line">			number/=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(number==t)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"true"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"false"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>求各个位数和新解</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2019/11/23/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="scanf输入字符串"><a href="#scanf输入字符串" class="headerlink" title="scanf输入字符串"></a>scanf输入字符串</h1><p>scanf输入的字符串中不能有空格，而gets()可以，若要用scanf输入多个字符，要先定义n(字符串个数)个字符数组，且在scanf内%s中间不用空格分隔</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">30</span>],str2[<span class="number">30</span>],str3[<span class="number">30</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s%s"</span>,str1,str2,str3); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="字符串存储在一个数组中"><a href="#字符串存储在一个数组中" class="headerlink" title="字符串存储在一个数组中"></a>字符串存储在一个数组中</h1><p>用二维数组定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">3</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str1[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,str1[<span class="number">1</span>]);  <span class="comment">//输出第二个字符串</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><ol>
<li>puts函数：函数中可以加入转义符，且在输出结束字符串后会自动转行<br><code>char str[]={&quot;hello\nworld!&quot;};</code></li>
<li>strcat函数：<code>strcat(str1,str2);</code>是将两个字符串连接起来，返回值是字符串数组1的地址，并且注意字符串1的长度必须足够大。</li>
<li>strcpy：字符串复制函数<code>strcpy(str1,str2)</code>若是采用数组元素一个个赋值不方便，直接用函数赋值。<br>strcpy可以是数组名复制，也可以是字符串常量<code>strcpy(str1,&quot;china!&quot;);</code></li>
<li>strcmp：字符串比较函数（strcmp（str1，str2）），若str1&lt; str2，返回值小于0，若str1&gt;str2,返回值大于0.若str1==str2，则返回0（用来判断字符串的结束标志）。</li>
</ol>
<h1 id="字符串数组与函数名做参"><a href="#字符串数组与函数名做参" class="headerlink" title="字符串数组与函数名做参"></a>字符串数组与函数名做参</h1><ol>
<li>当要通过某个特定值来确定函数是否结束时，用strcmp==0来判断，而不    用srt[i]==’#’或者str [i] [j]=’#’来判断,即使特 定符号已经出现程序也会直接跳过(具体原因不知，有空再说)。</li>
<li>给字符串数组赋结束标志’\0’时，不能用str[i]==’\0’，而是应用str<br>[i][j]==’\0’来赋值(可能因为一个字符只能放一个数组格)</li>
<li>数组名做参：定义函数时，如果定义二维数组，那么列的值不能为空<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> fet (<span class="built_in">int</span> han[][<span class="number">20</span>])&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>注意形参要带变量类型，但是调用函数时不需要，尤其是字符串数组，只要带入数组名即可不需要包括后面[]的大小</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">fet(<span class="name">han</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>字符串，c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
