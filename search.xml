<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>servlet的使用</title>
    <url>/2020/01/11/servlet/</url>
    <content><![CDATA[<h1 id="servlet的定义"><a href="#servlet的定义" class="headerlink" title="servlet的定义"></a>servlet的定义</h1><ol>
<li>servlet是sun公司开发的一款用于开发动态web资源的技术，web资源分为动态和静态的两种。</li>
<li>动态和静态的区别</li>
</ol>
<ul>
<li>动态web资源是客户端请求的动态资源，先将资源交于web容器，在由web容器连接数据库，数据库处理数据后交由web容器返回给客户端解析渲染处理</li>
<li>静态资源是web容器从内存中直接调取返回给客户端</li>
<li>静态资源一般是设计好的html页面，而动态资源是根据设计好的程序按照需求来动态响应</li>
<li>静态资源的交互性差，动态资源的交互性好</li>
<li>静态资源不需要数据库参与程序处理，而动态资源需要</li>
</ul>
<h1 id="servlet的实现方法"><a href="#servlet的实现方法" class="headerlink" title="servlet的实现方法"></a>servlet的实现方法</h1><p>sun在java中提供了servlet的接口，只需要完成两个步骤</p>
<ul>
<li>编写Java类，实现servlet接口</li>
<li>将Java类部署到服务器上</li>
</ul>
<h1 id="一些杂谈"><a href="#一些杂谈" class="headerlink" title="一些杂谈"></a>一些杂谈</h1><ol>
<li><p>得到表单提交的数据用String name = request.getParameter(“name”);<br>这里request.getParameter(“name”)的作用是获得提交的表单中name值为“name”的value，这是通过表单标签的action属性完成，这个属性是规定了表单获得的数据发送到哪个页面</p>
</li>
<li><p>Servlet的框架是由两个Java包组成:javax.servlet和javax.servlet.http. 在javax.servlet包中定义了所有的Servlet类都必须实现或扩展的的通用接口和类.在javax.servlet.http包中定义了采用HTTP通信协议的HttpServlet类.</p>
</li>
<li><p>Servlet的框架的核心是javax.servlet.Servlet接口,所有的Servlet都必须实现这一接口.在Servlet接口中定义了5个方法,其中有3个方法代表了Servlet的声明周期:</p>
</li>
<li><p>init方法,负责初始化Servlet对象<br>service方法,负责相应客户的请求<br>destory方法,当Servlet对象退出声明周期时,负责释放占有的资源</p>
</li>
<li><p>ServletConfig:代表当前Servlet在web.xml中的配置信息（用的不多）</p>
</li>
</ol>
<p>String getServletName()  – 获取当前Servlet在web.xml中配置的名字<br>String getInitParameter(String name) – 获取当前Servlet指定名称的初始化参数的值<br>Enumeration getInitParameterNames()  – 获取当前Servlet所有初始化参数的名字组成的枚举<br>ServletContext getServletContext()  – 获取代表当前web应用的ServletContext对象<br>在Servlet的配置文件中，可以使用一个或多个<init-param>标签为servlet配置一些初始化参数。</init-param></p>
<p>当servlet配置了初始化参数后，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig对象传递给servlet。进而，程序员通过ServletConfig对象就可以得到当前servlet的初始化参数信息。</p>
<p>这样做的好处是：如果将数据库信息、编码方式等配置信息放在web.xml中，如果以后数据库的用户名、密码改变了，则直接很方便地修改web.xml就行了，避免了直接修改源代码的麻烦</p>
<ol start="6">
<li><p>不管是客户端还是服务端，要想跳转，就得把跳转页面放在web文件夹下，而不是放在WEB-INF文件夹下</p>
</li>
<li><p>servlet用web动态项目做的project，打开时要加127.0.0.1:8080/j2ee/listHero，不直接加listHero，并且点击增删查改操作时，点击跳转后会无法跳转，这也是由于上述原因，只要按上面格式输入就好(其实就是相对路径和绝对路径)，通过web动态项目run as就是相对路径，要加上项目名称</p>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat的问题及解决办法</title>
    <url>/2020/01/10/tomcat/</url>
    <content><![CDATA[<h1 id="tomcat匹配的jdk"><a href="#tomcat匹配的jdk" class="headerlink" title="tomcat匹配的jdk"></a>tomcat匹配的jdk</h1><ol>
<li>如果是用的how2j提供的tomcat，那么Java的jdk版本必须是1.8(我之前用的是13，打开tomcat就闪退)，具体安装教程how2j上也有。</li>
<li>如果想用url访问html文件，必须在tomcat/bin/webapps下手动新建一个ROOT(大写)文件夹，才能在网站上看见。</li>
<li>tomcat的乱码显示问题</li>
<li>部署项目时要加上端口号，并且在server配置文件里写文件路径时，要新建一个web项目文件</li>
<li>用eclipsse打开时，会发现报failed to find JDK….jvm,这是因为jdk版本与eclipse版本不一致导致，全部用how2j提供的版本进行下载</li>
</ol>
<h1 id="部署servlet时的错误"><a href="#部署servlet时的错误" class="headerlink" title="部署servlet时的错误"></a>部署servlet时的错误</h1><ol>
<li>将WEB-INF文件错打成了WEB_INF,</li>
</ol>
]]></content>
      <categories>
        <category>problem solution</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法实战</title>
    <url>/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ol>
<li>通过指针引用数组元素，<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a [<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p=&amp;a;</span><br><span class="line">(p+i)<span class="comment">//第i个元素的地址</span></span><br><span class="line">*(p+i)<span class="comment">//第i个元素</span></span><br></pre></td></tr></table></figure>
！！！！数组名为第一个元素a[i]的地址，是一个指针常量，不能进行a++运算，<br>要用a+1进行运算(递归注意，就是这里错的)。但是用<code>int *p=a</code>之后就可以用p++。</li>
<li>对数组进行操作的话，函数只要传入首个元素的地址就可以(数组是连续内存)，再知道数组的长度，就可以对数组进行索引和一系列操作<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">     <span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line">     <span class="keyword">int</span> x = <span class="built_in">max</span>(a,n);</span><br><span class="line">     <span class="keyword">double</span> m = average(a,n);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"max = %d,average =  %f"</span>,x,m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> *p;<span class="comment">//定义一个指针，指向a数组，这样可以执行p++操作（详见1）</span></span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">max</span> = *p;</span><br><span class="line">     <span class="keyword">for</span>(p=a;p&lt;a+n;p++)&#123;  <span class="comment">//n是数组长度，p向后一个不是二进制的+1，而是数组元素类型占用内存+1(这样就直观表现为数组元素向后+1)</span></span><br><span class="line">     	<span class="keyword">if</span>(*p&gt;<span class="built_in">max</span>)&#123;</span><br><span class="line">     		<span class="built_in">max</span>=*p;</span><br><span class="line">     	&#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       itn *p;</span><br><span class="line">       <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(p=a;p&lt;a+n;p++)&#123;</span><br><span class="line">       	sum+=(<span class="keyword">double</span>)*p;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">double</span> average = sum/(<span class="keyword">double</span>)n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> average;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>对字符串数组进行操作时，容易忘记最后加上一个中止符号(‘\0’),<br>先省略。。。。。。</li>
</ul>
<ol start="3">
<li>行指针和二维数组</li>
</ol>
<ul>
<li>行指针的定义方式<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据类型  (* 变量名)[每行的元素个数]</span></span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>]<span class="comment">//每行元素个数为4个</span></span><br></pre></td></tr></table></figure></li>
<li>访问具体元素只能用列指针访问，有三种形式<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//数组下标访问</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//列指针访问</span></span><br><span class="line">*(a[<span class="number">2</span>]+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//行指针访问</span></span><br><span class="line">*(*(a+<span class="number">2</span>)+<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li>
<li>编写子函数时，如果是二维数组，那么传入的参数就得是行指针，而不是普通指针<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">ArrayOutput</span> <span class="params">(<span class="keyword">int</span> (*p)[<span class="number">4</span>],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="4">
<li><p>数组名是地址常量，用++操作是无法操作的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++,a++)&#123;</span><br><span class="line"> prinf(<span class="string">"%d"</span>,*a);<span class="comment">//这段是错误的，因为a是地址常量，++无法改变地址，而a+i就可以访问数组其它元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++,a++)&#123;</span><br><span class="line"> prinf(<span class="string">"%d"</span>,*(a+i));<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符数组和字符指针<br>区别：</p>
</li>
</ol>
<p>-字符数组有无穷个元素组成，每个元素存放一个字符，而字符指针中存放的是字符串首字符的地址，不是存放的字符串</p>
<ul>
<li>可以对字符串指针赋值，而不能对数组名赋值<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *s ;</span><br><span class="line">s=<span class="string">"i love china!"</span>;<span class="comment">//对</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">13</span>];</span><br><span class="line">a[<span class="number">0</span>]=<span class="string">"i"</span>;<span class="comment">//对</span></span><br><span class="line">a=<span class="string">"i love china"</span>;<span class="comment">//错</span></span><br></pre></td></tr></table></figure></li>
<li>编译时为字符串数组分配若干个存储单元，为字符指针分配一个存储单元</li>
<li>字符指针的值可以改变，而数组名是常量地址，无法更改<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *s;</span><br><span class="line">s+=<span class="number">7</span>;<span class="comment">//对</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">13</span>];</span><br><span class="line">a+=<span class="number">7</span><span class="comment">//错</span></span><br></pre></td></tr></table></figure></li>
<li>初始化并不等价<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">13</span>]=<span class="string">"i love china"</span>;<span class="comment">//正确，</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">13</span>];</span><br><span class="line">str[]=<span class="string">"i love china"</span>;<span class="comment">//错误，因为一旦数组大小确定了之后，在接下来的引用中都必须带上下标，并且数组名是常量地址，无法赋值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str*=<span class="string">"i love china"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str*;</span><br><span class="line">str=<span class="string">"i love china"</span><span class="comment">//这是等价的，因为str*中存储的是地址</span></span><br></pre></td></tr></table></figure></li>
<li>字符数组中的元素值是可以改变的，但是字符指针中的值是不能改变的，因为常量是不能改变的，数组中的并不是常量，而是复制在数组中的副本，但是指针中所指向的就是常量<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">13</span>]=<span class="string">"i love china"</span>;</span><br><span class="line">str[<span class="number">3</span>]=<span class="string">"e"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *str=<span class="string">"i love china"</span>;</span><br><span class="line">*(str+<span class="number">2</span>)=<span class="string">"e"</span>;<span class="comment">//错</span></span><br></pre></td></tr></table></figure></li>
<li>可以用字符指针指向一个格式字符串，这样就可以减少输入麻烦<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *format;</span><br><span class="line">format=<span class="string">"%d %d"</span>;</span><br><span class="line"><span class="built_in">printf</span>(format,a,b);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="6">
<li>指针数组<br>指针数组中存放的是地址，适合用来处理与字符串相关的问题，比用字符数组更加灵活，并且字符串一般是长度不相等的，用指针比二维数组节省空间</li>
</ol>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><ol>
<li><p>概念：递归算法的思想实质就是分治策略，将一个问题拆解成不能再拆解的最小问题(递推分解)，再将最小问题的解返回给上一级(回归分治)。并且在运行到最小问题的时候一定要给出结束的条件，否则会无线递归，占用完内存最终导致程序崩溃。</p>
</li>
<li><p>递归与循环的区别：递归在底层实际上是对线程栈的压栈和出栈(递归是先调用的函数最后运算)，每调用一次都会压栈一次，并记录相关的局部变量信息，无限的递归耗用的是内存资源，而死循耗用的是CPU资源，死循环并不会引起程序的异常，但递归耗完内存就会引发程序的崩溃。</p>
</li>
<li><p>与循环十分类似，但是递归是通过不断打开新函数来运算的，效率上明显不如循环，实际上也是经常用循环而不是用递归。</p>
</li>
<li><p>实例：求n!阶乘</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factrial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//设立的终止条件</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n*factrial(n<span class="number">-1</span>);<span class="comment">//重复的步骤</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题分析：首先找出问题的重复步骤，此题中是n!=1<em>2</em>3<em>….n,那么可见每次n+1就是重复步骤。但是递归是由大问题向小问题分解，就变成了n!=n</em>n-1<em>n-1….</em>1(这也符合栈先进后出的特点)。终止条件显而易见，就是n==1，return 1。<br>程序分析：当n&gt;1时，程序运行到<code>return n*factrial(n-1)</code>时，会打开factrial(n-1)函数，以此类推，最后变为：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">n<span class="number">*fac</span>trial(n-1)<span class="number">*fac</span>trial(n-2)<span class="built_in">..</span><span class="built_in">..</span><span class="number">*fac</span>trial(1)</span><br></pre></td></tr></table></figure>
<p>其中<code>factrial(1) return 1</code>，那么返回上一级函数是2，在上一级就是3。</p>
</li>
</ol>
<p><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E9%80%92%E5%BD%921.jpeg" alt><br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E9%80%92%E5%BD%922.jpeg" alt></p>
<h1 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h1><ol>
<li>特性：先进后出，是一种只能对表尾进行插入和删除的运算受限线性表，将表尾称作栈顶，另一端称为栈底，插入删除元素分别叫做入栈(push)和出栈(pop)。<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/stack.png" alt></li>
<li>ElemType:是element type 的简体，代指元素类型，类似Java中的泛型，</li>
<li>与define的区别：</li>
</ol>
<ul>
<li>#define可以使用其他类型说明符对宏类型名进行拓展，但对typedef定义的类型名却不能这样<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERGE int </span></span><br><span class="line"><span class="keyword">unsigned</span> INTERGE n;<span class="comment">//真确</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INTERGE </span><br><span class="line"><span class="keyword">unsigned</span> INTERGE n;<span class="comment">//错误，typedef不能用说明符进行拓展</span></span><br></pre></td></tr></table></figure></li>
<li>顺序不同:#define 是前换后，typedef是后换前，<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI int<span class="comment">//将int用PI替代</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> PI<span class="comment">//将int重命名为PI</span></span><br></pre></td></tr></table></figure></li>
<li>连续定义多个变量时，typedef能保证定义的所有变量是同一类型，而#define不能保证<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OI int*</span></span><br><span class="line">OI p1,p2;<span class="comment">//相当于int*p1，p2，只有p1是指针，p2是int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* OI</span><br><span class="line">OI p1 ，p2；<span class="comment">//p1，p2都是指针；</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>栈的有关操作:</li>
</ol>
<ul>
<li>初始化:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackInit</span><span class="params">(Stack* s)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//为栈申请空间</span></span><br><span class="line">  s-&gt;base=(DataType*)<span class="built_in">malloc</span>(length*<span class="keyword">sizeof</span>(DataType));</span><br><span class="line">  <span class="comment">//判断是否申成功</span></span><br><span class="line">  <span class="keyword">if</span>(!s-&gt;base)&#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//初始化栈数组空间</span></span><br><span class="line">  s-&gt;top = s-&gt;base;<span class="comment">//最开始栈顶等于栈底</span></span><br><span class="line">  s-&gt;stackSize = length;<span class="comment">//Stacksize表示栈的最大长度</span></span><br><span class="line">  <span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>入栈:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPush</span> <span class="params">(Stack* s,DataType x)</span></span>&#123;</span><br><span class="line">  <span class="comment">//断言</span></span><br><span class="line">  assert(s);</span><br><span class="line">  <span class="keyword">if</span>(s-&gt;stackSize==s-&gt;top-s-&gt;base)&#123;<span class="comment">//栈的顶部减底部就是栈的长度 ,判断是否满栈 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"空间已满，追加空间"</span>);</span><br><span class="line">    s-&gt;base = (DataType*)<span class="built_in">realloc</span>(s-&gt;base,(s-&gt;stackSize+length)*<span class="keyword">sizeof</span>(DataType));</span><br><span class="line">    <span class="comment">//为栈扩容，重新分配地址,最大容量在加length</span></span><br><span class="line">    <span class="keyword">if</span>(!s-&gt;base)&#123;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    s-&gt;top = s-&gt;base+s-&gt;stackSize;<span class="comment">//将top向上移动stacksize个元素单位 </span></span><br><span class="line">    s-&gt;stackSize+=length;<span class="comment">//记录当前的栈的最大长度 </span></span><br><span class="line">  &#125; </span><br><span class="line">  *(s-&gt;top)=x;<span class="comment">//赋值 </span></span><br><span class="line">  s-&gt;top++;<span class="comment">//top移向上一个元素，为下一个赋值 </span></span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>出栈:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DataType <span class="title">StackPop</span><span class="params">(Stack* s)</span></span>&#123;</span><br><span class="line">  assert(s);</span><br><span class="line">  <span class="keyword">if</span>(StackEmpty(s))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈为空"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *--(s-&gt;top);</span><br><span class="line"><span class="comment">//优先级 '.' &gt; "--" = '*'</span></span><br><span class="line"><span class="comment">//s.top有两种可能</span></span><br><span class="line"><span class="comment">//一是指向栈顶元素的指针</span></span><br><span class="line"><span class="comment">//二是指向比栈顶元素更高一层的空元素</span></span><br><span class="line"><span class="comment">//从这里的实际情况来看，我判断是第二种情况，当s.top==0时，栈为空。</span></span><br><span class="line"><span class="comment">//--s.top是递减指针，这时s.top就指向真正的栈顶元素了</span></span><br><span class="line"><span class="comment">//*--s.top是是该元素，返回给e</span></span><br><span class="line"><span class="comment">//这样e就得到了真正的栈顶元素，同时栈内元素数目减一</span></span><br><span class="line"><span class="comment">//说白了就是e=stack.pop()操作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>查看栈的大小<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DataType <span class="title">StackSize</span><span class="params">(Stack* s)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (s-&gt;top-s-&gt;base);<span class="comment">//顶部-底部就是元素个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>查看栈顶元素<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DataType <span class="title">StackTop</span><span class="params">(Stack* s)</span></span>&#123;</span><br><span class="line">  assert(s);</span><br><span class="line">  <span class="keyword">if</span>(StackEmpty(s))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈为空"</span>);</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *(s-&gt;top<span class="number">-1</span>);<span class="comment">//s.top指向的是比栈顶更高一层的空间,因此要先-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>判空<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(Stack* s)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>==(s-&gt;top-s-&gt;base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="一些退出用法"><a href="#一些退出用法" class="headerlink" title="一些退出用法"></a>一些退出用法</h1><p>exit（0）：正常运行程序并退出程序；</p>
<p>exit（1）：非正常运行导致退出程序；</p>
<p>return（）：返回函数，若在主函数中，则会退出函数并返回一值。</p>
<p>详细说：</p>
<ol>
<li><p>return返回函数值，是关键字；  exit 是一个函数。</p>
</li>
<li><p>return是语言级别的，它表示了调用堆栈的返回；而exit是系统调用级别的，它表示了一个进程的结束。</p>
</li>
<li><p>return是函数的退出(返回)；exit是进程的退出。</p>
</li>
<li><p>return是C语言提供的，exit是操作系统提供的（或者函数库中给出的）。</p>
</li>
<li><p>return用于结束一个函数的执行，将函数的执行信息传出个其他调用函数使用；exit函数是退出应用程序，删除进程使用的内存空间，并将应用程序的一个状态返回给OS，这个状态标识了应用程序的一些运行信息，这个信息和机器和操作系统有关，一般是 0 为正常退出， 非0 为非正常退出。</p>
</li>
<li><p>非主函数中调用return和exit效果很明显，但是在main函数中调用return和exit的现象就很模糊，多数情况下现象都是一致的。</p>
</li>
</ol>
<p>exit（0）与exit（1）对你的程序来说，没有区别。对使用你的程序的人或者程序来说，区别可就大了。<br>一般来说，exit 0 可以告知你的程序的使用者：你的程序是正常结束的。如果 exit 非 0 值，那么你的程序的使用者通常会认为你的程序产生了一个错误。</p>
<p>以 shell 为例，在 shell 中调用完你的程序之后，用 echo $? 命令就可以看到你的程序的 exit 值。在 shell 脚本中，通常会根据上一个命令的 $? 值来进行一些流程控制。</p>
<h1 id="assert-断言"><a href="#assert-断言" class="headerlink" title="assert(断言)"></a>assert(断言)</h1><ol>
<li>assert是宏定义，其作用是类似if else，当条件满足时才会继续运行，否则终止程序运行，避免了if语句冗长的表达式，其结构为assert(int expression)，expression是表达式，当表达式返回值为0时结束，但是频繁调用assert会影响性能</li>
<li>可以通过在包含include的语句前插入#include NDEBUG来禁用<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="指针与int相加"><a href="#指针与int相加" class="headerlink" title="指针与int相加"></a>指针与int相加</h1><ol>
<li>指针与int n相加，则表示指针p的指向向后移动了n个p指向的元素所占有的空间值，相当于向后移了n个元素<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line">p=&amp;a;<span class="comment">//假设p值为2000，那么p+4就是2004；</span></span><br><span class="line">p=p+<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">int</span> *p1;</span><br><span class="line">p1=&amp;b;<span class="comment">//p值为2000，那么p+4就是2000+4*4=2016，因为int是4个字节</span></span><br><span class="line">p1+=<span class="number">4</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="gt-和-的区别"><a href="#gt-和-的区别" class="headerlink" title="-&gt;和.的区别"></a>-&gt;和.的区别</h1><p>.的左边是一个表达式结果为结构体的表达式，而-&gt;的左边是指向结构体的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> date;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> *<span class="title">length</span>;</span></span><br><span class="line">&#125;Tree,*PTree;</span><br><span class="line"></span><br><span class="line">Tree.date=a;<span class="comment">//Tree为结构体，用.</span></span><br><span class="line">PTree-&gt;date=b;<span class="comment">//PTree为指针，用-&gt;</span></span><br></pre></td></tr></table></figure>


<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><ol>
<li>二叉树的遍历有三种，分别是先序遍历(DLR)，中序遍历(LDR)，后序遍历(LRD)<br>其中D是根节点，L和R分别是左子树和右子树，最常见的遍历方法有两种，分别是递归法和非递归法</li>
<li></li>
</ol>
<ul>
<li>先序递归法：递归法很容易理解，单相对来说数据大时会因为递归层数太大，调用的栈多，造成运算时间过长，占用内存过多。就相当于套娃，进入支树后，知数本身作为根节点，支树的支树作为子树<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Tree e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(t)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,e-&gt;data);<span class="comment">//先输出e节点的值</span></span><br><span class="line">    PreOrder(e-&gt;Lchild);<span class="comment">//进入左子树，一直遍历至左子树为NULL；</span></span><br><span class="line">    PreOrder(e-&gt;Rchild);<span class="comment">//进入右子树，一直遍历至左子树为NULL；</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>先序非递归法：其实本质上与递归差不多，因为二叉树的遍历必然要用到栈，只不过由系统调用改为手动调用<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder1</span><span class="params">(Tree e)</span></span>&#123;</span><br><span class="line">     Tree p = t;</span><br><span class="line">     Sqstack s;</span><br><span class="line">     InitStack(&amp;s);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>(p||!StackEmpty(s))&#123;</span><br><span class="line">      <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,p-&gt;data);</span><br><span class="line">        push(&amp;s,p);</span><br><span class="line">        p = p-&gt;Lchild;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        Pop(&amp;s,p);</span><br><span class="line">        p = p-&gt;Rchild;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>中序非递归遍历:与先序遍历不同，因为要先输出左子树，所以要先入栈根节点，进入左子树<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder1</span><span class="params">(Tree t)</span></span>&#123;<span class="comment">//非递归中序遍历</span></span><br><span class="line">    Tree p = t;</span><br><span class="line">    Sqstack s;</span><br><span class="line">    InitStack(s); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( p || !StackEmpty(s) )&#123;</span><br><span class="line">    <span class="keyword">if</span> ( p )&#123;</span><br><span class="line">        Push(s,p);<span class="comment">//先压栈，进入左子树 </span></span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pop(s,p);<span class="comment">//返回上一级 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>后序遍历：后序遍历的非递归算法是最复杂的，关键就是只有当左右子树都输出完成后才能输出节点，标识isOut为1时打印，isOut初始值为0，这主要是为了处理非叶子节点。由后序遍历的原理决定，左右子树都被打印该节点才能打印，所以该节点肯定会被访问2次，第一次的时候不要打印，第二次打印完右子树的时候打印。叶子节点打印完后将isOut置为1。<br>isOut处理具体如下：<br>所有节点入栈的时候初始化为0；<br>叶子节点打印输出后将isOut置为1；<br>非叶子节点分两种情况。<br>   如果存在左子树，则输出左子树后将isOut置为1，此时指针已获得其右子树节点；<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (p-&gt;lchild) &amp;&amp; (p-&gt;lchild-&gt;isOut == <span class="number">1</span>) )&#123;<span class="comment">//如果存在左子树,并且左子树已经遍历完，则说明该节点已经入栈，不用再次Push,直接走向右子树       </span></span><br><span class="line">       p-&gt;isOut = <span class="number">1</span>;</span><br><span class="line">       p = p-&gt;rchild;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
   如果不存在左子树，则将isOut置为1，此时指针已获得其右子树节点；    <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!StackEmpty(s))</span><br><span class="line">  &#123;</span><br><span class="line">        GetTop(s,p);</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;lchild == <span class="literal">NULL</span> )</span><br><span class="line">        p-&gt;isOut = <span class="number">1</span>; <span class="comment">//右子树已输出，将父节点isOut置1</span></span><br><span class="line">   &#125;；</span><br><span class="line">     ```                                      </span><br><span class="line">遇到isOut=<span class="number">1</span>的时候，说明左右子树都已输出，所以该节点也出栈打印出来。</span><br><span class="line">```c</span><br><span class="line"><span class="keyword">void</span> PostOrder1(Tree t)&#123;<span class="comment">//非递归后序遍历</span></span><br><span class="line">    t-&gt;isOut = <span class="number">0</span>;<span class="comment">//初始化 </span></span><br><span class="line">    Tree p = t;</span><br><span class="line">    Sqstack s;</span><br><span class="line">    InitStack(s); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> ( p || !StackEmpty(s) )&#123;</span><br><span class="line">    <span class="keyword">if</span> ( p )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;isOut )&#123;<span class="comment">//左右子树都已输出，则该节点也输出，这是叶子节点 </span></span><br><span class="line">             Pop(s,p);<span class="comment">//出栈，p变为上一级节点 </span></span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);<span class="comment">//输出节点 </span></span><br><span class="line">        <span class="keyword">if</span> (!StackEmpty(s))<span class="comment">//如果栈不为空，获得栈顶元素，这里是输出完非叶子节点后，进入上一级进行LRD输出 </span></span><br><span class="line">                   GetTop(s,p); <span class="comment">//得到弹出节点元素的父节点</span></span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               p = <span class="literal">NULL</span>;<span class="comment">//若栈为空，则p为空 </span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>&#123;<span class="comment">//若左右子树未完全输出 （非叶子节点）   </span></span><br><span class="line">            <span class="keyword">if</span> ( (p-&gt;lchild) &amp;&amp; (p-&gt;lchild-&gt;isOut == <span class="number">1</span>) )&#123;</span><br><span class="line">      <span class="comment">//如果存在左子树,并且左子树已经遍历完，那么就将isout设为1，因为此时p已经指向右子树，接下来会进入右子树进行输出，</span></span><br><span class="line">      <span class="comment">//说明该节点已经入栈（因为左子树已经遍历完了），不用再次Push,直接走向右子树       </span></span><br><span class="line">               p-&gt;isOut = <span class="number">1</span>;</span><br><span class="line">               p = p-&gt;rchild;</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//这是存在左子树但为遍历完成的非叶子节点的情况 </span></span><br><span class="line">             Push(s,p);<span class="comment">//先入栈，进入左子树输出 </span></span><br><span class="line">             p = p-&gt;lchild;</span><br><span class="line">             &#125;    </span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//这是不存在左子树的情况 </span></span><br><span class="line">         <span class="keyword">if</span> (!StackEmpty(s))<span class="comment">//若栈不为空，获取栈顶元素 </span></span><br><span class="line">            GetTop(s,p); </span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">            p = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;rchild )&#123;<span class="comment">//若右子树存在，则一直向下遍历，直至NULL </span></span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>&#123;<span class="comment">//当不存在右子树时，返回上一级输出 </span></span><br><span class="line">            Pop(s,p);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);</span><br><span class="line">            p-&gt;isOut = <span class="number">1</span>;<span class="comment">//此时右子树 </span></span><br><span class="line">            <span class="keyword">if</span> (!StackEmpty(s))</span><br><span class="line">            &#123;</span><br><span class="line">             GetTop(s,p);</span><br><span class="line">                <span class="keyword">if</span> ( p-&gt;lchild == <span class="literal">NULL</span> )</span><br><span class="line">               p-&gt;isOut = <span class="number">1</span>; <span class="comment">//右子树已全部输出，将父节点isOut置1</span></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            p = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E5%85%88%E5%BA%8F%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.jpg" alt></li>
</ul>
<ol start="3">
<li>函数传递参数中带&amp;与不带&amp;号区别<br>首先引用只有c++能使用，c不能使用引用</li>
</ol>
<ul>
<li>C++ 引用<br>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</li>
<li>C++ 引用 vs 指针<br>引用很容易与指针混淆，它们之间有三个主要的不同：</li>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
<li>C++ 中创建引用<br>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，可以通过原始变量名称或引用来访问变量的内容</li>
</ul>
<h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><p>二叉树的算法都包括递归与非递归，递归易于理解，非递归利于效率，现在出学，只要求了解递归算法</p>
<ol>
<li>递归算法：左子树和右子树的最大值+1(+1是根节点)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(Tree t)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!t)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> depth(t-&gt;lchild)&gt;depth(t-&gt;rchild)?depth(t-&gt;lchild)+<span class="number">1</span>:depth(t-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="主函数的参数"><a href="#主函数的参数" class="headerlink" title="主函数的参数"></a>主函数的参数</h1><ol>
<li>主函数的参数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[]</span><br></pre></td></tr></table></figure>
argc是控制台传入主函数的字符串个数，而argv是指针数组，本质是二级指针</li>
<li>过程<br>首先切换到可执行程序所在目录(第一个字符),接着输入要传入主函数的参数<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/main.png" alt></li>
</ol>
<h1 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h1><ol>
<li>定义：类型名 (*变量名）（参数表列）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></li>
<li>通过指针变量来访问函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">p=<span class="built_in">max</span>;<span class="comment">//不能再其后加上参数列表，ex：p=max(*P)(a,b);</span></span><br><span class="line">c=(*P)(a,b);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> z,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"> <span class="comment">//交换两数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>函数指针进行自加和+n都是无意义的</li>
<li>函数指针可以作为参数传入函数，这样在函数中就可以调用实参函数</li>
</ol>
<p>#各种指针的区分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;<span class="comment">//整数</span></span><br><span class="line"><span class="keyword">int</span> *P;<span class="comment">//指针指向整型</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];<span class="comment">//数组</span></span><br><span class="line"><span class="keyword">int</span> *p[<span class="number">4</span>];<span class="comment">//行指针，每行4个元素</span></span><br><span class="line"><span class="keyword">int</span> (*P)[<span class="number">4</span>];<span class="comment">//指针数组，元素类型为指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;<span class="comment">//函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">P</span><span class="params">()</span></span>;<span class="comment">//返回值是整型指针的函数</span></span><br><span class="line"><span class="keyword">int</span> (*P)();<span class="comment">//指向函数的指针</span></span><br><span class="line"><span class="keyword">int</span> **P;<span class="comment">//二级指针，存放的是指针的地址</span></span><br><span class="line"><span class="keyword">void</span> *P;<span class="comment">//只返回地址不返回数据类型的指针</span></span><br></pre></td></tr></table></figure>

<h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><ol>
<li>四种函数，malloc,calloc,realloc,free</li>
<li>malloc函数(动态内存分配，链表创建的基础)：其函数原型为void <em>malloc(unsigned int size)，size是输入数据的长度，返回类型是void</em>类型，需要指定类型。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Head = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));<span class="comment">//定义头节点</span></span><br><span class="line"><span class="comment">//node是重命名后的结构体变量名(即相当与指定int*类型指针一样，sizeof()*n用来计算n个结构体的长度。</span></span><br></pre></td></tr></table></figure></li>
<li>realloc(再分配函数)<br>用来冲新分配内存，原型是：(void<em>)realloc(void</em> ptr,size_t size);<br>ptr是需要重新分配内存的指针所指向的空间，size是新的内存空间大小。</li>
</ol>
<ul>
<li>size可以比原来大或者小，当内存不够用时，就可以调用realloc来重新分配内存</li>
<li>如果ptr指向NULL，那么作用和malloc是一样的，而size值为0时，ptr指向的空间就会被释放，类似free()。</li>
<li>注意点：</li>
<li>ptr必须是在动态内存分配成功的指针，像int *i，int a[2]这样的指针时不行的，即只有通过malloc，calloc，realloc分配成功的指针才能被再次分配内存</li>
<li>再分配成功后，原来ptr指针就会被系统回收，一定不能对ptr指针做任何操作，包扩free，但是可以对realloc的返回值进行正常操作</li>
<li>如果扩大内存，就会把数据复制到新地址（新地址可能与原地址相同也可能不同，单依旧不能对原地址进行任何操作），如果是缩小内存，原数据会被复制并截取新长度</li>
<li>如果分配失败，ptr指向的内存不会被释放，内容也不会被改变，依然可以正常使用<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> input,n;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* numbers = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span>* more_numbers = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"Enter an integer value (0 to end): "</span>);<span class="comment">//输入0表示结束</span></span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;input);</span><br><span class="line">        count++;<span class="comment">//每次递增，表示内存分配的空间，因为realloc是复制再重新分配，而不是在原地址直接增加内存，因此要递增</span></span><br><span class="line">        more_numbers = (<span class="keyword">int</span>*) <span class="built_in">realloc</span> (numbers, count * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//分配count个空间</span></span><br><span class="line">        <span class="keyword">if</span> (more_numbers!=<span class="literal">NULL</span>) &#123;<span class="comment">//如果分配内存成功，那么more_numbers就非空</span></span><br><span class="line">            numbers=more_numbers;<span class="comment">//将numbers指向more_numbers</span></span><br><span class="line">            numbers[count<span class="number">-1</span>]=input;<span class="comment">//调用内存分配的函数都是连续空间，因此类似数组，可以用下标来访问。只不过内存大小shi可以改变的，即动态数组</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">free</span> (numbers);<span class="comment">//失败就释放指针</span></span><br><span class="line">            <span class="built_in">puts</span> (<span class="string">"Error (re)allocating memory"</span>);</span><br><span class="line">            <span class="built_in">exit</span> (<span class="number">1</span>);<span class="comment">//非正常运行导致程序退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(input!=<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"Numbers entered: "</span>);</span><br><span class="line">    <span class="keyword">for</span> (n=<span class="number">0</span>;n&lt;count;n++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,numbers[n]);</span><br><span class="line">    <span class="built_in">free</span> (numbers);</span><br><span class="line">    system(<span class="string">"pause"</span>);<span class="comment">//暂停</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>calloc</li>
</ol>
<ul>
<li>原型：void* calloc(unsigned n,unsignedsize);n是要开辟的元素个数，size是字节大小</li>
<li>与malloc的区别：calloc一般是用来给数组扩大空间的，并且会对分配的内存全部初始化为0，会降低程序的运行效率<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//calloc相当于</span></span><br><span class="line">p=<span class="built_in">malloc</span>();</span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="built_in">size</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="5">
<li>free函数</li>
</ol>
<ul>
<li>原型：void free(void *p);</li>
<li>作用是释放p所指向的内存空间，p应为最近一次调用内存分配的函数，无返回值</li>
</ul>
<h1 id="链表-哈希表的基础"><a href="#链表-哈希表的基础" class="headerlink" title="链表(哈希表的基础)"></a>链表(哈希表的基础)</h1><ol>
<li><p>链表的实质就是由结构体转变而来，不过多了一个指针域。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; node ;<span class="comment">//重命名结构体变量，方便下一步</span></span><br></pre></td></tr></table></figure>
<p>重命名typedef可以避免字母打错等错误。</p>
</li>
<li><p>头节点：是链表的第一个节点，一般不存放数据(用来指向整个链表)。</p>
</li>
<li><p>malloc函数(动态内存分配，链表创建的基础)：其函数原型为void <em>malloc(unsigned int size)，size是输入数据的长度，返回类型是void</em>类型，需要指定类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Head = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));<span class="comment">//定义头节点</span></span><br><span class="line"><span class="comment">//node是重命名后的结构体变量名(即相当与指定int*类型指针一样，sizeof()*n用来计算n个结构体的长度。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>！！！链表建立时都是建的结构体指针，而不是结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node *Head;</span><br><span class="line">node *pend;</span><br><span class="line">node *pnew;</span><br></pre></td></tr></table></figure></li>
<li><p>建立流程：</p>
<ul>
<li>定义头节点(Head)，尾节点(pend)，新节点(pnew)<br>由于要用头节点来指向整个链表，数据域不赋值，因此需要一个节点来代替头节点进行节点的更替。</li>
<li>确定输入多少个值(由具体情况而定)，每次输入都要为pnew动态分配内存，输入值赋给新节点的数据域，旧节点的指针域指向新节点，新节点变为旧节点。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node *Head;<span class="comment">//创建头节点</span></span><br><span class="line">     Head = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">   Head-&gt;next = <span class="literal">NULL</span>;<span class="comment">// 头节点后面没有新节点，所以是NULL</span></span><br><span class="line">   node *pnew,*pend;</span><br><span class="line">   pend = Head;<span class="comment">// 当输入数据为0个时，尾节点就等于头节点，用尾节点代替头节点进行连接操作</span></span><br><span class="line">   <span class="keyword">int</span> n;</span><br><span class="line">   <span class="keyword">for</span>(;n!=<span class="number">-1</span>;)&#123;</span><br><span class="line">     pnew = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));<span class="comment">//为新节点分配内存</span></span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">     pnew-&gt;data = n;<span class="comment">// 新节点的数据域赋值为n</span></span><br><span class="line">     pend-&gt;next = pnew; <span class="comment">//旧节点的指针域指向新节点，不然下一步无法完成，因为旧节点没有新节点的地址，没有办法找到新节点</span></span><br><span class="line">     pend = pnew; <span class="comment">//新节点变为旧节点</span></span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> pend-&gt;next = <span class="literal">NULL</span>;<span class="comment">// 尾节点的指针域赋为NULL，表示后面没有新元素</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h1 id="结构体和链表中的问题"><a href="#结构体和链表中的问题" class="headerlink" title="结构体和链表中的问题"></a>结构体和链表中的问题</h1><ol>
<li>头节点，首元节点， 头指针的区别：链表分为带头节点和不带头节点两种，带头结点的链表的头指针指向的第一个节点的数据域是空的(有时用来存放链表的长度)，头节点的指针域指向首元节点，不带头节点的链表的头指针指向首元节点，首元节点是存储数据的第一个节点。头节点存在的作用是为了使操作统一化，不用考虑对首元节点操作的特殊情况</li>
<li>不带头节点是，如果对首元节点进行增删的操作的话，会改变头指针的值，解决办法有两种，一种是用二级指针指向头指针，这样就是二级指针的值在变化，另一种是返回新的头指针</li>
<li>删除首元节点：直接将头节点指向头节点之后的节点就可以</li>
<li>链表的增删查改都是通过指针移动到目标节点，在为pre和p赋值，而不是直接用p和pre向后走，这样经常容易出错</li>
<li>永远不对头指针直接进行操作，一旦头指针改变，就找不会完整的链表，用工作指针来进行操作</li>
<li>单链表的逆序是不能向数组那样简单的头尾颠倒，因为单链表的指向是单向的，只能指向后一个节点，用双链表就可以直接换，单链表用头插法重新建立链表输出</li>
<li>如果想建立不带头节点的单链表的话，while中的if(head==NULL)中才能为head分配空间，因为一旦分配空间后head的值就会改变，不再是NULL，也就无法进入if语句</li>
<li>两个有序链表的合并</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>c语言，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title>java复习</title>
    <url>/2019/12/19/java/</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ol>
<li>局部变量(local variable):方法或语句块内的变量，其生命周期是从声明位置开始到方法或语句块结束为止。(和c的函数局部变量一样)。<a id="more"></a></li>
<li>成员变量(member variable)：也叫实例变量，方法外，类的内部的变量，其生命周期伴随对象始终。并且成员变量在定义时如果没有手动赋值，会默认赋初始值，数字是0，字符是null，布尔是false。</li>
<li>静态变量(类变量 static variable):用static关键字表示，从属于类，生命周期从类加载到卸载，伴随类的始终。</li>
<li>周期比较(小到大)：局部变量(从属于方法)&lt;成员变量(从属于对象)&lt;静态变量(从属于类)。而c中类似的只有局部变量和静态变量的概念。(c是面向过程编程，不同于面向对象，没有对象的概念)。</li>
</ol>
<hr>
<h1 id="变量和常量的命名规范"><a href="#变量和常量的命名规范" class="headerlink" title="变量和常量的命名规范"></a>变量和常量的命名规范</h1><ol>
<li>所有变量和方法名都是首字母小写和驼峰原则。</li>
<li>常量是大写字母和下划线。</li>
<li>类名大写字母和驼峰原则。</li>
</ol>
<hr>
<h1 id="自动转化"><a href="#自动转化" class="headerlink" title="自动转化"></a>自动转化</h1><ol>
<li>指容量小的数据类型自动转为容量大的数据类型，容量指的是表示范围，例如short a = 12 合法，但short a = 1234567不合法，超出了short的表示范围。<br>其中实线表示可以不损失精度直接转换，虚线是可能会有精度损失。<br><img src="/2019/12/19/java/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt></li>
</ol>
<h1 id="Scanner获取键盘输入"><a href="#Scanner获取键盘输入" class="headerlink" title="Scanner获取键盘输入"></a>Scanner获取键盘输入</h1><ol>
<li>首先要导入Scanner所在包</li>
<li>新建Scanner对象</li>
<li>建立变量存储键盘输入的值<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner<span class="comment">//引进包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">               Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//in是io流</span></span><br><span class="line">               System.out.println(<span class="string">"请输入名字"</span>);</span><br><span class="line">               String name = Scanner.nextline();<span class="comment">//字符串是nextline</span></span><br><span class="line">               System.out.println(<span class="string">"请输入爱好"</span>);</span><br><span class="line">               String favor = Scanner.nextline();</span><br><span class="line">               System.out.println(<span class="string">"请输入年龄"</span>);</span><br><span class="line">               <span class="keyword">int</span> age = Scanner.nextInt();<span class="comment">//数字是nextInt</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ol>
<li>主类中方法前加static，表名该方法是类的共享成员，可以被该类所有的实例化对象访问，当类加载时，static方法就被加载，其声明周期从属于类。若是不定义static，也可以通过对象调用普通方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testmethod</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">	<span class="keyword">int</span> m = scanner.nextInt();</span><br><span class="line">	<span class="keyword">int</span> x = sum(n,m);</span><br><span class="line">	System.out.println(<span class="string">"n+m="</span>+x);<span class="comment">//直接调用</span></span><br><span class="line">	</span><br><span class="line">	Testmethod th = <span class="keyword">new</span> Testmethod();</span><br><span class="line">	<span class="keyword">int</span> a = th.sum(<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">	System.out.println(a);<span class="comment">//对象调用</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">int</span> m)</span> </span>&#123; 	<span class="comment">//static 修饰的函数可以在主类中直接调用</span></span><br><span class="line">	<span class="keyword">return</span> m+n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//没有static要先创建对象，在通过对象调用方法</span></span><br><span class="line">	<span class="keyword">return</span> n+m+x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法的重载(overload)：函数名相同但参数列表不同(参数个数，顺序，类型)，只有返回值和形参名称不构成重载。</li>
</ol>
<h1 id="对象-object-instance"><a href="#对象-object-instance" class="headerlink" title="对象(object,instance)"></a>对象(object,instance)</h1><ol>
<li>对象是具体的事物;类是对对象的抽象;</li>
<li>类可以看成一类对象的模板，对象可以看成该类的一个具体实例。</li>
<li>类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性</li>
</ol>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ol>
<li>每个文件都只能由一个public class，且类名必须与文件名一致。可以定义多个普通类</li>
<li>类里由三个成员，属性(field),方法(method),构造方法(constructor)</li>
<li>类可以相互引用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testclass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line">	 grade ge;<span class="comment">//类名+属性名</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	grade g1 = <span class="keyword">new</span> grade();</span><br><span class="line">	Testclass stu1 = <span class="keyword">new</span> Testclass();</span><br><span class="line">	g1.grade = <span class="number">2</span>;</span><br><span class="line">	stu1.ge = g1;</span><br><span class="line">	System.out.printf(<span class="string">"年级"</span>+stu1.ge);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grade</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> grade;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>主类名唯一，其他类不能与主类重名，否则会报错找不到主类</li>
<li>传入一个类类型，在方法内进行改动，会对方法外的参数造成影响。<br>24行的引用 teemo与 第17行的引用hero，是不同的引用<br>通过调用garen.attack(teemo, 100); 使得这两个引用都指向了同一个对象<br>所以在第18行hero.hp = hero.hp - damage; 就使得该对象的hp值，发生了变化<br>因此第25行，打印该对象的Hp值就是变化后的值<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    String name; <span class="comment">// 姓名</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">float</span> hp; <span class="comment">// 血量</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">float</span> armor; <span class="comment">// 护甲</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> moveSpeed; <span class="comment">// 移动速度</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String name, <span class="keyword">float</span> hp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.hp = hp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 攻击一个英雄，并让他掉damage点血</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero hero, <span class="keyword">int</span> damage)</span> </span>&#123;</span><br><span class="line">        hero.hp = hero.hp - damage;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">"提莫"</span>, <span class="number">383</span>);</span><br><span class="line">        Hero garen = <span class="keyword">new</span> Hero(<span class="string">"盖伦"</span>, <span class="number">616</span>);</span><br><span class="line">        garen.attack(teemo, <span class="number">100</span>);</span><br><span class="line">        System.out.println(teemo.hp);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>类方法： 又叫做静态方法(加载类时和类一起加载)</li>
</ol>
<p>对象方法： 又叫实例方法，非静态方法(只有当对象调用是才会用)</p>
<p>访问一个对象方法，必须建立在有一个对象的前提的基础上<br>访问类方法，不需要对象的存在，直接就访问</p>
<h1 id="构造方法-constructor"><a href="#构造方法-constructor" class="headerlink" title="构造方法(constructor)"></a>构造方法(constructor)</h1><ol>
<li><p>用于对象的初始化，在对象创建时被调用，构造器的名称应该与类的名称一致，    虽然有返回值，但不能加return(返回值必然时本类)，即public+类名(不用加返回值类型名)</p>
</li>
<li><p>构造方法同样可以重载，但是当形参和实参重复时，就要用this关键字，this指代正在创建的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hero</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> hp ;</span><br><span class="line">   <span class="keyword">int</span> speed;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">hero</span> <span class="params">(<span class="keyword">int</span> hp,<span class="keyword">int</span> speed)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.hp = hp;  <span class="comment">//this.hp 指代创建对象的hp，等号后面的hp是形参hp</span></span><br><span class="line">		<span class="keyword">this</span>.speed = speed;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><ol>
<li>类和类之间的关系有5种，分别是：</li>
</ol>
<p><img src="/2019/12/19/java/%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt></p>
<ul>
<li>自身：hero类</li>
<li>同包子类：charactor包里继承了hero包的类(ADhero)</li>
<li>不同包子类：charactor1和property包里的继承了hero的类(support)</li>
<li>同包类：charactor包里除了hero的所有类</li>
<li>其他类：除上述类外的所有类</li>
</ul>
<ol start="2">
<li>修饰符类型：</li>
</ol>
<ul>
<li>private只能自己访问，其余任何类都不能访问或继承<br><img src="/2019/12/19/java/private.png" alt></li>
<li>package/friendly/default,没有修饰符是的默认修饰符，同包的子类和其他类可以继承和访问，但其他类的子类和类就不能访问和继承。<br><img src="/2019/12/19/java/default.png" alt></li>
<li>protected，除其他类不能访问外，同包和不同包都可以继承。<br><img src="/2019/12/19/java/protected.png" alt></li>
<li>public，任何地方，都可以访问<br><img src="/2019/12/19/java/public.png" alt></li>
</ul>
<ol start="3">
<li>适用范围：</li>
</ol>
<ul>
<li>属性通常使用private封装起来</li>
<li>方法一般使用public用于被调用</li>
<li>会被子类继承的方法，通常使用protected</li>
<li>package用的不多，一般新手会用package,因为还不知道有修饰符这个东西</li>
</ul>
<p>-再就是作用范围最小原则<br>  简单说，能用private就用private，不行就放大一级，用package,再不行就用protected，最后用public。这样就能把数据尽量的封装起来，没有必要露出来的，就不用露出来了</p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ol>
<li>又叫singleton，一个类在一个JVM里只有一个实例村在。有两种办法，两种办法的步骤都是</li>
</ol>
<ul>
<li>将构造方法私有化，使其不能被外部方法更改</li>
<li>将类属性实例化(二者主要区别就在这里)</li>
<li>写public static(类方法)，返回instance(实例)</li>
</ul>
<p>懒汉式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	giantDragon g1 = giantDragon.getInstance();</span><br><span class="line">	giantDragon g2 = giantDragon.getInstance();</span><br><span class="line">	System.out.println(g1==g2);<span class="comment">//返回true，两者是同一对象</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">giantDragon</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">giantDragon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;<span class="comment">//构造器私有化</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> giantDragon instance;<span class="comment">//定义一个类属性，</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> giantDragon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;<span class="comment">//调用getIstance函数，如果没有实例，就新建一个</span></span><br><span class="line">			instance = <span class="keyword">new</span> giantDragon();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;<span class="comment">//如果已经有的话就返回实例</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	giantDragon g1 = giantDragon.getInstance();</span><br><span class="line">	giantDragon g2 = giantDragon.getInstance();</span><br><span class="line">	System.out.println(g1==g2);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">giantDragon</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">giantDragon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> giantDragon instance = <span class="keyword">new</span> giantDragon();<span class="comment">//二者差别就在于此，饿汉式是加载类的时侯就加载完成的，即不管是否调用getInstance，类属性都被被实例化，而懒汉式只有当调用时才会实例化</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> giantDragon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>饿汉式是立即加载的方式，无论是否会用到这个对象，都会加载。<br>如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。</li>
</ol>
<p>懒汉式，是延迟加载的方式，只有使用的时候才会加载。 并且有线程安全的考量。<br>使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。</p>
<p>看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式</p>
<h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><ol>
<li>使用枚举类型时，要另外定义一个新的public类，因为一个Java文件只能有一个public类，常用于switch结构里(用来定义常量)，可以防止case越界引起程序的混乱。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hhh</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Season s: Season.Values())&#123;</span><br><span class="line">			System.out.println(s);<span class="comment">//增强型循环，变量类型+中间变量+要输出的内容</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在另外一个文件里定义枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season&#123;</span><br><span class="line">	SPRING,SUMMER,AUTUMN,WINTER<span class="comment">//没有分号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>MySQL数据库</p>
<ol>
<li>驱动程序包名：mysql-connector-Java-3.1.11-bin.jar</li>
</ol>
<ul>
<li>驱动类的名字：com.mysql.jdbc.Driver</li>
<li>JDBC URL：jdbc:mysql://dbip:port/databasename</li>
<li>说明：驱动程序包名有可能会变</li>
<li>JDBC URL其中各个部分含义如下：</li>
<li>dbip –为数据库服务器的IP地址，如果是本地可写：localhost或127.0.0.1。</li>
<li>port –为数据库的监听端口，需要看安装时的配置，缺省为3306。</li>
<li>databasename –数据库的名字。</li>
</ul>
<p>例如我的数据库就是jdbc:mysql://127.0.0.1:3306/how2java</p>
<ol start="2">
<li>数据库的增删改：</li>
</ol>
<ul>
<li>增加：insert into table_name (指定的列) values (值)<br>数据库不区分大小写，<br>ex：``` insert into hero values (null,”+”‘提莫’”+”，”+312+”,”+50+”)<br>insert into hero (hp) values (320)<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 删除：<span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> ...(<span class="keyword">where</span> 是用来定位用的)</span><br><span class="line">删除表内全部内容：<span class="keyword">delete</span> *<span class="keyword">from</span> table_name</span><br><span class="line">-改 ：<span class="keyword">UPDATE</span> 表名称 <span class="keyword">SET</span> 列名称 = 新值 <span class="keyword">WHERE</span> 列名称 = 某值</span><br><span class="line"><span class="symbol">``</span><span class="symbol">` update hero set id = 2 where hp = 59</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h1><ol>
<li>操作数据库的步骤：</li>
</ol>
<ul>
<li>根据how2j的教程将sql的jar包下好并导入</li>
<li>导入sql操作必要的包<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;<span class="comment">//创建数据库与Java的连接对象</span></span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;<span class="comment">//驱动管理类，用来获取数据库的连接</span></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;<span class="comment">//用于报告与数据库相关的错误信息</span></span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;<span class="comment">//建立statement才能对数据库进行操作，statement对象：用来进行一些简单的无参查询sql语句</span></span><br></pre></td></tr></table></figure></li>
<li>建立Connection和Statement对象，并赋空值<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection c=<span class="keyword">null</span>;</span><br><span class="line">Statement s = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li>
<li>try-catch语句，首先加载驱动类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(com.mysql.jdbc.Driver);</span><br></pre></td></tr></table></figure>
Class.forName(className)可以简单的理解为：获得字符串参数中指定的类，并初始化该类。返回与给定的字符串名称相关联类或接口的Class对象。</li>
</ul>
<p>Class.forName是一个静态方法，同样可以用来加载类。<br>该方法有两种形式：Class.forName(String name, boolean initialize,ClassLoader loader)和 Class.forName(String className)</p>
<p>第一种形式的参数 name表示的是类的全名；<br>initialize表示是否初始化类；loader表示加载时使用的类加载器。<br>第二种形式则相当于设置了参数 initialize的值为 true，loader的值为当前类的类加载器。</p>
<ul>
<li>用DriverManager.getConnection(…..)连接数据库，并赋给可操作对象S<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">		Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		 c = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8"</span>,</span><br><span class="line">				<span class="string">"root"</span>,<span class="string">"admin"</span>);</span><br><span class="line">	    	</span><br><span class="line">		  s = c.createStatement();</span><br></pre></td></tr></table></figure></li>
<li>写sql语句，并用execute函数执行sql语句<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">"delete from hero where id = 8"</span>;</span><br><span class="line">		execute(sql);</span><br></pre></td></tr></table></figure></li>
<li>由于数据库资源有限，需要结束时关闭数据库<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(s!=<span class="keyword">null</span>) </span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				s.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">try</span> &#123;</span><br><span class="line">        	    c.close();	</span><br><span class="line">        	&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">        		e.printStackTrace();</span><br><span class="line">        	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>或者用try流自动关闭，将操作写在try后的()内，这样在结束后会自动关闭括号内的操作。</p>
<ul>
<li>printStackTrace()和普通print(e)的区别在于普通报错只会提醒错了，而printStackTrace会指出错误行和错误信息。</li>
</ul>
<p>完整版</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testjdbc</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">"delete from hero where id = 8"</span>;</span><br><span class="line">		execute(sql);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="comment">//*************************************************</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">	Connection c=<span class="keyword">null</span>;</span><br><span class="line">	Statement s = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		 c = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8"</span>,</span><br><span class="line">				<span class="string">"root"</span>,<span class="string">"admin"</span>);</span><br><span class="line">	    	</span><br><span class="line">		  s = c.createStatement();</span><br><span class="line">		 </span><br><span class="line">			</span><br><span class="line">			 s.execute(sql);</span><br><span class="line">		 </span><br><span class="line">	&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(s!=<span class="keyword">null</span>) </span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				s.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">try</span> &#123;</span><br><span class="line">        	    c.close();	</span><br><span class="line">        	&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">        		e.printStackTrace();</span><br><span class="line">        	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**********************************************</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数据库的增删改：只要将sql语句改写即可，详见上一篇数据库的操作。</li>
<li>sql的查询：用ResultSet 结果集来收集来自数据库的信息，这样可以通过对结果集的操作来查询数据，方便操作。</li>
</ol>
<ul>
<li>首先导入结果集包：<code>import java.sql.ResultSet</code></li>
<li>写sql语句，即将表中所有数据都收集到结果集中</li>
<li>创建结果集对象，并用get函数得到所需信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">"select *form hero "</span>;</span><br><span class="line">ResultSet rs = s.executeQuery(sql);</span><br><span class="line"><span class="keyword">while</span> (rs.next())&#123;<span class="comment">//rs.next()是判断数据库内是否还有数据，有就执行，无就退出</span></span><br><span class="line">	<span class="keyword">int</span> hp = rs.getInt(<span class="number">4</span>);</span><br><span class="line">	String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用查询语句来验证账号密码是否正确：</li>
</ul>
<ol>
<li>将数据表中数据全部加载到结果集中，在查找，但是数据一旦大了之后，内存都放不下，不推荐这种放法</li>
<li>将账号密码写入sql语句中，在数据库中查找含有关键字的数据。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = <span class="string">"haha"</span>;</span><br><span class="line">String password = <span class="string">"thisispassword"</span>;</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">"select *from hero where name = '"</span>+name+<span class="string">"' and password = '"</span>+password+<span class="string">"';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ResultSet rs = s.executeQuery(sql);</span></span><br><span class="line"><span class="string">if(rs.next())&#123;</span></span><br><span class="line"><span class="string">	System.out.println("</span>账号密码正确<span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">else&#123;</span></span><br><span class="line"><span class="string">	System.out.println("</span>账号密码错误<span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>统计表中有多少条数据<code>select count(*)from hero</code></li>
<li>分页查询：<code>select form hero limit 0,5</code>每5个数据为一页查询。</li>
</ol>
<h1 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h1><ol>
<li>array.sort:</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode周赛题目</title>
    <url>/2019/12/02/leetcode/</url>
    <content><![CDATA[<h1 id="164周赛第1题"><a href="#164周赛第1题" class="headerlink" title="164周赛第1题"></a>164周赛第1题</h1><p> 访问所有点的最小时间（切比雪夫距离）</p>
<p>平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。请你计算访问所有这些点需要的最小时间（以秒为单位）。</p>
<p>你可以按照下面的规则在平面上移动：</p>
<p>每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。<br>必须按照数组中出现的顺序来访问这些点。</p>
<p>在二维坐标中，二个点之间的距离定义为其各座标数值差绝对值的最大值。以(x1,y1)和(x2,y2)二点为例，其切比雪夫距离为max(|x2-x1|,|y2-y1|)。</p>
<a id="more"></a>

<p><img src="/2019/12/02/leetcode/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB.png" alt><br><img src="/2019/12/02/leetcode/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB1.png" alt><br>points.length是点的个数，范围是[1,100]，points[i].length是坐标长度，为2（x，y）。x，y距离都是-1000，1000</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(<span class="keyword">int</span>** points, <span class="keyword">int</span> pointsSize, <span class="keyword">int</span>* pointsColSize)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!points)   <span class="comment">//是points（点个数）为0的特殊情况</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i;i&lt;pointsSize<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">a=<span class="built_in">abs</span>(points[i][<span class="number">0</span>]-points[i+<span class="number">1</span>][<span class="number">0</span>]);<span class="comment">//x的最大值，i表示第几个点，0是每个元素的第一个值，即横坐标</span></span><br><span class="line">b=<span class="built_in">abs</span>(points[i][<span class="number">1</span>]-points[i+<span class="number">1</span>][<span class="number">1</span>]);<span class="comment">//y的最大值，i表示第几个点，1是每个元素的第一个值，即纵坐标</span></span><br><span class="line"><span class="keyword">if</span> (a&gt;=b)    <span class="comment">//a的差值大，就加a</span></span><br><span class="line">&#123;</span><br><span class="line">sum=sum+a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sum=sum+b;  <span class="comment">//b的差值大，就加b</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="164周赛第2题"><a href="#164周赛第2题" class="headerlink" title="164周赛第2题"></a>164周赛第2题</h1><p> 统计参与通信的服务器（逆向思维，从反面，减法出发）<br> 类似求某种存在多少符合条件的结果时，有时用逆向思维，用总数减去不符合的结果可能更简便。</p>
<p> 这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。</p>
<p>如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。</p>
<p>请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。</p>
<p>示例 1：<br><img src="/2019/12/02/leetcode/%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4.jpg" alt></p>
<p>输入：grid = [[1,0],[0,1]]<br>输出：0<br>解释：没有一台服务器能与其他服务器进行通信。<br>示例 2：<br><img src="/2019/12/02/leetcode/%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B41.jpg" alt></p>
<p>输入：grid = [[1,0],[1,1]]<br>输出：3<br>解释：所有这些服务器都至少可以与一台别的服务器进行通信。<br>示例 3：</p>
<p><img src="/2019/12/02/leetcode/%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B42.jpg" alt></p>
<p>输入：grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]<br>输出：4<br>解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。</p>
<p>提示：<br>m == grid.length   //行数<br>n == grid[i].length  //列数<br>1 &lt;= m &lt;= 250<br>1 &lt;= n &lt;= 250<br>grid[i][j] == 0 or 1  //存在or不存在</p>
<p>思路：</p>
<ol>
<li>由第一题启发，先遍历数组，将服务器位置输入，在统计能通信的（先遍历行，存在两个以上的服务器就是一台，列同理，但是缺点明显，会有重复的不好甄别）。</li>
<li>因此选用第二种方法，统计总服务器数目，减去不合结果的服务器（就是那台服务器所在行和列都只有一个1。<br>建立row数组用来存放每行服务器的数目，col数组用来存放每列服务器的数目，遍历数组，如果grid[row][col]存在服务器，且row=1，col=1.则此服务器无法与其他服务器通信，总数减一。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计所有服务器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">			row[i]++;</span><br><span class="line">			col[j]++;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除不能通信的服务器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>&amp;&amp;col[j]==<span class="number">1</span>&amp;&amp;row[i]==<span class="number">1</span>)&#123;</span><br><span class="line">			count--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="leetcode数组算法"><a href="#leetcode数组算法" class="headerlink" title="leetcode数组算法"></a>leetcode数组算法</h1><ol>
<li>删除数组中重复元素：</li>
</ol>
<ul>
<li>复杂算法：对数组进行遍历，找出重复元素个数，并并将其后的元素依次覆盖。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span> <span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">//p是数组首元素的地址，即数组名，size是数组大小</span></span><br><span class="line">	<span class="keyword">int</span> i,count=<span class="number">0</span>,j,i1;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;<span class="built_in">size</span>;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]==a[j])&#123;</span><br><span class="line">			count++;</span><br><span class="line">			<span class="keyword">for</span> (i1=i;i1&lt;<span class="built_in">size</span><span class="number">-1</span>;i1++)&#123;</span><br><span class="line">                    a[i1]=a[i1+<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">size</span>-count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>循环比较前后两个数字，如果相同就跳过，如果不同就将这个数字存进当前数组(数组下标从0开始)，并且len++；<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span> <span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="异或的使用-自反性"><a href="#异或的使用-自反性" class="headerlink" title="异或的使用(自反性)"></a>异或的使用(自反性)</h1><ol>
<li>异或的自反性是指：a ^ b ^ a = b。即对给定的数A，用同样的运算因子（B）作两次异或运算后仍得到A本身。</li>
<li>所有的程序教科书都会向初学者指出，要交换两个变量的值，必须要引入一个中间变量。但如果使用异或，就可以节约一个变量的存储空间：<br>设有A,B两个变量，存储的值分别为a，b，则以下三行表达式将互换他们的值 表达式（值）：<br>A=A^B(a^b)<br>B=B^A(b^a^b=a)<br>A=A^B(a^b^a=b)</li>
<li>落单的数</li>
</ol>
<p>给出2*n + 1 个的数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。<br>样例<br>给出 [1,2,2,1,3,4,3]，返回 4<br>此题可以用异或的性质做：一个数与自身异或的结果为0。我们只需遍历数组中的每一个元素，并将其进行异或。因为，异或满足交换律，所以最终的异或结果将仅仅包含只出现一次的那个数。<br>如：1 ^ 2 ^ 2 ^ 1 ^3 ^ 4 ^ 3 = 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 = 4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param A: An integer array</span></span><br><span class="line"><span class="comment">     * @return: An integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="comment">//采用异或的操作可以解决这个问题</span></span><br><span class="line">        <span class="keyword">if</span>(A.empty())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i != A.size();++i)&#123;</span><br><span class="line">            n = n^A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="当需要根据输入n来决定几位数时"><a href="#当需要根据输入n来决定几位数时" class="headerlink" title="当需要根据输入n来决定几位数时"></a>当需要根据输入n来决定几位数时</h1><ol>
<li>根据输入n来确定位数是先设start和end，用pow赋值<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> start = <span class="built_in">pow</span>(<span class="number">10</span>,n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">end</span> = <span class="built_in">pow</span>(<span class="number">10</span>,n);</span><br><span class="line"><span class="keyword">for</span>(i=start;i&lt;<span class="built_in">end</span>;i++)&#123;</span><br><span class="line">	..........</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="字符与出现次数一一对应的数组-特定法则"><a href="#字符与出现次数一一对应的数组-特定法则" class="headerlink" title="字符与出现次数一一对应的数组(特定法则)"></a>字符与出现次数一一对应的数组(特定法则)</h1><ol>
<li>将字符顺序与出现次数一一对应(仅限于字符种类已知的情况下，改进方法是创立127位数组，一位ASCII码就是127)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出0代表没有满足条件的</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">findFirstNoRepeatChar</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(str == <span class="keyword">null</span> || str.trim().length()==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> []counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">		str = str.toLowerCase(); <span class="comment">//防止出现大小写混乱的情况</span></span><br><span class="line">		<span class="keyword">int</span> len = str.length();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">			counts[str.charAt(i) - <span class="string">'a'</span>]++;<span class="comment">//charAt函数是根据索引位置返回索引位置的字符值，索引范围是[0,length-1]</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(counts[str.charAt(i) - <span class="string">'a'</span>] == <span class="number">1</span>)&#123;<span class="comment">//就是通过字符与a的相对位置，来确定次数数组的位置</span></span><br><span class="line">				<span class="keyword">return</span> str.charAt(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(findFirstNoRepeatChar(<span class="string">"abaccdeff"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUnique3</span><span class="params">(<span class="built_in">string</span> &amp;str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">127</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        c[str[i]]++;</span><br><span class="line">        <span class="keyword">if</span> (c[str[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>解法2：挑战中有提到不使用额外存储空间，能想到的解法是循环两次，内循环中遇到相同字母则结束，返回false。</li>
</ol>
<p>时间复杂度O(n^2),空间复杂度O(1)。</p>
<p>代码如下：</p>
<p>bool isUnique2(string &amp;str) {<br>    if (str.size() == 0 || str.size() == 1) {<br>        return true;<br>    }</p>
<pre><code>for (int i = 0; i &lt; str.size() - 1; i++) {
    for (int j = i+1; j &lt; str.size(); j++) {
        if (str[i] == str[j]) {
            return false;
        }
    }
}
return true;</code></pre><p>}</p>
<ul>
<li>变式：先排序，然后比较当前字符与前后两个字符是否相同，若不同就是答案</li>
</ul>
<ol start="3">
<li>用哈希表，键值对</li>
<li>7-2 求整数序列中出现次数最多的数 (15分)<br>本题要求统计一个整型序列中出现次数最多的整数及其出现次数。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret =<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line"><span class="keyword">int</span> a[number],temp[number];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">	count=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;number;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]==a[j])&#123;</span><br><span class="line">			count++;</span><br><span class="line">			temp[i]=count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = temp[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(temp[i]&gt;<span class="built_in">max</span>)&#123;</span><br><span class="line">		<span class="built_in">max</span>=temp[i];</span><br><span class="line">		ret = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d"</span>,a[ret],temp[ret]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>各种工具的问题和解决办法</title>
    <url>/2019/12/01/problem/</url>
    <content><![CDATA[<h1 id="devc-中文乱码"><a href="#devc-中文乱码" class="headerlink" title="devc++中文乱码"></a>devc++中文乱码</h1><p>是因为dev采用ANCI编码，不是用UTF-8编码<br>解决办法： </p>
<ul>
<li><p>用notpadc++打开，选择ANCI编码。</p>
<a id="more"></a>
<p><img src="/2019/12/01/problem/devc++.png" alt></p>
<ul>
<li>直接在dev中编辑</li>
</ul>
</li>
</ul>
<hr>
<h1 id="dev中斜杠报错"><a href="#dev中斜杠报错" class="headerlink" title="dev中斜杠报错"></a>dev中斜杠报错</h1><p>是不支持c++注释语法，误点击编辑器选项<br>解决办法：将<code>支持所有ANCI标准设置为NO</code><br><img src="/2019/12/01/problem/devc++1.png" alt></p>
<hr>
<h1 id="hexo中出现的中文乱码现象"><a href="#hexo中出现的中文乱码现象" class="headerlink" title="hexo中出现的中文乱码现象"></a>hexo中出现的中文乱码现象</h1><p> 第一步： 首先找到根目录下_config.yml文件，将langue字段设为zh-Hans或者zh-CN（简体中文），具体何种类型取决于theme主题中source文件中的language文件夹中有何种语言文件。<br><img src="/2019/12/01/problem/config_language.png" alt></p>
<p><img src="/2019/12/01/problem/theme_language.png" alt><br> 第二步： 出现乱码可能是因为用记事本编辑没有使用UTF-8编码，解决办法：下载文本编辑器（例如sublime）进行编辑。</p>
<p><img src="/2019/12/01/problem/sublime_encode.png" alt><br> 第三步： 点击sublime中file下的save with Encoding，选择UTF-8，<br> 直接点击save可能会出现警告.</p>
<hr>
<h1 id="hexo的图片上传"><a href="#hexo的图片上传" class="headerlink" title="hexo的图片上传"></a>hexo的图片上传</h1><p>  在根目录下建立与文章同名的文件夹，将图片放进去引用即可，或者用网络地址引用。<br> <img src="/2019/12/01/problem/image_post.png" alt></p>
<hr>
<h1 id="图标点击显示找不到页面。"><a href="#图标点击显示找不到页面。" class="headerlink" title="图标点击显示找不到页面。"></a>图标点击显示找不到页面。</h1><p><img src="/2019/12/01/problem/icon.png" alt><br>第一步：打开主题目录设置文件，找到menu。<br><img src="/2019/12/01/problem/menu.png" alt><br>第二步：将每个图标斜杠/后的空格删去。<br><img src="/2019/12/01/problem/menu1.png" alt></p>
<hr>
<h1 id="文章添加多个tags"><a href="#文章添加多个tags" class="headerlink" title="文章添加多个tags"></a>文章添加多个tags</h1><p>不能直接在tags标签后用空格隔开标签，应该用方括号中间用逗号隔开,<br>否则会出现文章无法上传的问题。</p>
<hr>
<h1 id="hexo页面上传"><a href="#hexo页面上传" class="headerlink" title="hexo页面上传"></a>hexo页面上传</h1><ol>
<li>标签和其他页面的格式要符合hexo的表准，单个标签用双引号，多个用方括号，中间不用双引号，否则页面无法上传。</li>
</ol>
<hr>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><ol>
<li>navicat 10061(MySQL服务未开启，无法连接到数据库)，是由于再金山毒霸里开启了开机加速，导致MySQL被禁止开机自启动，取消限制后任然没有作用，就可以通过手动启动来解决。</li>
</ol>
<ul>
<li>win + R启动运行程序，输入services.msc<br><img src="/2019/12/01/problem/mysql.png" alt></li>
<li>找到mysql服务打开即可<br><img src="/2019/12/01/problem/mysql1.png" alt></li>
</ul>
<h1 id="复制代码时会有大量？号或者其他乱码太多不好删除"><a href="#复制代码时会有大量？号或者其他乱码太多不好删除" class="headerlink" title="复制代码时会有大量？号或者其他乱码太多不好删除"></a>复制代码时会有大量？号或者其他乱码太多不好删除</h1><p>用ctrl+f，利用替换，选择范围从头开始而不是从当前光标开始，将乱码替换为空格，比用手更快捷</p>
]]></content>
      <categories>
        <category>problem solution</category>
      </categories>
      <tags>
        <tag>解决办法，工具软件</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希函数和哈希表（其他查找函数）</title>
    <url>/2019/11/29/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>定义：根据哈希函数和冲突处理办法将数据存储在一段连续的空间中。</p>
<p>不同于其他查找函数需要对值进行匹配，哈希表在建立时为每一个数据建立一个独一无二的关键字，这样查找时可以根据关键字直接找到数据。</p>
<a id="more"></a>

<hr>
<h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><p>哈希函数需要满足两个条件，假设哈希表有m个关键字，则取值范围是<br>[0，m-1]。</p>
<ol>
<li>哈希函数的值域必须在[0，m-1]的范围内。</li>
<li>保证哈希函数的每个值在[0,m-1]内的概率相等。</li>
</ol>
<hr>
<h1 id="哈希函数的几种办法"><a href="#哈希函数的几种办法" class="headerlink" title="哈希函数的几种办法"></a>哈希函数的几种办法</h1><ol>
<li>直接定址法：适用与线性数据，比如年龄，日期等</li>
<li>数字分析法：适用与某些数据中有大量重复字段，且可以预知全部的可能出现的值，取其中若干的字段作为关键字。</li>
<li>平方取中法：适用与字段较短，可以先平方，再取中间的字段作为关键字，因为中间的字段与每个数据都有关系，可以增加概率的平均性。</li>
<li>折叠法：将关键值分割为几个位数相同的部分，取这几个部分的叠加和作为哈希地址。</li>
</ol>
<ul>
<li>移位叠加<br>   各部分按照最低位对齐（舍去进位，即相加后多出切割位的数字），然后相加。</li>
<li>间界叠加<br>   关键字值从一端向另一端沿分界线来回折叠，然后对齐相加。</li>
</ul>
<ol start="5">
<li>除留余数法：被除数必须是素数，否则会出现关键字大量重复。（最大公倍数原理）</li>
</ol>
<hr>
<h1 id="处理冲突方法"><a href="#处理冲突方法" class="headerlink" title="处理冲突方法"></a>处理冲突方法</h1><p>当哈希函数值相同时，位置已经被其他数据占用，则按照冲突处理方法寻找下一个位置。</p>
<ol>
<li>开放定址法：令Hi=(H(key)+di)%m,其中H(key)时哈希函数，di是增量序列。</li>
</ol>
<ul>
<li>若di取1，2，3，4….m-1，则为线性探测再散列。</li>
<li>若di取1^2,-1^2,2^2,-2^2..+k^2,-k^2,则为二次探测再散列。</li>
<li>若di取伪随机数序列，则称伪随机探测再散列。</li>
</ul>
<ol start="2">
<li>链表寻址法： 对重复数据建立链表，并且将每个链表有序排列，</li>
<li>公共溢出区法： 将哈希表的一部分作为公共区，重复数据依次放入。</li>
</ol>
<hr>
<h1 id="哈希表中查找元素"><a href="#哈希表中查找元素" class="headerlink" title="哈希表中查找元素"></a>哈希表中查找元素</h1><p>  与插入的方法差不多，按关键字寻找，遇到冲突按照法则寻找。</p>
<hr>
<hr>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c语言，数据结构，查找算法，链表</tag>
      </tags>
  </entry>
  <entry>
    <title>函数输出水仙花数（求各位数之和新解）</title>
    <url>/2019/11/24/pta/</url>
    <content><![CDATA[<h1 id="求各位数之和新解"><a href="#求各位数之和新解" class="headerlink" title="求各位数之和新解"></a>求各位数之和新解</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">          temp=x%<span class="number">10</span>;<span class="comment">//取出最后一位数</span></span><br><span class="line">          x=x/<span class="number">10</span>;<span class="comment">//去掉最后一位数</span></span><br><span class="line">          y=temp+y*<span class="number">10</span>;<span class="comment">//在还原</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是求出未知数各个位置的和。<br>与之前从第一位开始求不同，这种更方便，无需根据具体位数设置相应个数的变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* run this program using the console pauser or add your own getch, system("pause") or input loop */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line"><span class="keyword">int</span> i,a,b,c,d,e,f,g,t; </span><br><span class="line"><span class="keyword">if</span>(N==<span class="number">3</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">100</span>;i&lt;=<span class="number">999</span>;i++)&#123;</span><br><span class="line">		a=i/<span class="number">100</span>;</span><br><span class="line">		b=(i%<span class="number">100</span>)/<span class="number">10</span>;</span><br><span class="line">		c=(i%<span class="number">100</span>)%<span class="number">10</span>;</span><br><span class="line">	t=a*a*a+b*b*b+c*c*c;</span><br><span class="line">    <span class="keyword">if</span>((a*<span class="number">100</span>+b*<span class="number">10</span>+c)==t)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a*<span class="number">100</span>+b*<span class="number">10</span>+c);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(N==<span class="number">4</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1000</span>;i&lt;=<span class="number">9999</span>;i++)&#123;</span><br><span class="line">		a=i/<span class="number">1000</span>;</span><br><span class="line">		b=i%<span class="number">1000</span>/<span class="number">100</span>;</span><br><span class="line">		c=i%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">		d=i%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">	t=a*a*a*a+b*b*b*b+c*c*c*c+d*d*d*d;</span><br><span class="line">    <span class="keyword">if</span>((a*<span class="number">1000</span>+b*<span class="number">100</span>+c*<span class="number">10</span>+d)==t)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line"> <span class="keyword">if</span>(N==<span class="number">5</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">10000</span>;i&lt;<span class="number">99999</span>;i++)&#123;</span><br><span class="line">		a=i/<span class="number">10000</span>;</span><br><span class="line">		b=(i%<span class="number">10000</span>)/<span class="number">1000</span>;</span><br><span class="line">		c=(i%<span class="number">10000</span>)%<span class="number">1000</span>/<span class="number">100</span>;</span><br><span class="line">		d=(i%<span class="number">10000</span>)%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">		e=(i%<span class="number">10000</span>)%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">	t=a*a*a*a*a+b*b*b*b*b+c*c*c*c*c+d*d*d*d*d+e*e*e*e*e;</span><br><span class="line">    <span class="keyword">if</span>(a*<span class="number">10000</span>+b*<span class="number">1000</span>+c*<span class="number">100</span>+d*<span class="number">10</span>+e==t)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">if</span>(N==<span class="number">6</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">100000</span>;i&lt;<span class="number">999999</span>;i++)&#123;</span><br><span class="line">		a=i/<span class="number">100000</span>;</span><br><span class="line">		b=i%<span class="number">100000</span>/<span class="number">10000</span>;</span><br><span class="line">		c=i%<span class="number">100000</span>%<span class="number">10000</span>/<span class="number">1000</span>;</span><br><span class="line">		d=i%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>/<span class="number">100</span>;</span><br><span class="line">		e=i%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">		f=i%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">	t=a*a*a*a*a*a+b*b*b*b*b*b+c*c*c*c*c*c+d*d*d*d*d*d+e*e*e*e*e*e+f*f*f*f*f*f;</span><br><span class="line">    <span class="keyword">if</span>((a*<span class="number">100000</span>+b*<span class="number">10000</span>+c*<span class="number">1000</span>+d*<span class="number">100</span>+e*<span class="number">10</span>+f)==t)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a*<span class="number">100000</span>+b*<span class="number">10000</span>+c*<span class="number">1000</span>+d*<span class="number">100</span>+e*<span class="number">10</span>+f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">if</span>(N==<span class="number">7</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1741723</span>;i&lt;<span class="number">9999999</span>;i++)&#123;</span><br><span class="line">		a=i/<span class="number">1000000</span>;</span><br><span class="line">		b=i%<span class="number">1000000</span>/<span class="number">100000</span>;</span><br><span class="line">		c=i%<span class="number">1000000</span>%<span class="number">100000</span>/<span class="number">10000</span>;</span><br><span class="line">		d=i%<span class="number">1000000</span>%<span class="number">100000</span>%<span class="number">10000</span>/<span class="number">1000</span>;</span><br><span class="line">		e=i%<span class="number">1000000</span>%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>/<span class="number">100</span>;</span><br><span class="line">		f=i%<span class="number">1000000</span>%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">		g=i%<span class="number">1000000</span>%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">		t=a*a*a*a*a*a*a+b*b*b*b*b*b*b+c*c*c*c*c*c*c+d*d*d*d*d*d*d+e*e*e*e*e*e*e+f*f*f*f*f*f*f+g*g*g*g*g*g*g;</span><br><span class="line">	<span class="keyword">if</span>((a*<span class="number">1000000</span>+b*<span class="number">100000</span>+c*<span class="number">10000</span>+d*<span class="number">1000</span>+e*<span class="number">100</span>+f*<span class="number">10</span>+g)==t)</span><br><span class="line">	                        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a*<span class="number">1000000</span>+b*<span class="number">100000</span>+c*<span class="number">10000</span>+d*<span class="number">1000</span>+e*<span class="number">100</span>+f*<span class="number">10</span>+g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然上面也可以用for循环+pow函数但还是不够简便。</p>
<hr>
<h1 id="逆序数输出（由末位新解联想）"><a href="#逆序数输出（由末位新解联想）" class="headerlink" title="逆序数输出（由末位新解联想）"></a>逆序数输出（由末位新解联想）</h1><ol>
<li><p>数学法：通过末尾取余将末尾数取出，在依次*10，便能输出逆序数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number,x,t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">	<span class="keyword">while</span>(number!=<span class="number">0</span>)&#123;</span><br><span class="line">		t=t*<span class="number">10</span>+number%<span class="number">10</span>;  <span class="comment">//每次t向前移动一位</span></span><br><span class="line">	    number/=<span class="number">10</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,t);		</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串法：转为字符串逆序输出。。。。。</p>
</li>
</ol>
<hr>
<h1 id="另一种应用-回文数"><a href="#另一种应用-回文数" class="headerlink" title="另一种应用(回文数)"></a>另一种应用(回文数)</h1><ol>
<li><p>存为数组，用a[i]与a[n-i-1]相互比较</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(a[i]!=a[n-i<span class="number">-1</span>])&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"false"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		flag++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"true"</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>反转一半数：用末尾数新解，对输入数后一半进行逆序排序，将它和变化后的number比较。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> number,t=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">	<span class="keyword">if</span>(number&lt;<span class="number">0</span>||(number%<span class="number">10</span>==<span class="number">0</span>&amp;&amp;number!=<span class="number">0</span>))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"false"</span>);         <span class="comment">// 数字为负数或者末尾是0但首位肯定不是0，就不可能是回文数</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(number&gt;t)&#123; <span class="comment">//当number&gt;t时，说明t的位数比number小，即没有到中间，并且中间数肯定等于自身，不需判定。</span></span><br><span class="line">			t=t*<span class="number">10</span>+number%<span class="number">10</span>;</span><br><span class="line">			number/=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(number==t)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"true"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"false"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="顺序查找法"><a href="#顺序查找法" class="headerlink" title="顺序查找法"></a>顺序查找法</h1><p>顺序查找法：<br>特点：对每一个数据进行比较，如果符合就返回。<br>优点：空间复杂度小，数据小时处理有优势，思路简单。<br>缺点：时间复杂度大，数据一大运行时间会大大增加。<br>时间复杂度：最好是找1次就可以，最坏是找n次，平均是（n+1）/2.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">顺序查找法：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">200</span>];</span><br><span class="line">	<span class="keyword">int</span> number,i;</span><br><span class="line">	<span class="keyword">int</span> target;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);                <span class="comment">//输入数组</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;target);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]==target)&#123;                  <span class="comment">//判断是否相等</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d is in the list\n"</span>,target);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"target's location is %d(从1开始计数)"</span>,i+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找法：<br>特点：数据必须要有序排列。<br>优点：运行时间比顺序查找法少，数据大时有优势。<br>缺点：数据必须有序，先得排序，空间复杂度比顺序查找法高，思路不容易想到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> low,high,mid;</span><br><span class="line">	low=<span class="number">0</span>;<span class="comment">//low和high表示的下标区间，因此high要在数组个数上减去1</span></span><br><span class="line">	high=<span class="number">10</span><span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)&#123;<span class="comment">//注意=号，因为可能就是中值为目标</span></span><br><span class="line">		mid=(high+low)/<span class="number">2</span>;<span class="comment">//这里不需要考虑除不尽，取整和下面的操作会取到所有的下标</span></span><br><span class="line">        <span class="keyword">if</span>(a[mid]==x);<span class="comment">//x为目标值</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&gt;x)&#123;<span class="comment">//说明目标值在中值的左边,就要把右区间设为mid-1</span></span><br><span class="line">             high=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        	low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//找不到返回-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="选择排序法"><a href="#选择排序法" class="headerlink" title="选择排序法"></a>选择排序法</h1><p>两次循环,每次将最小的放在第一个,然后将第二最小的数放在第二个,以此类推,期间调用交换函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">12</span>];</span><br><span class="line">	<span class="keyword">int</span> i,j,<span class="built_in">min</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">12</span><span class="number">-1</span>;i++)&#123;<span class="comment">//只要进行个数-1次,最后一个数不用动</span></span><br><span class="line">		<span class="built_in">min</span>=i;<span class="comment">//每次最小值更新</span></span><br><span class="line">		<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;<span class="number">12</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]&lt;a[<span class="built_in">min</span>])&#123;</span><br><span class="line">				<span class="built_in">min</span>=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(&amp;a[<span class="built_in">min</span>],&amp;a[i]);<span class="comment">//交换最小值</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	t=*a;</span><br><span class="line">	*a=*b;</span><br><span class="line">	*b=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="p-和P-i的区别"><a href="#p-和P-i的区别" class="headerlink" title="p++和P+i的区别"></a>p++和P+i的区别</h1><ol>
<li>p++操作完后指针已经移位,要想重新输出,就要另设新指针,令新指针指向数组首地址才能继续输出,否则输出的是随机数,容易忘记,所以用p+i更加保险</li>
<li>数组名相当于指针常量,是不能像指针一样变动的,所以将数组名更改后数组的任然是原数组,不会变</li>
</ol>
<h1 id="数组的转置"><a href="#数组的转置" class="headerlink" title="数组的转置"></a>数组的转置</h1><ol>
<li>建立一个新数组，将i和j颠倒重新输入，就能转置</li>
<li>将左对角线右上方的数组元素与主对角线左下方的数组元素进行单方向交换<br>不一定是方阵，可以是任意MxN的矩阵<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j&gt;i)</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">/*将主对角线右上方的数组元素与主对角线左下方的数组元素进行单方向交换*/</span></span><br><span class="line"></span><br><span class="line">temp=n[i][j];</span><br><span class="line"></span><br><span class="line">n[i][j]=n[j][i];</span><br><span class="line"></span><br><span class="line">n[j][i]=temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"转置矩阵：\n"</span>);</span><br></pre></td></tr></table></figure></li>
<li>用第一种方法转置后，如果i和j不一样大，那么就得新建立一个长为m的行指针，<br>不然会出现运行时错误<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*P)[<span class="number">3</span>];<span class="comment">//原来是3x2矩阵</span></span><br><span class="line"><span class="keyword">int</span> (*a)[<span class="number">2</span>];<span class="comment">//转置后变为2x3矩阵，就要重新定义行指针</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>求各个位数和新解</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2019/11/23/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="scanf与gets的区别"><a href="#scanf与gets的区别" class="headerlink" title="scanf与gets的区别"></a>scanf与gets的区别</h1><ol>
<li>gets的分割符只有回车，而scanf的分隔符是所以空白字符(空格，制表符，回车)，因此gets能够读入空格，scanf不能<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">23</span>];</span><br><span class="line">gets(str);<span class="comment">//输入hello world，会原样输出，</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);<span class="comment">//scanf遇到空格会停止读入，输出hello</span></span><br></pre></td></tr></table></figure></li>
<li>对待buffer(缓冲区)里的空白字符不同：scanf在读取非空白字符之前会忽略掉空白字符(被忽略的空白字符会被scanf移走)，当读取结束后，会将分割符留在缓冲区中，而gets遇到回车就会结束输出，并将回车从缓冲区中移走，例如输入”\nhello\n”,scanf会先忽略\n，读入hello，遇到\n输入完成，将\n留在缓冲区，这是缓冲区里什么也没有，而gets遇到第一个\n就会停止输入，这时缓冲区里只剩hello\n，gets读入的是一个空串，即首字符为’\0’的字符串</li>
<li>gets读走分隔符后会用’\0’来代替分隔符</li>
<li>在程序中有时会遇到scanf，gets连用的，就会出先scanf留在缓冲区的空白字符是\n，导致gets只能读入空白字符串的情况，这时就可以用scanf(“%s”,str)来读走最后一个空表字符前的所有空表字符，再用getchar读入一个空白字符就可以解决问题</li>
<li>用gets读取是无上限的，但要保证缓冲区足够大，才不会发生内存溢出</li>
</ol>
<hr>
<h1 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h1><ol>
<li>用二维数组定义。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">3</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str1[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,str1[<span class="number">1</span>]);  <span class="comment">//输出第二个字符串</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>字符串数组第一个[]存储的是一位字符数组的地址，如果想获取具体某一个字符的话，就要加上列指针<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">3</span>][<span class="number">23</span>];</span><br><span class="line">str[<span class="number">2</span>];<span class="comment">//指向最后一行</span></span><br><span class="line">str[<span class="number">2</span>][<span class="number">0</span>];<span class="comment">//指向最后一行第一个字符</span></span><br></pre></td></tr></table></figure></li>
<li>二维数组名实际上是一个二级指针，而字符指针只是一个指向字符串的指针</li>
</ol>
<hr>
<h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><ol>
<li>puts函数：函数中可以加入转义符，且在输出结束字符串后会自动转行<br><code>char str[]={&quot;hello\nworld!&quot;};</code></li>
<li>strcat函数：<code>strcat(str1,str2);</code>是将两个字符串连接起来，返回值是字符串数组1的地址，并且注意字符串1的长度必须足够大。</li>
<li>strcpy：字符串复制函数<code>strcpy(str1,str2)</code>若是采用数组元素一个个赋值不方便，直接用函数赋值。<br>strcpy可以是数组名复制，也可以是字符串常量<code>strcpy(str1,&quot;china!&quot;);</code></li>
<li>strcmp：字符串比较函数（strcmp（str1，str2）），若str1&lt; str2，返回值小于0，若str1&gt;str2,返回值大于0.若str1==str2，则返回0（用来判断字符串的结束标志）。</li>
</ol>
<h1 id="字符串数组与函数名做参"><a href="#字符串数组与函数名做参" class="headerlink" title="字符串数组与函数名做参"></a>字符串数组与函数名做参</h1><ol>
<li>当要通过某个特定值来确定函数是否结束时，用strcmp==0来判断，而不    用srt[i]==’#’或者str [i] [j]=’#’来判断,即使特 定符号已经出现程序也会直接跳过(具体原因不知，有空再说)。</li>
<li>给字符串数组赋结束标志’\0’时，不能用str[i]==’\0’，而是应用str<br>[i][j]==’\0’来赋值(可能因为一个字符只能放一个数组格)</li>
<li>数组名做参：定义函数时，如果定义二维数组，那么列的值不能为空<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> fet (<span class="built_in">int</span> han[][<span class="number">20</span>])&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>注意形参要带变量类型，但是调用函数时不需要，尤其是字符串数组，只要带入数组名即可不需要包括后面[]的大小<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">fet(<span class="name">han</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>-</p>
<h1 id="删除字符串中指定类型-由删除字符串中数字衍生而来"><a href="#删除字符串中指定类型-由删除字符串中数字衍生而来" class="headerlink" title="删除字符串中指定类型(由删除字符串中数字衍生而来)"></a>删除字符串中指定类型(由删除字符串中数字衍生而来)</h1><ol>
<li>通过循环将后面一个元素一直赋给前一个元素(小技巧，非数字可以用&lt;0or&gt;9)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span> <span class="params">(<span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">	gets(str);</span><br><span class="line">    del(str);</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span> <span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>,j;</span><br><span class="line">      <span class="keyword">for</span> (i=<span class="number">0</span>;*(str+i)!=<span class="string">'\0'</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">      	<span class="keyword">if</span>((*(str+i)&gt;=<span class="string">'0'</span>)&amp;&amp;(*(str+i)&lt;=<span class="string">'9'</span>))&#123;</span><br><span class="line">      		<span class="keyword">for</span> (j=i;*(str+j+<span class="number">1</span>)!=<span class="string">'\0'</span>;j++)</span><br><span class="line">      		&#123;</span><br><span class="line">      			*(str+j)=*(str+j+<span class="number">1</span>);	</span><br><span class="line">      		&#125;</span><br><span class="line">      		*(str+j)=<span class="string">'\0'</span>;<span class="comment">//每次向前移，就将结束标志前移 </span></span><br><span class="line">      		i=<span class="number">0</span>;<span class="comment">//不用双重循环就得将i置0，从头开始继续判断 </span></span><br><span class="line">      	&#125;</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
或者<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteString</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">char</span> str[<span class="number">15</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">15</span>];</span><br><span class="line">gets(str); </span><br><span class="line">deleteString(str,str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteString</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">char</span> str[<span class="number">15</span>])</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line">	<span class="keyword">char</span> *p1;</span><br><span class="line">	<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(p=a;p&lt;a+<span class="built_in">strlen</span>(str);p++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!(<span class="number">65</span>&lt;=*p&amp;&amp;*p&lt;=<span class="number">90</span>||<span class="number">97</span>&lt;=*p&amp;&amp;*p&lt;=<span class="number">122</span>))&#123;</span><br><span class="line">		          <span class="keyword">for</span>(p1=p;*p1!=<span class="string">'\0'</span>;p1++)&#123;</span><br><span class="line">		          	*p1=*(p1+<span class="number">1</span>);</span><br><span class="line">		          	 p--;</span><br><span class="line">				  &#125;</span><br><span class="line">		   &#125;</span><br><span class="line">		      </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(p=a;p&lt;a+<span class="built_in">strlen</span>(str);p++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>,*p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将符合要求的字符存入对应的位置<br>遇到符合条件的就可以按从头之尾的顺序输进原数组<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span> <span class="params">(<span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">23</span>];</span><br><span class="line">	gets(str);</span><br><span class="line">	del(str);</span><br><span class="line">	<span class="built_in">puts</span>(str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span> <span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,k=<span class="number">0</span>;</span><br><span class="line">     for (i=0;*(str+i)!='\0;i++)</span><br><span class="line">     &#123;</span><br><span class="line">     	<span class="keyword">if</span> (*(str+i)&lt;<span class="string">'0'</span>||*(str+i)&gt;<span class="string">'9'</span>)<span class="comment">//想要保留的字符</span></span><br><span class="line">     	&#123;</span><br><span class="line">     		*(str+(k++))=*(str+i);<span class="comment">//k每次自加</span></span><br><span class="line">     	&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     *(str+k)=<span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>建立新数组，将符合与不符合的分离，但是需要开辟新的数据空间</li>
</ol>
<h1 id="复制部分字符串"><a href="#复制部分字符串" class="headerlink" title="复制部分字符串"></a>复制部分字符串</h1><ol>
<li>指针要移动到目标位置-1处，因为基数不同</li>
<li>要一对一的赋值，不能因为s和t传进来的是指针，而不是数组，s并不会向后自动输出直到’\0’。</li>
<li>记得加上结束标志<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strmcpy</span><span class="params">( <span class="keyword">char</span> *t, <span class="keyword">int</span> m, <span class="keyword">char</span> *s )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t+=m<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(*t)</span><br><span class="line">        *s++=*t++;<span class="comment">//要一步步赋值，</span></span><br><span class="line">    <span class="comment">//因为s和t传进来的是指针，而不是数组，s并不会向后自动输出直到'\0'</span></span><br><span class="line">    *s=<span class="number">0</span>;<span class="comment">//加上结束标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="键盘输入字符串，并将其地址存入指针数组中"><a href="#键盘输入字符串，并将其地址存入指针数组中" class="headerlink" title="键盘输入字符串，并将其地址存入指针数组中"></a>键盘输入字符串，并将其地址存入指针数组中</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">3</span>][<span class="number">34</span>];</span><br><span class="line"><span class="keyword">char</span> *p[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	gets(str);</span><br><span class="line">	p[i]=str[i];<span class="comment">//关键就在这，str[i]实际上是二维数组每行的首地址，而</span></span><br><span class="line">	<span class="comment">//字符串正好就是按行地址输出的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串数组和指针数组区别"><a href="#字符串数组和指针数组区别" class="headerlink" title="字符串数组和指针数组区别"></a>字符串数组和指针数组区别</h1><ol>
<li></li>
</ol>
<ul>
<li>数组法占用空间大，必须开辟可以容纳最大字符串长度的空间，会造从内存的浪费，而指针数组存放的是指针，空间占用小。</li>
<li>数组法操作运行次数多，每次进行字符串的交换都要进入strcpy函数，耗费时间比指针法多，指针法只需要交换指针所指的值就可以</li>
<li>字符数组做形参时，数组大小要标出</li>
<li>指针数组，使用时需要进行初始化赋值，或者需要指向具体的内存单元后，才能作为函数实参进行调用</li>
<li>指针数组 作为函数形参时，数组大小可以不指定</li>
</ul>
<ol start="2">
<li><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    <span class="keyword">char</span> str[N][<span class="number">30</span>],tmp[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(str[j],str[j+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(tmp,str[j]);</span><br><span class="line">                <span class="built_in">strcpy</span>(str[j],str[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">strcpy</span>(str[j+<span class="number">1</span>],tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After sorted:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> *p,<span class="keyword">char</span> *p1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N,j,i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">	<span class="keyword">char</span> str[N][<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> *p[N];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		p[i]=str[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">          	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(p[j],p[j+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">          		swap(p[j],p[j+<span class="number">1</span>]);</span><br><span class="line">          	&#125;</span><br><span class="line">          &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="built_in">puts</span>(str[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> *p,<span class="keyword">char</span> *p1)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *t=<span class="literal">NULL</span>；</span><br><span class="line">	t=p;</span><br><span class="line">	p=p1;</span><br><span class="line">	p1=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="使用命令行输主函数参数"><a href="#使用命令行输主函数参数" class="headerlink" title="使用命令行输主函数参数"></a>使用命令行输主函数参数</h1><ol>
<li>int main(int argc, char * argv[]){}<br>argc 是命令行输入的参数字符串个数，argv是字符指针数组，元素按顺序指向命令行的参数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">c.exe <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">argc=<span class="number">4</span>;</span><br><span class="line">argv[0]='c.exe';</span><br><span class="line">argv[<span class="number">1</span>]=<span class="string">'1'</span>;</span><br><span class="line">argv[<span class="number">2</span>]=<span class="string">'+'</span>;</span><br><span class="line">argv[<span class="number">3</span>]=<span class="string">'2'</span>;</span><br><span class="line">``` </span><br><span class="line"><span class="number">2.</span> 使用命令行首先要生成可执行文件，然后通过dos命令转到可执行文件所在目录，再输入参数</span><br><span class="line">```c</span><br><span class="line"><span class="comment">//假设可执行文件在D：\test</span></span><br><span class="line"></span><br><span class="line">d:</span><br><span class="line">cd test</span><br><span class="line">c.exe <span class="number">1</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li>字符串数组第一个[]存储的是一位字符数组的地址，如果想获取具体某一个字符的话，就要加上列指针<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">3</span>][<span class="number">23</span>];</span><br><span class="line">str[<span class="number">2</span>];<span class="comment">//指向最后一行</span></span><br><span class="line">str[<span class="number">2</span>][<span class="number">0</span>];<span class="comment">//指向最后一行第一个字符</span></span><br><span class="line"><span class="comment">//比如这里要判断是什么数学符号，就要用argv[2][0],而不是argv[2]</span></span><br><span class="line"><span class="comment">//因为字符数组形式和字符不等价</span></span><br></pre></td></tr></table></figure></li>
<li>字符化为整型数<br>用aoti函数化整数，aotf化浮点数<br>iota将整数化为字符，fota将浮点数化为字符<br>传入字符的指针即可<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">char *p='afsudiijsa';</span><br><span class="line">aoti(p);</span><br><span class="line"><span class="comment">//在主函数中，就是argv【1】和argv【3】，而不是*argv【1】</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="在printf函数中输出"><a href="#在printf函数中输出" class="headerlink" title="在printf函数中输出%"></a>在printf函数中输出%</h1><p>%是格式符，想要输出文本，就得用两个%%</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d%%%d=%d\n"</span>,a,b,a%b);</span><br></pre></td></tr></table></figure>

<h1 id="给字符数组赋值"><a href="#给字符数组赋值" class="headerlink" title="给字符数组赋值"></a>给字符数组赋值</h1><p>main()<br>{<br>char s[30];<br>strcpy(s, “Good News!”); /<em>给数组赋字符串</em>/<br>.<br>.<br>.<br>}<br>上面程序在编译时, 遇到char s[30]这条语句时, 编译程序会在内存的某处留<br>出连续30个字节的区域, 并将第一个字节的地址赋给s。当遇到strcpy( strcpy 为<br>Turbo C2.0的函数)时, 首先在目标文件的某处建立一个”Good News!/0” 的字符串。<br>其中/0表示字符串终止, 终止符是编译时自动加上的, 然后一个字符一个字符地复<br>制到s所指的内存区域。因此定义字符串数组时, 其元素个数至少应该比字符串的<br>长度多1。<br>注意:</p>
<ol>
<li>字符串数组不能用”=”直接赋值, 即s=”Good News!”是不合法的。所以应分<br>清字符串数组和字符串指针的不同赋值方法。</li>
<li>对于长字符串, Turbo C2.0允许使用下述方法:<br>例如:<br>main()<br>{<br>char s[100];<br>strcpy(s, “The writer would like to thank you for”<br>“your interest in his book. He hopes you”<br>“can get some helps from the book.”);<br>.<br>.<br>.<br>}</li>
</ol>
<p>指针数组赋值
　</p>
<p>例如:<br>main()<br>{<br>char <em>f[2];<br>int <em>a[2];<br>f[0]=”thank you”; /</em>给字符型数组指针变量赋值</em>/<br>f[1]=”Good Morning”;<br><em>a[0]=1, <em>a[1]=-11; /</em>给整型数数组指针变量赋值</em>/<br>.<br>.<br>.<br>}</p>
<p>无论是静态，局部还是全局数组只有在定义时才能初始话，否则必须通过其它方法，比如循环操作实现。</p>
<p>任何<br>int a[3];<br>static int b[3];<br>a[3] = {1, 2, 3};<br>b[3] = {1, 2, 3};<br>没有在定义时初始化都是错误的！</p>
<hr>
<p>以下是转载：<br>学了这么多年的C语言，突然发现连字符串赋值都出错，真的很伤心。</p>
<p>char a[10];<br>怎么给这个数组赋值呢？<br>1、定义的时候直接用字符串赋值<br>char a[10]=”hello”;<br>注意：不能先定义再给它赋值，如char a[10]; a[10]=”hello”;这样是错误的！<br>2、对数组中字符逐个赋值<br>char a[10]={‘h’,’e’,’l’,’l’,’o’};<br>3、利用strcpy<br>char a[10]; strcpy(a, “hello”);</p>
<p>易错情况：<br>1、char a[10]; a[10]=”hello”;//一个字符怎么能容纳一个字符串？况且a[10]也是不存在的！<br>2、char a[10]; a=”hello”;//这种情况容易出现，a虽然是指针，但是它已经指向在堆栈中分配的10个字符空间，现在这个情况a又指向数据区中的hello常量，这里的指针a出现混乱，不允许！</p>
<p>还有：不能使用关系运算符“＝＝”来比较两个字符串，只能用strcmp() 函数来处理。</p>
<p>C语言的运算符根本无法操作字符串。在C语言中把字符串当作数组来处理，因此，对字符串的限制方式和对数组的一样，特别是，它们都不能用C语言的运算符进行复制和比较操作。</p>
<p>直接尝试对字符串进行复制或比较操作会失败。例如，假定str1和str2有如下声明：</p>
<p>char str1[10], str2[10];</p>
<p>利用=运算符来把字符串复制到字符数组中是不可能的：</p>
<p>str1 = “abc”;     /<strong>* WRONG *</strong>/</p>
<p>str2 = str1;       /<strong>* WRONG *</strong>/</p>
<p>C语言把这些语句解释为一个指针与另一个指针之间的（非法的）赋值运算。但是，使用=初始化字符数组是合法的：</p>
<p>char str1[10] = “abc”;</p>
<p>这是因为在声明中，=不是赋值运算符。</p>
<p>试图使用关系运算符或判等运算符来比较字符串是合法的，但不会产生预期的结果：</p>
<p>if (str1==str2) …    /<strong>* WRONG *</strong>/<br>这条语句把str1和str2作为指针来进行比较，而不是比较两个数组的内容。因为str1和str2有不同的地址，所以表达式str1 == str2的值一定为0。</p>
<ol start="2">
<li><p>C语言 谭浩强课本讲的很清楚：</p>
<p>符号常量 与普通变量的区别：</p>
</li>
</ol>
<p>符号常量 不占用存储空间，所以就没有内地址 了哦。</p>
<p>大家都懂 C语言的基本语法，但是 很多细节问题，就只有不同深入学习才懂的。</p>
<p>c和指针还是c专家编程上讲过，const修饰的是一个只读变量，所以可以用&amp;取得一个const变量的地址。</p>
<h1 id="用指针指向字符串"><a href="#用指针指向字符串" class="headerlink" title="用指针指向字符串"></a>用指针指向字符串</h1><ol>
<li>在结构体中，不能用字符串指针来代替结构体中的变量名<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> math,english,computer;</span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Stu s;</span><br><span class="line"><span class="keyword">char</span> *p=<span class="string">"math"</span>;</span><br><span class="line"><span class="keyword">char</span> *p1=<span class="string">"english"</span>;</span><br><span class="line"><span class="keyword">char</span>* p2=<span class="string">"computer"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,s.*p);<span class="comment">//这样写法是错误的，就是这么规定的</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>字符串指针所指向的是字符串常量，复制后就不能进行更改</li>
<li>输出字符串时要用%s，用%c想输出单个字符会输出乱码</li>
<li>字符串指针是可以移动的，可以用移动的指针来指定输出的位置<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p=<span class="string">"sfjalsafs"</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,(p+<span class="number">3</span>) );<span class="comment">//从a开始输出</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>字符串，c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
