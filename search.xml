<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ssm框架</title>
    <url>/2020/06/20/ssm%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>#目录</p>
<ol>
<li>入门</li>
<li>概述</li>
<li>环境搭建</li>
<li>案例       </li>
<li>自定义mybatis框架（了解执行细节）</li>
</ol>
<p>##第二天，基本使用</p>
<ol>
<li>单表crud<br>参数和返回值<br>dao编写<br>mybatis配置的细节（标签使用）</li>
</ol>
<p>##第三天，深入和多表</p>
<ol>
<li>连接池</li>
<li>事务控制和设计的方法</li>
<li>多表查询（一对多和多对一）</li>
</ol>
<p>##第四天，缓存和注解</p>
<ol>
<li>加载时机（查询时机）</li>
<li>一级缓存和二级缓存</li>
<li>注解开发</li>
<li>单表crud，多表查询</li>
</ol>
<h1 id="三大框架-ssm"><a href="#三大框架-ssm" class="headerlink" title="三大框架(ssm)"></a>三大框架(ssm)</h1><ol>
<li>三大框架分别是表现层的springMVC和持久层的Mybatis，以及贯穿整个项目的spring<br><img src="/2020/06/20/ssm%E6%A1%86%E6%9E%B6/%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6.png" alt></li>
<li>什么是框架:就是半成品，一堆写好的组件供开发者选用。好处:封装了许多细节，使开发者可以以极简的方式实现功能，大大提高开发效率</li>
<li>三层架构:表现层(展示数据)，业务层(实现业务需求)，持久层(和数据库交互)</li>
</ol>
<h1 id="三层架构，MVC，与ssm的系统架构关系（本段是从这里转载的）"><a href="#三层架构，MVC，与ssm的系统架构关系（本段是从这里转载的）" class="headerlink" title="三层架构，MVC，与ssm的系统架构关系（本段是从这里转载的）"></a>三层架构，MVC，与ssm的系统架构关系（本段是从<a href="https://blog.csdn.net/aphysia/article/details/80038506" target="_blank" rel="noopener">这里</a>转载的）</h1><ol>
<li>三层架构<br>三层架构是指：视图层view，服务层service，持久层Dao，它们的功能是：</li>
</ol>
<ul>
<li>view层：用来接收用户请求的代码，比如请求如何分发；</li>
<li>service层：系统的业务逻辑主要写在这里，比如借书系统会有借书的业务；</li>
<li>Dao层：直接操作数据库的代码，之所以分Dao层，主要是可能相同的sql语句可能使用在比较多的地方，改动的时候可以理解为只改动一处即可。<br>为了降低耦合度，在这里，使用面向抽象编程，也就是上层对下层的调用，直接通过接口来完成，下层对上层的真正服务提供者，是下层实现的接口实现类，实现类是可以更换的，这就实现了层间的解耦合。<br><img src="/2020/06/20/ssm%E6%A1%86%E6%9E%B6/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt></li>
</ul>
<ol start="2">
<li>MVC<br>mvc就是Model模型，view视图，以及Controller控制器<br>View：视图，为用户提供使用界面，与用户进行交互。<br>Model：模型承载数据，对用户提交请求进行计算的模块，分为两类：1.数据承载bean，2.业务承载bean，数据承载bean是指实体类专门承载业务数据的，比如Student，User，业务处理bean是指Service或者Dao对象，专门处理用户的请求的。<br>Controller：控制器，用来将用户请求转发给相应的Model进行处理，并且根据Model的计算结果向用户提供相应的响应。<br>MVC工作的流程：</li>
</ol>
<ul>
<li>用户通过view页面向服务端提出请求，表单，超链接或者ajax请求。</li>
<li>服务器端Controller控制器接受到请求之后，对请求进行解析，找到相应的Model对请求进行处理。</li>
<li>Model处理之后，将处理的结果交回给Controller</li>
<li>Controller在接受到处理结果后，找到相应的View页面，页面经过数据渲染（填充数据）后，发给客户端。<br><img src="/2020/06/20/ssm%E6%A1%86%E6%9E%B6/MVC.png" alt></li>
</ul>
<ol start="3">
<li><p>MVC与三层架构的区别<br>MVC架构里面的Controller以及View层合并在一起就是三层架构的View层，而MVC的Model层就包含了三层架构的Service层以及Dao层。<br><img src="/2020/06/20/ssm%E6%A1%86%E6%9E%B6/MVC%E4%B8%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E5%8C%BA%E5%88%AB.png" alt></p>
</li>
<li><p>SSM与三层架构的联系<br>SSM，即SpringMVC，Spring与Mybatis的统称。</p>
</li>
</ol>
<ul>
<li>SpringMVC:作为view的实现者，完成客户请求的接受功能,它的controller作为整个应用的控制器，完成用户请求的转发和对用户的响应。</li>
<li>Mybatis:作为Dao的实现者，完成数据库的增删改查等功能。</li>
<li>Spring：是整个应用的大管家，整个应用中所有的bean的生命周期行为，都是由Spring来管理的，就是说整个应用中所有的对象的创建，初始化，销毁，以及对象之间关联的关系维护，都是由Spring来进行管理。<br><img src="/2020/06/20/ssm%E6%A1%86%E6%9E%B6/ssm%E4%B8%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt></li>
</ul>
<p>#Mybatis</p>
<ol>
<li>是持久层的技术</li>
<li>持久层技术方案</li>
</ol>
<ul>
<li>JDBC技术：Connection，PreparedStatement，ReslutSet</li>
<li>spring的JdbcTemplate：spring中的对JDBC的简单封装 </li>
<li>Apache的DButils：和jdbcTemplate很像，也是简单封装<br>但是以上技术都不是框架，JDBC是JAVA提供的API，是底层技术，其他只是简单的封装，更像是工具类</li>
</ul>
<ol start="3">
<li>Mybatis封装了许多细节，使开发者只需要关注sql语句本身，而无需关注注册驱动和创建连接本身，使用ORM思想实现了结果集的封装</li>
<li>ORM：Object Relational Mapping 对象关系映射 简单的说就是把数据库表和实体类及其属性对应起来，使得开发者可以操作实体类进而操作表</li>
<li>Mybatis的依赖环境<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Mybatis的主配置文件的约束头--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration  </span></span><br><span class="line"><span class="meta">  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"  </span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>##Mybatis入门</p>
<ol>
<li>JDBC程序的回顾</li>
<li>SqlConfig（Mybatis的主配置文件）的配置：给Mybatis配置数据库的相关信息和数据源，并且指定映射配置文件的位置，映射配置文件指的是每个Dao独立的配置文件<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--接着上面主配置文件的约束头继续写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--指定使用的数据库是mysql--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--配置mysql的环境--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--配置事务类型--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--配置数据源（连接池）--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!--配置连接数据库的4个基本信息--&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.JDBC.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!--其实就是驱动类的包位置--&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!--xxx是你的数据库名称--&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"admin"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--指定映射配置文件的位置，映射配置文件就是每个Dao接口的独立配置文件--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--独立配置文件必须与Dao接口的目录结构相同--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/itheima/dao/IUserDao.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--如果是注解开发，就要写class=dao接口的全限定类名--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.itheima.dao.IUserDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>创建与Dao相同结构时，会发生中间包自动合并的情况，解决方法如下图，取消勾选紧凑中间包的选项即可<br><img src="/2020/06/20/ssm%E6%A1%86%E6%9E%B6/%E7%B4%A7%E5%87%91%E4%B8%AD%E9%97%B4%E5%8C%85.png" alt></li>
<li>每个Dao的独立配置文件<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper  </span></span><br><span class="line"><span class="meta">  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  </span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--先导入mapper的约束头--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--通过namespace+id才能找到唯一的方法--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.itheima.dao.IUserDao"</span>&gt;</span><span class="comment">&lt;!--接口的全限定类名--&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--配置查询所有，id就是IUserDao中的方法名，select标签里面写sql语句,resultType是查询到的数据封装到哪个类中--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.itheima.domain.user"</span>&gt;</span></span><br><span class="line"> 		select * from user</span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>mybatis的核心就是替我们创建Dao接口的代理对象，直接调用代理对象的方法就可。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.读取主配置文件</span></span><br><span class="line">InputStream in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig,xml"</span>);</span><br><span class="line"><span class="comment">//2.创建sqlSessionFactoryBuilder对象（使用构建者模式）</span></span><br><span class="line">SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line"><span class="comment">//3.获取sqlsessionFactory对象</span></span><br><span class="line">SqlSessionFactory factory = sqlSessionFactoryBuilder.build(in);</span><br><span class="line"><span class="comment">//4.通过工厂生产sqlsession</span></span><br><span class="line">SqlSession sqlSession = factory.openSession();</span><br><span class="line"><span class="comment">//5.通过sqlsession获取代理对象</span></span><br><span class="line">IUserDao userDao = sqlSession.getMapper(IUserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//6.执行代理对象</span></span><br><span class="line">userDao.findAll();</span><br><span class="line"><span class="comment">//7.释放资源</span></span><br><span class="line">sqlSession.close();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure></li>
<li>mybatis中的设计模式</li>
</ol>
<ul>
<li>获取主配置文件的路径：有两种路径，绝对路径和相对路径，绝对路径是文件在本机上的磁盘位置如D:/ads/dsaf/dsf.xml,相对路径是相对于整个项目的路径，如src/main/resources/safd.xml，两种路径在实际开发中都不会使用，绝对路径不能保证每个用户有相同的cipan，如某些电脑没有E盘，而相对路径在项目部署之后src目录就会消失，文件也会找不到，因此常用的有两种方法，一是类加载器，但是只能获得类路径的配置文件，二是使用ServletContext对象的getRealPath获取真实路径。</li>
<li>创建工厂使用了构建者模式，把对象的创建细节隐藏，是使用者直接调用方法即可拿到对象</li>
<li>生产sqlSession对象使用工厂模式，降低类之间的耦合度，使得在想更换sqlSession对象时不必重新部署服务器。</li>
<li>创建代理对象使用代理模式，在不修改源码的基础上增强方法</li>
</ul>
<ol start="7">
<li>注解开发<br>将IUserDao.xml移除，在接口的方法上加@Select(里面写sql语句)，同时要写class=dao接口的全限定类名，<mapper class="com.itheima.dao.IUserDao"></mapper></li>
</ol>
<p>##mybatis框架分析</p>
<ol>
<li>mybatis的原理基本上就是通过建立代理对象，在代理对象中调用sqlSession的不同sql方法来实现CRUD。</li>
<li>各部分的标签作用</li>
</ol>
<ul>
<li>mybatis从官网上引入头部信息时，要将?与xml的空格删除，后面=号两边的空格也要删除</li>
<li>主配置文件中的<enviroments></enviroments>里的default作用是指定当前使用哪一个environment的数据库配置，因为mybatis可以配置多个数据库，但是每个sqlSessionFactory只能使用一个数据库配置，如果像要同时连接两个数据库就要使用两个sqlSessionFactory，id是指定使用哪个environment的配置。</li>
<li>主配置文件中<dataSource></dataSource>里面的四个信息是数据库的基本信息，有了这些就可以创建连接对象conn，这些信息是传入factoryBuilder的，也就是只要解析一次，不需要解析多次</li>
<li>主配置文件中的<mapper></mapper>中的resource配置是指定每个Dao对应的独立配置文件，这样mtbatis就可以找到配置文件</li>
<li>独立配置文件中的<namespace></namespace>是指定Dao接口的位置，<id></id>是指定要执行的方法名，<resulrType></resulrType>是指定查询结果要封装到的实体类位置，这三个标签sql语句与接口中的某个方法进行绑定，用来执行sqlSession方法，而方法就是JDBC，需要三个信息，一是数据库的连接，这个在工厂中已经拿到，二是sql语句，这个已经被绑定，三是要封装的数据类型。因为这三个信息与每个方法都是一一对应的关系，于是可以创建一个MAP集合，key是方法的路径，value是sql语句和封装类型<br><img src="/2020/06/20/ssm%E6%A1%86%E6%9E%B6/mapper%E9%9B%86%E5%90%88.png" alt></li>
<li><property></property>标签可以将主配置文件下的所有property（主要是数据库4个连接信息，方便快速切换数据库），并且可以引入外部文件，通过resource属性指定路径，但是配置文件必须存在于类路径下，写法也是按类路径来写<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"admin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--或者这么写,jdbcConfig就放在resource里面就是类路径下--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">resource</span>=<span class="string">"jdbcConfig.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--properties文件中=后面的数据不要加引号，加了就会拿到带引号的数据，就不能连接数据库--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在数据库中的引用就是$&#123;属性名称&#125;，和ognl一样如果前面有jdbc.driver要把jdbc也写全--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;usename&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><typeAliases></typeAliases>是配置别名的，但只能配置domain中的类的别名其中type属性指定全限定类名，alias是起的别名，别名使用时是不区分大小写的，<package name></package>是指定要配置别名的包，并且类名就是别名，不区分大小写。<mapper></mapper>中的<package></package>是指定接口所在的包当指定了之后就不在需要写mapper和resource和class了。</li>
</ul>
<ol start="3">
<li>代理对象的创建分析<br>代理对象的实现是通过Proxy.newProxyInstance()方法实现的，该方法有三个参数，第一个是被代理对象的类加载器，第二个是被代理对象所要实现的接口的字节码数组，第三个是自己编写的增强方法，在mybatis中，此处需要实现一个InvocationHandler的接口，在实现类中调用SqlSession中的方法</li>
<li>注解方法的分析，使用注解时要将主配置文件中的<mapper></mapper>中的resource变成class，就是dao的全限定类名，这样的目的就是就是代替消失的dao独立配置中的namespace属性，用来组成Map的key，此外mybatis还需要两个属性，封装类型和sql语句，注解就写在方法之上，很容易就能拿到封装类型，sql语句就在注解之中。</li>
<li>基于xml的自定义mybatis的流程图<br><img src="/2020/06/20/ssm%E6%A1%86%E6%9E%B6/%E8%87%AA%E5%AE%9A%E4%B9%89maybatis%E6%A1%86%E6%9E%B6.png" alt></li>
</ol>
<p>##使用mybatis实现CRUD</p>
<ol>
<li><p>使用不同的功能需要不同的标签，增加时<insert></insert>,查询是<select></select>,更新是<updaet></updaet>,删除是<delete></delete></p>
</li>
<li><p>当方法中有参数时，需要在标签中增加属性parameterType=”参数的全限定类名”，拿到参数中的数据使用#{}，里面一定是写上get方法中get之后的属性名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"saveUser"</span> <span class="attr">paramterType</span>=<span class="string">"com.itheima.domain.user"</span>&gt;</span></span><br><span class="line">    insert into user(name,sex,age) values(#&#123;username&#125;,#&#123;sex&#125;,#&#123;age&#125;)    </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>模糊查询时，如果sql语句中参数没有%%号，那么在指向方法时就需要将%%传进去</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">这种是使用了preparedStatement预处理，参数使用占位符，优势大，开发常用</span><br><span class="line">userDao.query("%王%")</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="keyword">like</span> <span class="comment">#&#123;username&#125;</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="keyword">like</span> ?</span><br><span class="line"></span><br><span class="line">这种是使用了<span class="keyword">Statement</span>，直接使用字符串拼接，不推荐</span><br><span class="line">userDao.query(<span class="string">"王"</span>)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">'%$&#123;value&#125;%'</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">'%王%'</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取新增用户的id返回值<br>要在<insert></insert>标签中增加<selectkey>标签，其中属性有KeyPeoperty，代表要返回的值的名称 oeder取值为AFTER代表插入之后的行为，KeyColum代表数据库中的列名，resultType是返回类型，中间加上语句select last_insert_id();<br>这个语句返回的值还是封装在插入或者修改的User中，不会单独返回int，如果用单独返回的int接受那是数据库返回的结果数。</selectkey></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"saveUser"</span> <span class="attr">paramterType</span>=<span class="string">"com.itheima.domain.user"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">KeyProperty</span>=<span class="string">"id"</span> <span class="attr">KeyColum</span>=<span class="string">"id"</span> <span class="attr">oeder</span>=<span class="string">"AFTER"</span> <span class="attr">resultType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        slect last_insert_id();</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into user(name,sex,age) values(#&#123;username&#125;,#&#123;sex&#125;,#&#123;age&#125;)    </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用实体类的包装对象作为参数查询<br>就是一个类中包含另一个类</p>
</li>
</ol>
<ul>
<li>pojo(plain ordinary java objects),定义暂时搞不清，先理解为简单的实体类，只有属性和一些setget方法的类。</li>
<li>ognl(Object Graphic Navigation Language) 他是通过对象的取值方法来获得值，在写法上将get省略了，<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">user.getName();<span class="comment">//类中的写法</span></span><br><span class="line">user.username;<span class="comment">//ognl表达式</span></span><br></pre></td></tr></table></figure>
标签中sql语句中的数据就是用ognl拿到的，但是因为类名已经写了，因此就只要写属性名就可以而不需要写类名。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"saveUser"</span> <span class="attr">paramterType</span>=<span class="string">"com.itheima.domain.queryVo"</span>&gt;</span></span><br><span class="line">        这时参数获取就要写成#&#123;user.name&#125;才能拿到数据，因为如果只写#&#123;name&#125;，mybatis会去queryVo中寻找name属性，但是不会找到的，就需要加上类名</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="6">
<li>封装数据的时候要求实体类中的属性名要和数据库中的列名完全一样，否则就会在封装的时候报错，但是如果不一样的也有两种解决方法</li>
</ol>
<ul>
<li>修改sql语句，起别名,这种方式最好，因为是在sql语句的层面上进行修改的<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">as</span> userId, username <span class="keyword">as</span> userName, sex <span class="keyword">as</span> userSex <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li>
<li>sql语句不动，配置查询结果的列名和实体类属性名一一对应,并且在使用中将resultType换成resulMap，值就是resultMap的id<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userMap"</span> <span class="attr">type</span>=<span class="string">"com.itheima.domain.user"</span>&gt;</span><span class="comment">&lt;!--type封装到哪里--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--主键字段的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">proprety</span>=<span class="string">"userId"</span> <span class="attr">colum</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--非主键字段的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">colum</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="7">
<li>查询所有的封装类型仍然是User，不需要写其他，mybatis自动转为集合。</li>
</ol>
<p>##mybaits的连接池以及事务控制</p>
<ol>
<li>连接池：连接池就是一个存放和数据库之间的连接的集合对象，使用连接池可以减少于数据库之间的交互，提高效率，并且该容器必须线程安全和实现队列的特性，先进先出。</li>
<li>mybatis的连接池有三种配置，在主配置文件中的<datasource type></datasource>，有三种取值，POOLED，UNPOOLED，JNDI，</li>
</ol>
<ul>
<li>POOLED：采用传统的javax.sql.DataSource规范中的连接池，mabatis有对应的实现</li>
<li>UNPOOLED:采用传统的JDBC获取连接的方法，虽然也实现javax.sql.DataSource接口，但是并没有池的思想</li>
<li>JNDI：服务器提供的技术，不同服务器能拿到的datasource对象是不一样的，并且不是web或者maven的工程是不能使用的，在本例中，使用的是tomcat服务器，那么连接池就是dbcp连接池。</li>
</ul>
<ol start="3">
<li>事务提交和回滚，在SqlSessionFactory.openSession(true),就可以开启自动提交，但是这种只使用于单表的操作，当涉及到多个连接时，就要开启手动提交，例如银行转账案例。 </li>
</ol>
<p>##基于xml的动态sql</p>
<ol>
<li><if></if>，使用于查询条件可能有姓名，住址，电话等一个或多个信息的情况，利用sql语句的字符串拼接产生最终的查询语句，这时就要加上where 1=1,来保证sql语句的必定执行，另外，如果判断两个条件的话，需要使用and而不是&amp;&amp;，and是sql中的关键字，&amp;&amp;是java中的用法，if语句如果里面的对象为空的话，sql会继续执行但是不带上if标签内的语句。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.itheima.domain.User"</span> <span class="attr">paramterType</span>=<span class="string">"com.itheima.domain.User"</span>&gt;</span></span><br><span class="line">        select * from user where 1=1</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username!=null"</span>&gt;</span></span><br><span class="line">           and username=#&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><where></where>,if标签一个写and比较烦，就可以使用where标签来，这样就不用写1=1的操作了，mybatis可以根据条件自动删除and,如果内部的if所有标签都为空，就会量where都删除，变成select * from user 查询所有了，哪个if标签为空内部就会删除。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.itheima.domain.User"</span> <span class="attr">paramterType</span>=<span class="string">"com.itheima.domain.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username!=null"</span>&gt;</span></span><br><span class="line">            and username=#&#123;username&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"sex!=null"</span>&gt;</span></span><br><span class="line">            and sex=#&#123;sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><foreach></foreach>,用来执行sql的select * from user in (56,5,6,5)<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.itheima.domain.User"</span> <span class="attr">paramterType</span>=<span class="string">"com.itheima.domain.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ids!=null and list.size&gt;0"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">open</span>=<span class="string">"and in ("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">                    #&#123;id&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span>          </span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--这里的ids是传入参数User中的id集合，如果叫其他名字就写其他名字，collection是集合元素，不要加#&#123;&#125;，open代表语句的开始部分，close代表结束部分，item是集合中每个元素的变量名，separator是元素间的分割符，并且$&#123;id&#125;是和item的值是一样的--&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><sql></sql>，抽取重复的代码，在写重复代码时，不要在后面加上；后面还要拼接语句容易出错<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.itheima.domain.User"</span> <span class="attr">paramterType</span>=<span class="string">"com.itheima.domain.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"defaultUser"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ids!=null and list.size&gt;0"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">open</span>=<span class="string">"and in ("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">                    #&#123;id&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span>          </span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"defaultUser"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>##mybayis的多表</p>
<ol>
<li><p>一对一的查询：目标查询所有账户并且带有用户的姓名和地址，思路：查询所有的账户，带有用户的部分信息，也就是要建立一个新的实体类来封装数据，这个实体类可以继承account，并且加上username和address，并且为其配置xml，但是这种方法开发中并不常用，而是使用建立实体类关系得方式</p>
</li>
<li><p>一对一的实体类关系，从表实体类因该包含对主表实体类的引用，在这个案例中就是account中定义一个User对象，因此在配置文件中就要定义resultMap来映射数据</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--查询两个表的所有信息--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--首先在account对象中引用user对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"accountUserMap"</span> <span class="attr">type</span>=<span class="string">"com.itheima.domain.account"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">colum</span>=<span class="string">"aid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span><span class="comment">&lt;!--property是实体类中属性名称，column是数据库表的列名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以上只是封装了account表的数据，还差user的数据没有封装，这时就要建立一对一的封装关系，配置封装user的内容--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--javaType是指定数据封装到哪个实体类中，因为user并不是在account里面定义的内部类，而是引用的外部类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">column</span>=<span class="string">"uid"</span> <span class="attr">javaType</span>=<span class="string">"com.itheima.domain.user"</span>&gt;</span><span class="comment">&lt;!--指定主键（暂时先这么理解，以后再说）--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">colum</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"bithday"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--sql语句</span></span><br><span class="line"><span class="comment">select u.*, a.id as aid,a.money,a.uid from account a, user u where a.uid = u.id</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一对多查询，需求是查询用户并且查询用户的所有账户，一个用户可以有多个账户，因此是个一对多问题</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--首先在主表中应该定义从表的集合，就是在user中定义list&lt;account&gt; accounts，在上一个多案例中的user引用要删除，因为从数据库中拿到时，并没有封装user的信息，两个都是null--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userAccountMap"</span> <span class="attr">type</span>=<span class="string">"com.itheima.domain.user"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">colum</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"bithday"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置user对象中的accounts的集合配置，这次标签用collection--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"accounts"</span> <span class="attr">oftype</span>=<span class="string">"com.itheima.domain.account"</span>&gt;</span><span class="comment">&lt;!--property是user中集合的名字，ofType是每个元素的类型--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">colum</span>=<span class="string">"aid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span><span class="comment">&lt;!--property是实体类中属性名称，column是数据库表的列名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--sql语句</span></span><br><span class="line"><span class="comment">这次是查询所有用户，有的用户没有账户，就要用到外连接</span></span><br><span class="line"><span class="comment">select * from user u left join account a on u.id = a.uid</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多对多的查询，需求是查询除所有用户的所有角色</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--前期准备</span></span><br><span class="line"><span class="comment">实现多对多，根据之前的经验，要在两个对象的内部都定义一个对方的集合</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--role的map--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"roleMap"</span> <span class="attr">type</span>=<span class="string">"com.itheima.domain.role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"roleId"</span> <span class="attr">column</span>=<span class="string">"rid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleName"</span> <span class="attr">column</span>=<span class="string">"role_name"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleDesc"</span> <span class="attr">column</span>=<span class="string">"role_desc"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"users"</span> <span class="attr">ofType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"age"</span> <span class="attr">column</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--用户表也这么处理就可以了 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--sql语句比较难写，写多对多查询要用两次外连接，第一次将中间表与user表外连接，在把角色表和中间表外连接</span></span><br><span class="line"><span class="comment">select u.*,r.id as rid,r.role_name,r.role_desc from role r left join role_user ur on r.id = ur.rid left join user u on u.id = ur.uid</span></span><br><span class="line"><span class="comment">这时当查询角色时获取所有用户信息</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>##连接池的JNDI（仅了解）</p>
<ol>
<li>JNDI:java naming and directory interface，是sun公司推出的一套规范，目的是模仿windows的注册表在服务器中注册数据源</li>
<li>JNDI只能在war和web工程下使用</li>
</ol>
<p>##mybatis的缓存</p>
<ol>
<li>延迟加载和立即加载：例子，一个用户有100个账户，但是查询用户不一定要把100个账户都查出来，不然对内存压力大，应该是需要的时候在查出来，而查询账户时必须要将用户同时查询出来，是立即的。因此，延迟加载就是在真正使用数据时才会去查询，不用的时候就不查询，即时加载只要一调用方法就会查询。在四种表关系中对应的关系：多对一和一对一使用立即加载，一对多和多对多使用延迟加载。</li>
<li>一对一和一对多查询都是要将sql语句改造，原本是两张表一起查，现在改为查询一张表，并且在<collection></collection>中增加select属性，里面写的就是查询另一张表的方法的全限定类名，原理就是在调用方法时会去另一个对象中去寻找对应的查询方法。并且延迟加载开关也要打开.<br>这两个开关都要在主配置文件中配置，使用<settings></settings><br>lazyLoadingEnabled  延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。   true | false    false<br>aggressiveLazyLoading   开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载（参考 lazyLoadTriggerMethods)。   true | false    false （在 3.4.1 及之前的版本中默认为 true）</li>
<li>缓存：存在于内存中的临时信息，查询不经常变的数据可以从内存中查询，效率提高。使用的数据是，经常查询并且不经常改变的且数据的正确与否对最终结果影响不大的。</li>
<li>一级缓存：指的是SqlSession的缓存，执行查询之后，查询的结果会同时存入到sqlSession中，该区域结构是Map，当sqlSession消失时，一级缓存消失，触发清空一级缓存的情况：当调用sqlSession的修改添加删除，commit，close等方法时就会清空一级缓存。 </li>
<li>二级缓存：指的时sqlSessionFactory中的缓存，由同一个sqlSessionFactory对象创建的sqlSession共享其缓存。使用步骤：让mybatis支持二级缓存，第二步让当前的配置文件支持二级缓存（在配置文件中写<cache>，并且在select中添加属性useCache），第三步，让当前的操作支持二级缓存（在select标签中配置）。二级缓存中存储的散装数据而不是对像，当有重复查询时，就会把散装数据填充到新对象中。</cache></li>
</ol>
<p>##mybatis的注解开发</p>
<ol>
<li>注解配置的是dao的配置文件，而不是主配置文件</li>
<li>如果一个Dao已经有了对应的xml配置文件，这时不管用不用注解都会报错，解决方法就是删除xml文件或者放到其他路径下</li>
<li>mybatis注解建立实体类属性和数据库表中列的对应关系。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@results</span>(id =<span class="string">"userMap"</span>value=&#123;</span><br><span class="line">    <span class="meta">@result</span>(id=<span class="keyword">true</span>,column=<span class="string">"id"</span>,property=<span class="string">"userId"</span>)<span class="comment">//如果这行配置的时id就是true</span></span><br><span class="line">    <span class="meta">@result</span>(column=<span class="string">"username"</span>,property=<span class="string">"username"</span>)</span><br><span class="line">    <span class="meta">@result</span>(column=<span class="string">"sex"</span>,property=<span class="string">"sex"</span>)</span><br><span class="line">    <span class="meta">@result</span>(column=<span class="string">"birthday"</span>,property=<span class="string">"birthday"</span>)</span><br><span class="line">    <span class="meta">@result</span>(column=<span class="string">"address"</span>,property=<span class="string">"address"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样其他注解就能引用了</span></span><br><span class="line"><span class="meta">@resultMap</span>(value=&#123;<span class="string">"userMap"</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li>一对一查询，实质仍然是调用查询另一张表的方法去查询<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@results</span>(id=<span class="string">"hfads"</span> value=&#123;</span><br><span class="line">    <span class="meta">@result</span>(id=<span class="keyword">true</span>,property=<span class="string">"af"</span>,column=<span class="string">"dsaf"</span>),</span><br><span class="line">    <span class="meta">@result</span>(property=<span class="string">"sex"</span>,column=<span class="string">"dfas"</span>),</span><br><span class="line">    <span class="comment">//一对一查询需要使用@one注解，并且在其中配置select属性和fetch属性,one指的是通过userDao中的findById找用户，column=uid，是findById的参数。</span></span><br><span class="line">    <span class="meta">@result</span>(property=<span class="string">"user"</span>,column=<span class="string">"uid"</span>,javaType=user<span class="class">.<span class="keyword">class</span>,<span class="title">one</span></span>=<span class="meta">@one</span>(select=<span class="string">"cuit.cs.dao.IUserDao.findById"</span>,fetchType=<span class="string">"FetchType.EAGER"</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>多对多查询<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//和上面一样，只不过把one改为many，fetchType改为lazy，并且sql语句也要改变，变成先从中间表中查出数据组成集合，在从集合中查找相应的数据，并且javaType也要写成java.utis.List.class，因为是集合类型的数据</span></span><br><span class="line"><span class="comment">//注解查询的好处就在于它是调用已有的方法去查询，sql语句不会非常复杂，而xml配置是只查询一次，但是是把几个表的数据全部查询出来，需要人一个个的对应封装，非常麻烦，并且sql语句还要写左外连接查询，非常麻烦</span></span><br><span class="line">``` </span><br><span class="line"><span class="number">6</span>. 注解开启二级缓存</span><br><span class="line">```java</span><br><span class="line"><span class="comment">//首先在主配置文件中开启&lt;settings&gt;&lt;setting name="cacheEnabled" value="true"&gt;&lt;/setting&gt; &lt;/settings&gt;</span></span><br><span class="line"><span class="comment">//然后在dao接口最上写@CacheNamespace(bloking = true)，这样就开启二级缓存了</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>##mybatis踩雷</p>
<ol>
<li><p>别名：typeAlis配置的别名是实体类的别名，一般是作为封装类型和参数类型使用，但是mapper里的package是指定接口包的位置的，其作用以我现在的理解暂时应该是，如果使用的是xml配置，那么package的路径就是指定resource路径下的xml文件的包，就能找到xml（前提是resource下必须有和dao接口一样的的包结构，不然就会找不到，这就是下面的原理，xml文件移动路径，就找不到了，就会去使用注解）。如果使用的是注解，那么package指定的就是java包下的接口类，就能扫描这个包找到注解。</p>
</li>
<li><p>使用注解配置时，就必须把xml文件删除或者移到另外的路径下</p>
</li>
<li><p>xml配置文件必须和dao接口的名字相同</p>
</li>
<li><p>namespace必须写dao的全限定类名。</p>
</li>
<li><p>解决报错invalid statement，看<a href="https://www.cnblogs.com/itzyz/p/10954427.html" target="_blank" rel="noopener">这里</a></p>
</li>
<li><p>使用删除或者更新时，在调用完代理对象的方法之后就要SqlSession.commit（）开启手动提交，不然无法修改或者删除。我之所以无法修改数据库信息的原因是调用的sqlsession.close()方法，这个方法会自动回滚在关闭，而我没有开启手动提交，数据自动回滚，自然无法修改，在close方法前调用commit方法就可以解决。</p>
</li>
<li><p>mybatis操作数据库时会出现中文无法操作的问题，比如模糊查询是查不到数据的并且更新或者插入数据有中文都无法插入，解决方法是修改数据库的编码集是utf-8，并且在数据库配置文件中的url后加上?useUnicode=true&amp;characterEncoding=UTF-8，就可以操作中文数据了。</p>
</li>
</ol>
<p>#spring</p>
<ol>
<li>spring的体系结构<br><img src="/2020/06/20/ssm%E6%A1%86%E6%9E%B6/spring.jpg" alt></li>
<li>导入依赖<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="程序间的耦合"><a href="#程序间的耦合" class="headerlink" title="程序间的耦合"></a>程序间的耦合</h2><ol>
<li>概念：简单理解为程序间的依赖关系，包括类之间的依赖关系和方法之间的依赖关系</li>
<li>解耦就是降低程序间的依赖关系，耦合不可能完全消除，实际开发中应该实现编译器不依赖，执行时才依赖</li>
<li>解耦的思路：创建时使用反射而不是new一个新的对象（反射就是只写类的名字，由Java去寻找具体的类，而不用去指定一个具体的jar包），并且通过配置文件读取类的全限定类名。</li>
</ol>
<p>##工厂模式</p>
<ol>
<li>工厂模式就是为了降低程序间的耦合度</li>
<li>其作用是创建Bean对象，在计算机英语中，Bean指可重用组件，即可以被其他程序或类多次调用的组件，在web中主要是指service和dao，</li>
<li>JavaBean不仅仅是实体类对象，其范围远远大于实体类</li>
<li>工厂工作的原理：在配置文件中配置service和dao，即id=类的全限定类名，工厂通过读取配置文件找到对应的service和dao，并进行创建</li>
<li>工厂模式中的问题：多次调用工厂的话每次都会创建一个新的对象返回，即对象是多利的，这样可以避免线程的安全问题（即方法可以改变成员变量的值，这样的话，单例每次调用都会改变成员变量的值，解决方法是尽量不定义成员变量，在方法内部定义变量，sevlet就是如此），但是创建单例对象的话如果长时间不使用对象就会由java垃圾回收机制自动回收，无法控制，因此在对象创建之后就必须将其存入容器之中，这就是Spring的核心容器，就是个Map集合</li>
</ol>
<p>##IOC(inversion of control)</p>
<ol>
<li>将创建对象的权力交给工厂，app想要一个资源必须通过工厂，工厂在产生相应的资源返回</li>
<li>核心容器的两个接口：applicationContext和BeanFactory，其中applicationContext的三个实现类，ClassPathXmlApplicationContext 加载类路径下的配置文件，FileSystemXmlApplicationContext 加载磁盘路径下的配置文件，AnnotationConfigApplicationContext 加载注解。<br>applicationContext在构建核心容器时，采取的策略时即时加载，即一读取完配置文件就会创建对象。而BeanFactory创建对象的策略是延迟加载，就是说，什么时候根据id获取对象，什么时候才能真正的创建对象。正因如此，applicationContext适合单例对象，BeanFactory适合多例对象。实际开发中更多的使用applicationContext接口，因为他是BeanFactory的子接口，有更丰富的方法。并且applicationContext很智能，能够根据配置文件中的配置，自己选择延时还是即时加载。</li>
</ol>
<p>##xml配置</p>
<ol>
<li>创建Bean的三种方式</li>
</ol>
<ul>
<li>注入普通对象，只要调用默认构造函数就能创建，如果没有默认构造函数，就无法创建<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>使用jar包中的或者其他已经编写好的类对象(使用普通工厂中的方法创建对象并存入spring容器)，这时是无法通过修改源码保证其拥有默认构造函数 通过factory-bean找到工厂类，在通过factory-method找到对应方法，调用该方法创建对象<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instanceFactory"</span> <span class="attr">class</span>=<span class="string">"com.itheima.factory.InstanceFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">factory-bean</span>=<span class="string">"instanceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAccountService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>使用工厂的静态方法创建<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.factory.staticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAccountService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>Bean的作用范围<br>调整Bean的作用范围<br> Bean的scope:常用前面两个</p>
<pre><code>singleton:单例的（默认值）
prototype：多例的
request:作用域web应用的请求范围
session:web的会话范围
global-session:作用于集群环境的会话范围（全局会话范围），不是集群环境时，就是session，就是有多台服务器时，想其中一个服务器请求时的数据
可能会由于访问人数的变动导致当前服务器不可用，得切换服务器，这时原来服务器上的请求信息比如验证码肯定在新的服务器上是没有的，因此就得把所有服务器都看作一个session，数据所有服务器通用</code></pre></li>
<li><p>Bean的生命周期<br>Bean对象的生命周期，单例：由于只创建一次，创立就存入容器，因此容器存在，单例对象就存在，容器销毁，单例对象就销毁<br>多例对象：只有调用方法的时候才会创建，死亡不是由spring控制的，而是由java的垃圾回收机制自动回收</p>
</li>
<li><p>依赖注入（dependencies injetion）<br>一定要分清依赖和创建Bean的关系，创建Bean的三种方式指的是获取一个Bean的方式，而依赖注入是解决Bean中对其他类的引用，一个Bean中可能拥有依赖注入。<br>依赖注入：dependence injection<br> 以后的依赖关系就交给spring来维护，依赖关系就是在类中需要用到哪些其他类，都由spring为我们提供，我们只需在spring配置文件中配置即可<br> 依赖注入能注入的类型由三类：</p>
<pre><code>基本类型和string 
其他Bean类型（在配置文件中配置过或者注解过）
复杂类型（集合和Map）</code></pre></li>
</ol>
<p>注入的方式：有三种<br>第一种：使用构造函数<br> 使用的标签：constructor-arg<br>        使用位置在bean的内部<br>        标签的属性<br>            type:指定要注入的数据类型，也是构造函数参数中的某个数据类型<br>            name:指定要注入的参数名称（开发常用）<br>            index:指定要注入的参数索引（从0开始）<br>            以上是寻找注入参数，以下就是赋值</p>
<hr>
<pre><code>value:用于提供String和基本数据类型
ref:用于指定其他类型的Bean类型数据。它指的就是在Ioc核心容器中出现过的Bean对象

构造函数注入的优势在于在创建Bean对象时注入数据是必须操作，否则不能创建对象
劣势在于改变了Bean的实例化方式，如果用不到这些方式也必须提供</code></pre><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"憨憨"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"52"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"now"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"now"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二种：使用set函数<br> 涉及的标签：property<br>        出现的位置：Bean内部<br>        name:指定要注入的参数名称（开发常用）<br>        value:用于提供String和基本数据类型<br>        ref:用于指定其他类型的Bean类型数据。它指的就是在Ioc核心容器中出现过的Bean对象</p>
<pre><code>优势：创建对象时没有明确的限制，可以直接使用默认构造函数
劣势：如果某个成员必须有值，则获取对象时有可能set方法没有执行
开发中常用set注入</code></pre><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"12"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"asd"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"now"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"now"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>复杂数据类型的注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    复杂数据类型注入</span></span><br><span class="line"><span class="comment">    用于给list类型结构注入的标签</span></span><br><span class="line"><span class="comment">    list，array，set</span></span><br><span class="line"><span class="comment">    用于给map类型注入的标签</span></span><br><span class="line"><span class="comment">    map，properties</span></span><br><span class="line"><span class="comment">    结构相同，标签可以互相换的</span></span><br><span class="line"><span class="comment">    因此只需记住两者list和map即可</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService2"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mystrs"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>fads<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>fads<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>fads<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"asfd"</span> <span class="attr">value</span>=<span class="string">"dsaf"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>##基于注解的IOC</p>
<ol>
<li><p>使用注解需要的配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--当使用注解配置时，需要使用xmlns：context约束，告诉spring在创建容器时需要扫描的包，配置所需的表签不是在beans的约束中，而是yige</span></span><br><span class="line"><span class="comment">称为context名称空间和约束中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.itheima"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建对象的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建对象的</span><br><span class="line">    和在xml中写bean标签一样</span><br><span class="line">    <span class="meta">@Component</span>：用于把当前对象写入spring容器中</span><br><span class="line">    属性：value（就是xml中的id），当不写时，默认为类名，且首字母改小写</span><br><span class="line">    下面三个注解与Component的注解是作用相同的，是为了和三层架构匹配的</span><br><span class="line">    Controller：一般用在表现层</span><br><span class="line">    Service：业务层</span><br><span class="line">    Repository：持久层</span><br></pre></td></tr></table></figure></li>
<li><p>注入依赖的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在bean标签中写property标签作用一样</span><br><span class="line">    <span class="meta">@Autowired</span>:自动按类型注入，是依赖注入而不是创建Bean对象</span><br><span class="line">        首先根据数据类型（比如AccountService就是数据类型），在spring寻找与之匹配的对象，如果有就创建对象，如果不止一个，就在根据</span><br><span class="line">        对象名称寻找与之符合的key，如果两个都没，就会报错</span><br><span class="line">        出现的位置：可以是变量上，也可以是方法上，并且在使用注解注入时，set方法就不是必须的了。</span><br><span class="line">        自动按类型注入的前提是容器中必须至少有一个类型和哟要注入的类型是匹配的，这就像用set注入时的引用ref一样，容器中必须有一个这样的Bean类型才能注入。</span><br><span class="line">    <span class="meta">@Qulifier</span>:在按照类型注入的基础上按照名称注入，它在给类成员注入时不能单独使用，但是在给方法参数注入时可以</span><br><span class="line">    属性：（value）用于指定指定Bean的id</span><br><span class="line">    但是在给类成员注入时必须和autowired一起使用</span><br><span class="line">    这样可以把变量命名成任意的名字，不再受Autowired的影响</span><br><span class="line">    <span class="meta">@Resource</span>：直接按照Bean的id输入，可以独立使用</span><br><span class="line">    属性：name</span><br><span class="line">    以上三个注入都只能实现Bean类型的注入，基本类型和String无法使用上述注解实现</span><br><span class="line">    另外，集合类型的数据注入只能通过XML实现</span><br><span class="line">    <span class="meta">@Value</span>：注入基本数据类型和String</span><br><span class="line">    属性：value：用于指定数据的值，并且可以使用spring中的spel（即el表达式），写法：$&#123;表达式&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>改变作用范围的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用于改变作用范围的</span><br><span class="line">    scope</span><br><span class="line">    属性：singleton和prototype</span><br></pre></td></tr></table></figure>
</li>
<li><p>生命周期的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">于生命周期相关的</span><br><span class="line">    init-method 和destroy-method一样</span><br><span class="line"> PreDestroy：指定销毁方法</span><br><span class="line"> PostConstruct：指定初始化</span><br><span class="line"> 其用法说在bean对象的方法上添加注解，并且如果对象是多例的，是不能指向销毁方法的，因为多例对象的销毁是由Java的垃圾回收机制处理的，改成单例对象就可以执行，而默认的就是多例对象，因此想要销毁方法执行就要加上singleton</span><br><span class="line"></span><br><span class="line"> 向要销毁方法执行，首先需要改变applicationContext的类型，因为销毁方法是ClassPathXmlApplicationContext的特有方法，作为父类的applicaitonContext是没有close方法的，因此销毁方法并不会执行，</span><br><span class="line"></span><br><span class="line"> ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        IAccountService service = (IAccountService)context.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">        service.saveAccount();</span><br><span class="line">        context.close();<span class="comment">//一定要调用close方法才能执行销毁方法</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>###完全不需要xml的注解</p>
<ol>
<li>由于需要指定注解扫描的包，因此xml不可能完全消除，并且queryRunner是jar包，不能再上面写注解，也就不可能将其注入核心容器。<br>解决方法是创建一个配置类，这个配置类就相当于bean.xml的作用，在配置类之前要写上@Configuration注解<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">  指定当前类是一个配置类</span><br><span class="line"> 细节：当对象作为AnnotationConfigurationApplicationContext的参数时，可以不适用此注解，并且参数之间是兄弟关系，不是</span><br><span class="line"> 需求的父子配置类关系，当参数不写时，就必须在ComponentScan加上要扫描的包</span><br></pre></td></tr></table></figure></li>
<li>componmentScan注解，指明要扫描的包<figure class="highlight"><table><tr><td class="code"><pre><span class="line">ComponentScan</span><br><span class="line"> 指定spring在创建容器时要扫描的包</span><br><span class="line"> 属性：value 和xmlbasePackage作用一样，都是用于指定创建容器时要扫描的包，使用此注解就等于在xml中配置：</span><br><span class="line"> &lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure></li>
<li>@Bean，当有jar包中的对象需要使用时，在configuration类中定义方法，return值就是new 一个目标对象（使用默认构造函数注入，和xml一样，在使用@@Bean存入容器，那么就和xml作用一样），如果方法中有参数，那么就创建一个新方法，return参数对象。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>:作用把当前方法的返回值作为Bean对象存入spring的ioc容器中</span><br><span class="line"> * 属性：name：用于指定bean的id</span><br><span class="line"> * 细节：当我们使用注解配置时，如果方法有参数，spring框架会去容器中寻找有无可用的bean对象</span><br><span class="line"> * 查找的方式和Autowired一样。</span><br></pre></td></tr></table></figure></li>
<li>删除bean.xml后会发现测试类中都是读取的配置文件，现在没有配置文件，构建不了工厂，但是applicationContext有三个实现类，注解的实现类叫annotationConfigApplicationContext（配置类的字节码）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> AnnotationConfigurationApplicationContext(configuration<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure></li>
<li>小细节:</li>
</ol>
<ul>
<li>用注解配置出来的queryRunner是单例对象，但是我们所需求的是多例（为了线程之间不相互干扰），就得在前面加上@scope(“protoType”)</li>
<li>当配置类作为annotation的参数时，可以不写@Configuration，但是如果在参数中没有写，就需要加上@configRation，并且配置@ComponentScan，使其扫描配置类。如果两个都不想用，就需要用到@Import，就可以将其他配置类引进，但是两个类的关系就变成了父子关系。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@import</span>(jdbcConfig<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="6">
<li><p>将数据库连接信息抽取到配置文件中：在配置类中定义String类型的变量，使用@Value将其注入ioc容器中，获取配置文件的方法和myBatis的是一样的都是使用el表达式（@value{${jdbc.driver}}），还需要在配置文件上指定配置文件的路径，使用的是类路径，@PropertySource(classpath:jdbc.properties).</p>
</li>
<li><p>当在配置类中注入依赖时，可能会有多个对象，这时要从ioc容器中取出Bean对象，就需要变量名和Bean的名字一样，这就是在xml配置中也遇到的问题，对此的解决办法就是用@autowired和@qualifer共同注入，但是在方法中不需要@Autowired，只需要@qualifer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(value = <span class="string">"query"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Query <span class="title">createQuery</span><span class="params">(Date date)</span></span>&#123;<span class="comment">//这种写法就相当于@Autowired，自动按类型注入，但现在容器中有两个相同类型的，并且变量的名字是date，和容器中的两个名字都不相同，这时就可以使用@qualifier</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Query();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Query <span class="title">createQuery</span><span class="params">(@qualifier(value=<span class="string">"date1"</span>)</span>Date date)</span>&#123;<span class="comment">//这样就能取出date1Bean</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Query();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span>(value = <span class="string">"date1"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Date <span class="title">createDate</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Date();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Bean</span>(value = <span class="string">"date2"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Date <span class="title">createDate2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Date();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实际开发中，一般是自己写的类使用注解，jar包中的使用xml配置</p>
</li>
<li><p>spring整合junit:解决重复代码,问题分析：程序执行的入口是main方法，junit中集成了一个main方法，但是并不会知道我们是否使用了spring，因此并不会创建ioc容器，因此即使使用@Autowired注入，没有容器也无法注入。解决方法就是我们要使用注解告诉junit使用了spring。</p>
</li>
</ol>
<ul>
<li>导入spring整合junit的jar包<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>使用junit提供的注解替换为spring提供的（@RunWith），在测试类上面写，value是固定值。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Runwith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure></li>
<li>告知spring的runner，使用的是注解还是xml，在@Runwith下面写<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(<span class="class"><span class="keyword">class</span> </span>= SpringConfig<span class="class">.<span class="keyword">class</span>)//前面的<span class="title">class</span>或者<span class="title">Location</span>一定要写   </span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">location</span> </span>= <span class="string">"classpath:bean.xml"</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="10">
<li>小细节：当使用spring5.x以上版本整合junit时，要求junit的版本在4.12及以上。</li>
</ol>
<p>##spring的事务控制</p>
<ol>
<li>事务控制是指几个操作只有同时成功才能更该数据库中的内容，否则就会回滚到之前的状态，单个连接的事务一般是开启自动提交，但是开发中不可能只有一个连接，因此需要手动提交事务来确定事务的具体范围</li>
<li>银行转账的案例的问题：A给B转钱的时候成功了，但是A扣钱的时候失败了，因此造成数据的错误，这并不是因为没有事务，没有事务提交，那么转账就不可能成功。</li>
<li>问题产生的原因分析：因为每个事务控制都只能针对同一个connection（通过conn.commit()和conn.close（）来控制），如果有多个connection，是没有一个更高一级的事务来控制不同的Connection的。解决方法就是通过ThreadLocal给每一个线程分配一个conn（该临时变量与其他线程是隔离的），这样就能保证每个线程使用一个conn。</li>
<li>我们使用的数据库连接池也使用了ThreadLocal技术，但是两者的功能并不重复，连接池负责缓存一些连接提高速度，Thread Local负责事务。</li>
<li>转载的博客，关于项目中的ThreadLocal的应用，在(<a href="https://www.debugger.wiki/article/html/1562468577936287" target="_blank" rel="noopener">这里</a>)</li>
</ol>
<p>##spring的动态代理</p>
<ol>
<li>动态代理的特点：字节码随用随创建，随用随加载，作用：不修改源码的基础上对原有方法进行增强，分类：基于接口的动态代理和基于子类的动态代理</li>
<li><ul>
<li>基于接口的代理：作用：不修改源码的基础上对原有方法进行增强，涉及的类：Proxy，提供者：JDk官方，如何代理对象：使用Proxy类中的newInstance方法，创建代理对象的要求：被代理类至少实现一个接口，如果没有则不能使用，newInstance的参数ClassLoader：类加载器它是用于加载代理对象字节码的，和被代理的对象使用相同的类加载器。固定写法Class[]：字节码数组，它是用于让代理对象和被代理对象有相同方法，固定写法。InvocationHandler：用于提供增强的方法代码。它是让我们写如何代理，一般都是一些个改接口的实现类，通常情况下是匿名内部类，但不是必须的<br>此接口的实现类都是谁用谁写。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer();<span class="comment">//注意invocationHandler一般是使用的匿名内部类,一定要写这个，不然就会出现代理无法代理，并且要和代理方法写在统一方法内，不然会报static的错误。</span></span><br><span class="line"></span><br><span class="line">(java.lang.reflect.Proxy)<span class="comment">//代理类是这个包下的</span></span><br><span class="line"></span><br><span class="line">IProducer proxyProducer = (IProducer)Proxy.newProxyInstance(producer.getClass().getClassLoader(), producer.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 执行该被代理对象的任何接口方法都会经过该方法</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> proxy 代理对象的引用</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method 当前执行的方法</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> args 当前执行的方法所需的参数</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span> 和被代理对象具有相同的返回值</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                       Object returnValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//提供增强的代码</span></span><br><span class="line">                        <span class="comment">//1.获取方法执行的参数</span></span><br><span class="line">                        Float money = (Float) args[<span class="number">0</span>];</span><br><span class="line">                        <span class="comment">//2.判断当前方法是否是销售</span></span><br><span class="line">                        <span class="keyword">if</span> (method.getName().equals(<span class="string">"saleProduct"</span>))&#123;</span><br><span class="line">                            returnValue = method.invoke(producer,money*<span class="number">0.8f</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">       proxyProducer.saleProduct(<span class="number">10000f</span>);<span class="comment">//这个就是当前执行的代理对象的方法，producer就是被代理对象就是invoke参数中的proxy，method是saleProduct，args[]就是参数列表</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    代理对象的几个注意点：首先必须先<span class="keyword">new</span>一个被代理对象（且被代理对象的要是最终类，即用<span class="keyword">final</span>修饰），然后再invoke方法中，定义一个object就是要返回的被代理对象，用method.getName().equals()来判定是否是要增强的方法，如果是，调用method.invoke（）将对象和参数传入，注意这里传入的对象是一开<span class="keyword">new</span>的对象，因为被代理增强的对象是returnValue，还没有被增强返回，另外，就是invoke返回值才是被代理增强的对象，在最后调用被增强的对象。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li></li>
</ol>
<ul>
<li><p>基于子类的动态代理,是为了解决基于接口的代理对象必须要实现某个接口的弊端，普通类是无法使用动态代理的，这种代理方式需要使用第三方jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1_3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>基于子类的动态代理:涉及的类：Enhancer提供者：第三方cglib库,如何代理对象：使用Enhancer类中的create方法,被代理类不能是最终类（即不能用final修饰）。create的参数：Class：字节码它是用于指定被代理对象的字节码，callback：用于提供增强的方法代码它是让我们写如何代理，一般都是一些个改接口的实现类，通常情况下是匿名内部类，但不是必须的，此接口的实现类都是谁用谁写。我们一般写的是该接口的子接口实现类：methodInterceptor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Producer cglibProxy = (Producer)Enhancer.create(producer.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行被代理对象的方法之前都会经过该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">             * 和基于接口的参数是一样的</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> methodProxy 当前执行方法的代理对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Object returnValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//提供增强的代码</span></span><br><span class="line">                <span class="comment">//1.获取方法执行的参数</span></span><br><span class="line">                Float money = (Float) args[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">//2.判断当前方法是否是销售</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"saleProduct"</span>))&#123;</span><br><span class="line">                    returnValue = method.invoke(producer,money*<span class="number">0.8f</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    cglibProxy.saleProduct(<span class="number">12000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>##AOP面向切面编程</p>
<ol>
<li>通过在编译期执行和运行期使用动态代理的方式对对象进行统一的管理，大大降低了重复代码，提高开发效率</li>
<li>AOP的相关术语：</li>
</ol>
<ul>
<li>JoinPoint：连接点，在spring中，这些点指的是方法，因为spring只支持方法类型的点，翻译成人话是就是在业务层接口中的方法都是连接点。</li>
<li>PointCut：切入点，指连接点中被代理增强的点，所有的切入点都是连接点，因为都是业务层接口的方法，但不是所有的连接点都是切入点</li>
<li>Advice：通知/增强，指拦截到之后应该干的事情，分类：前置通知，后置通知，异常通知，最终通知，环绕通知。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//环绕通知：整个的invoke方法在执行就是环绕通知，并且环绕通知中有明确的切入点方法调用。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundPrintLog</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">        Object reValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Object[] args = pjp.getArgs();<span class="comment">//获得执行方法所需的参数</span></span><br><span class="line">            System.out.println(<span class="string">"printLog in Logger begin execute"</span>);<span class="comment">//前置通知</span></span><br><span class="line">            reValue = pjp.proceed(args);<span class="comment">//切入点方法</span></span><br><span class="line">            System.out.println(<span class="string">"printLog in Logger begin execute"</span>);<span class="comment">//后置通知</span></span><br><span class="line">            <span class="keyword">return</span> reValue;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            System.out.println(<span class="string">"printLog in Logger begin execute"</span>);<span class="comment">//异常通知</span></span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"printLog in Logger begin execute"</span>);<span class="comment">//最终通知</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>Introduction：引介，引介是一种特殊的通知在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或Filed。</li>
<li>Target：被代理的对象</li>
<li>Weaving：织入，把增强方法应用到Target上来创建新的代理对象的过程。</li>
<li>Proxy：代理，一个类被AOP织入增强后，就产生一个结果代理类。</li>
<li>Aspect：切面，是切入点和通知的结合。</li>
</ul>
<ol start="3">
<li>学习AOP要明确的事</li>
</ol>
<ul>
<li>开发阶段：编写核心业务代码（开发主线），大部分程序员来做，对业务熟悉即可。<br>把公用代码抽取出来，制作成通知，（开发最后阶段在做），由团队中的老鸟来做<br>在配置文件中声明切入点和通知之间的关系，即切面。</li>
<li>spring的工作：spring监控切入点方法的执行，一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置将对应通知的功能织入，完成完整的代码逻辑运行。</li>
</ul>
<ol start="4">
<li>基于xml的AOP<br>使用AOP需要的maven<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="comment">&lt;!--负责解析切入点表达式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--配置Ioc，把service对象存入ioc容器之中--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--把通知也存入容器中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logger"</span> <span class="attr">class</span>=<span class="string">"com.itheima.utils.Logger"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span><span class="comment">&lt;!--开启AOP的配置--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"logger"</span>&gt;</span><span class="comment">&lt;!--配置通知方法--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置前置通知类型，并且建立通知方法和切入点方法的关联--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--pointCut，建立和切入点之间的联系，不然spring不知道向哪个切入点织入通知方法--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;aop:before method="beforePrintLog" pointcut="execution(* com.itheima.service.impl.*.*(..))"&gt;&lt;/aop:before&gt;--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--before指定在切入点方法调用之前执行，是前置通知，mehtod是增前方法的名字--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置后置通知类型，并且建立通知方法和切入点方法的关联--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;aop:after-returning method="afterReturningPrintLog" pointcut="execution(* com.itheima.service.impl.*.*(..))"&gt;&lt;/aop:after-returning&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--配置异常通知类型，并且建立通知方法和切入点方法的关联--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;aop:after-throwing method="afterThrowingPrintLog" pointcut="execution(* com.itheima.service.impl.*.*(..))"&gt;&lt;/aop:after-throwing&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--配置最终通知类型，并且建立通知方法和切入点方法的关联--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;aop:after method="afterPrintLog" pointcut="execution(* com.itheima.service.impl.*.*(..))"&gt;&lt;/aop:after&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>pointCut的写法：<br>标准写法:关键字：execution(表达式)，表达式，访问修饰符  返回值 包名…类名.方法名(参数列表)</p>
<pre><code>public    void   com.itheima.service.impl.serviceImpl.saceAccount()</code></pre><p>简略写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//省略修饰符可以省略</span></span><br><span class="line"><span class="keyword">void</span> com.itheima.service.impl.serviceImpl.saceAccount()</span><br><span class="line"><span class="comment">//返回值可以使用通配符，表示任意返回值</span></span><br><span class="line">* com.itheima.service.impl.serviceImpl.saceAccount()</span><br><span class="line"><span class="comment">//包名可以使用通配符，表示任意包，但是又几级包就要写几个*.</span></span><br><span class="line">* *.*.*.*.serviceImpl.saceAccount()</span><br><span class="line"><span class="comment">//包名可以使用..表示当前包及其自包</span></span><br><span class="line">* *..serviceImpl.saceAccount()</span><br><span class="line"><span class="comment">//类名和方法名都可以使用*来实现通配</span></span><br><span class="line">* *..*.saceAccount()</span><br><span class="line">* *..*.*()</span><br><span class="line"><span class="comment">//参数列表，可以直接写数据类型，基本数据类型直接写名称，引用类型写包名.类名的方式</span></span><br><span class="line">* *..*.(<span class="keyword">int</span>)</span><br><span class="line">* *..*.(java.lang.String)</span><br><span class="line"><span class="comment">//类型使用通配符，表示任意类型，但是必须要有参数</span></span><br><span class="line">* *..*.(*)</span><br><span class="line"><span class="comment">//参数可以使用..表示有无参数都可，就是全通配方法，所有方法都会被增强，不是我们的目的</span></span><br><span class="line">* *..*.(..)</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际开发中的写法是切到业务层实现类下的所有方法</span></span><br><span class="line">* com.itheima.service.serviceImpl.*.*(..)  *.是所有方法，*(..)是所有参数，有无参数都可</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置切入点表达式<br>配置切入点表达式，id属性用于指定表达式的唯一标识，expression属性用于指定表达式内容，此标签可以写在<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>内部，也可以写在标签外部，写在内部只能当前切面使用，写在外部可以所有切面使用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.itheima.service.impl.*.*(..))"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"logger"</span>&gt;</span><span class="comment">&lt;!--ref是配置通知是谁，id是切面自生的唯一标识--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--引用外部切入点方法--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beforePrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--配置前置通知类型，并且建立通知方法和切入点方法的关联--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;aop:before method="beforePrintLog" pointcut="execution(* com.itheima.service.impl.*.*(..))"&gt;&lt;/aop:before&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--配置后置通知类型，并且建立通知方法和切入点方法的关联--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;aop:after-returning method="afterReturningPrintLog" pointcut="execution(* com.itheima.service.impl.*.*(..))"&gt;&lt;/aop:after-returning&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--配置异常通知类型，并且建立通知方法和切入点方法的关联--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;aop:after-throwing method="afterThrowingPrintLog" pointcut="execution(* com.itheima.service.impl.*.*(..))"&gt;&lt;/aop:after-throwing&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--配置最终通知类型，并且建立通知方法和切入点方法的关联--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;aop:after method="afterPrintLog" pointcut="execution(* com.itheima.service.impl.*.*(..))"&gt;&lt;/aop:after&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>环绕通知</p>
</li>
</ol>
<ul>
<li>问题：当我们配置了环绕通知后，切入点方法没有执行，而通知方法执行了<br>分析<br>  通过对比动态代理中的代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有<br>  解决：spring矿建为我们提供了一个接口，ProceedingJoinPoint。该接口有一个方法proceed()。此方法就相当于明确调用切入点方法。<br>  该接口可以作为环绕通知的方法参数，在程序执行过程中，spring框架会为我们提供该接口的实现类供我们使用。<br>  spring中的环绕通知，是一种可以在代码中手动控制增强代码何时执行的方式<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里的通知方法都是通过代码来手动控制执行的，而不是通过xml的配置来配置的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundPrintLog</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">        Object reValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Object[] args = pjp.getArgs();<span class="comment">//获得执行方法所需的参数</span></span><br><span class="line">            System.out.println(<span class="string">"printLog in Logger begin execute"</span>);<span class="comment">//前置</span></span><br><span class="line">            reValue = pjp.proceed(args);<span class="comment">//这里就是执行切入点方法</span></span><br><span class="line">            System.out.println(<span class="string">"printLog in Logger begin execute"</span>);<span class="comment">//后置</span></span><br><span class="line">            <span class="keyword">return</span> reValue;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            System.out.println(<span class="string">"printLog in Logger begin execute"</span>);<span class="comment">//异常</span></span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"printLog in Logger begin execute"</span>);<span class="comment">//最终</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="8">
<li>基于注解的AOP<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>()<span class="comment">//写在类上，表明这是切面类</span></span><br><span class="line"><span class="comment">//在四种通知上写@Before，@AfterRunning，@AfterThrowing，@After，@Around</span></span><br><span class="line"><span class="comment">//在类中写切入点方法，private void pt1()&#123;&#125;,在方法上加注解@Pointcut("expression(切入点表达式)")</span></span><br><span class="line"><span class="comment">//在bean.xml中开启aop注释&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;,不用写参数</span></span><br><span class="line"><span class="comment">//在@Before里面加上切入点方法,@Before("pt1()"),括号一定要加</span></span><br><span class="line"><span class="comment">//完全不使用xml只要在配置类上加@EnableAspectJAutoProxy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(value = <span class="string">"logger"</span>)</span><br><span class="line"><span class="meta">@Aspect</span>(value = <span class="string">"loggerAspect"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* cuit.cs.service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span>(value = <span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"异常通知执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(value = <span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finallyLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"最终通知执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(value = <span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundLogger</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">        Object returnValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] args = pjp.getArgs();</span><br><span class="line">            beforeLogger();</span><br><span class="line">            returnValue = pjp.proceed(args);</span><br><span class="line">            afterLogger();</span><br><span class="line">            <span class="keyword">return</span> returnValue;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            exceptionLogger();</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            finallyLogger();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>##JDBCTemplate</p>
<ol>
<li><p>所需的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>jdbctemplate的CRUD</p>
</li>
</ol>
<ul>
<li>保存，更新，插入，删除都是jdbctemplate.update方法，使用预处理语句和占位符输出<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbcTemplate.update(<span class="string">"insert into accoune (name,money) values(?,?)"</span>,<span class="string">"dsa"</span>,<span class="number">225</span>);</span><br></pre></td></tr></table></figure></li>
<li>查询<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">查询是比较复杂的操作，因为和myBatis中一样涉及到结果集的封装</span><br><span class="line">template由两种查询方法</span><br><span class="line">query(String sql, Object[] args,RowMapper&lt;T&gt; rowMapper);<span class="comment">//这种是所有版本都能用的</span></span><br><span class="line">query(String sql,RowMapper&lt;T&gt; rowMapper,Object... args);<span class="comment">//这种是JDK1.5之后才能用的</span></span><br><span class="line"><span class="comment">//两者都返回list集合，但是第二种是可变参数，第一种是参数数组。一般选第二种</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><p>查询方法中有一个RowMapper<T> 的参数，这个参数是个接口，我们不能直接使用，但是我们可以在下面建立一个类实现这个接口，手动完成结果集的封装</T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Account</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 实现结构集封装方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> resultSet</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Account <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                Account account = <span class="keyword">new</span> Account();</span><br><span class="line">                account.setId(resultSet.getInt(<span class="string">"id"</span>));</span><br><span class="line">                account.setMoney(resultSet.getDouble(<span class="string">"money"</span>));</span><br><span class="line">                account.setName(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> account;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现了结果集的封装之后，我们就可以在查询语句中new 一个AccoutRowMapper，就能封装了，并且我们返回的是Account，但是spring会自动把account取出并放入集合中，不需要我们手动去放入</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>jdbctemplate的查询与dbutils的查询的区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">query(String sql,ResultSetHandler&lt;T&gt; rsh,Object... args)<span class="comment">//这时dbutils的查询方法</span></span><br><span class="line">query(String sql,RowMapper&lt;T&gt; rm,Object... args)<span class="comment">//这是spring的查询方法</span></span><br><span class="line"><span class="comment">//由此可见，Row Mapper和ResuleHandler两个接口的作用是一样的，但是在dbutils中我们并没有使用自己创建实现类的方式，而是使用了dbutils提供的BeanLishHandler实现类，如果是单个对象就使用BeanHandler，那么可以推出spring中也有写好的实现类供调用，就是BeanPropertyRowMapper，但是spring只有BeanPropertyHandler，不管查询单个还是所有，因为spring是通过不同的query方法来决定返回指定的，而dbutils是通过不同的BeanLIstHandler或者BeanHandler来实现返回值控制的。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JDBCDaoSupport类是用来抽取重复代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">产生的原因是当我们有多个dao时，每个dao中都需要写jdbcTemplate，十分繁琐，也就形成大量重复代码，这时可以使用dao继承JDBCSuppport，support中有template和datasource两个参数，这样就可以直接使用getCreateTemplate方法获取template，只要在accountDao中注入数据源或者template即可，但是如果继承了之后就不能在使用注解<span class="meta">@Autowired</span>了，因为是jar包中的代码无法修改，因此要根据自己选用的方式来合理选择。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>##spring的事务</p>
<ol>
<li><p>spring中也有提供的事务控制API，不需要我们自己写，下面是bean.xml的头部信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">支持aop和注解还有事务控制的头部信息</span><br></pre></td></tr></table></figure></li>
<li><p>基于xml的事务控制</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">spring中基于xml的声明式事务控制</span></span><br><span class="line"><span class="comment">    1.配置事务管理器</span></span><br><span class="line"><span class="comment">    2.配置事务的通知</span></span><br><span class="line"><span class="comment">        使用tx：advice来配置</span></span><br><span class="line"><span class="comment">        属性：id给事务起一个唯一标识</span></span><br><span class="line"><span class="comment">            transaction-manager:给事务通知提供一个事务管理器引用</span></span><br><span class="line"><span class="comment">    3.配置AOP中的通用切入点表达式</span></span><br><span class="line"><span class="comment">    4.建立事务通知和切入点方法的关系</span></span><br><span class="line"><span class="comment">        使用&lt;aop:advisor&gt;</span></span><br><span class="line"><span class="comment">    5.配置事务属性</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置事务的通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        isolation:用于指定事务的隔离级别，默认值是DEFAULT，表示使用数据库的默认隔离级别</span></span><br><span class="line"><span class="comment">        propafation:用于指定事务的传播行为，默认值是REQUIRED，表示一定会有事务，增删改的选择，查询方法可以选择SUPPORTS</span></span><br><span class="line"><span class="comment">        read-only;用于指定事务是否只读，只有查询方法才能设置为true，默认值是false，表示读写</span></span><br><span class="line"><span class="comment">        timeout:用于指定事务的超时时间，默认值是-1，表示永不超时，如果指定了数字，单位是秒</span></span><br><span class="line"><span class="comment">        rollback-for:用于指定一个异常，产生异常时，事务回滚，产生其他异常事务不回滚，没有默认值，表示任何异常都回滚</span></span><br><span class="line"><span class="comment">        no-rollback-for:用于指定一个异常，产生异常时，事务不回滚，产生其他异常事务回滚，没有默认值，表示任何异常都回滚</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"transfer"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"false"</span> <span class="attr">rollback-for</span>=<span class="string">""</span> <span class="attr">no-rollback-for</span>=<span class="string">""</span> <span class="attr">timeout</span>=<span class="string">"-1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> <span class="attr">rollback-for</span>=<span class="string">""</span> <span class="attr">no-rollback-for</span>=<span class="string">""</span> <span class="attr">timeout</span>=<span class="string">"-1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> <span class="attr">rollback-for</span>=<span class="string">""</span> <span class="attr">no-rollback-for</span>=<span class="string">""</span> <span class="attr">timeout</span>=<span class="string">"-1"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--*的优先级低于find*，因此约定，查询方法都以find开头--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* cuit.cs.domain.Account.hashCode())"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>基于注解的事务控制</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1.配置事务管理器</span></span><br><span class="line"><span class="comment">2.开启sprig的事务控制</span></span><br><span class="line"><span class="comment">3.在需要使用事务的地方使用@Transactional注解，就是在业务层上面写注解</span></span><br><span class="line"><span class="comment">但是有的方法是只读型的，有的是读写型的。当一个业务层中的方法很多时。用注解配置就非常复杂。不如用xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@Transactional(propagation=Propagation.REQUIRED.readOnly=true)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编程式事务控制<br>开发中用到非常少，暂时不想接触，有空再说</p>
</li>
</ol>
<p>##spring的踩雷</p>
<ol>
<li><p>工厂模式解耦的原理是为了解决编译期的依赖，意思就是不会因为找不到对应的类或jar包，而在编译期就报错，我一开始的想法是在工厂中直接return new 对象，但是这并不符合要求，因为如果对象不存在，仍然解决不了编译期的依赖问题，但是放在配置文件中不管文件名是否存在，都不会报错，只会在执行时找不到类才会报错。</p>
</li>
<li><p>工厂获取配置文件时，一般是使用流输入，但是流的获取就需要路径，而开发中路径的获取一般使用当前类加载器的getResourceASStream（）获取resource文件夹下的配置文件。</p>
</li>
<li><p>BeanFactory的方法和变量都是使用的静态方法，这样能提高创建对象的速度。</p>
</li>
<li><p>工厂类的getbean方法返回对象时，注意要在Class.forName(beanPath)后面加上newInstance方法，不然无法映射类。</p>
</li>
<li><p>在写@Component标签时要在后面加上value，值是这个Bean的名字。</p>
</li>
<li><p>由于取消了xml，因此类中的依赖注入就需要@Atuowired来进行，否则会报空指针异常</p>
</li>
<li><p>spring与数据库进行交互，使用dbutils和c3p0，其中dbutils是对jdbc的简单封装，而c3p0是一种连接池技术，两者的依赖在下面</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>由于dbutils是外部jar包，所以我们不使用注解注入的方式使用而是使用xml配置，最不好找的是他的全限定类名，在下面</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"database"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>为了使数据库方便修改，我们使用配置文件的方式配置，首先打开引用外部文件，在写上外部文件的地址，在用el表达式取得值，如果文件引用成功，那么写完${}就会有提示的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"sql.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span><span class="comment">&lt;!--要先写这个--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"database"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>事务操作是在accountServiceImpl中实现的而不是持久层实现的。</p>
</li>
<li><p>transaction中的连接不用设置中间变量，而是直接调用connectionUtils.getThreadConnection().commit()来执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> connectionUtils connectionUtils;</span><br><span class="line">        <span class="comment">//不用中间变量是可能是因为spring认为还有一个Connection对象需要注入，但是我们是从connectinutils中拿的，并没有通过spring注入 。可能让后spring就认为没有注入，报错。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">transactionManager</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        connectionUtils.getThreadConnection().setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        connectionUtils.getThreadConnection().commit();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将事务控制转移到业务层后发现事务并没有执行，扣钱的执行了但是加钱的没有执行，而理论上应该是扣钱和加钱都失败才对，分析一下，还是和之前没有使用事务的时候一样，每个连接还是单独的连接，并没有使用同一个连接，就因此导致事务不能控制所有的连接，但是为什么会这样，业务层已经开启了事务，仔细一想，业务层完成了，持久层呢，后来一看果然是的，持久层中任然是每次都从数据源中取出新的连接，怪不得事务不起作用，把xml文件中的set方法注入数据源依赖删除，在持久层中使用connectionUtils获取连接，但是注意不要使用中间变量，原因在上一条。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">propertiy</span> <span class="attr">name</span>=<span class="string">"ds"</span> <span class="attr">ref</span>=<span class="string">"database"</span>&gt;</span><span class="tag">&lt;/<span class="name">propertiy</span>&gt;</span><span class="comment">&lt;!--把这行删除--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"database"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> connectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//              使用connectionUtils().getThreadConnection()来获取练接，不通过中间变量</span></span><br><span class="line">            runner.update(connectionUtils.getThreadConnection(),<span class="string">"update account set money = ? where id = ?"</span>,account.getMoney(),account.getId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>#SpringMVC</p>
<ol>
<li><p>springMVC位于表现层，主要与浏览器进行数据的交互，就是将页面模板进行动态数据的填充</p>
</li>
<li><p>开发所需的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建工程使用骨架开发，注意要选用org.apache.maven.archetypes:maven-archetype-webapp，不要选用其他的webapp，就是第三个后缀带webapp的选项。</p>
</li>
<li><p>项目创建完成之后，可以看到main的文件下面没有java和resources文件夹，于是就要新建两个文件夹。</p>
</li>
<li><p>配置springMVC的文件的头部信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/mvc/spring-mvc.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>quickStart项目步骤</p>
</li>
</ol>
<ul>
<li>在web.xml中配置分发器并且配置在一开始时就加载springMVC配置文件<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>//spring的资源分发器</span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>//配置配置文件的位置</span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>//使用类路径下resources文件</span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span>//表示服务器第一次启动就扫描springMVC文件和创建dispatcher，否则视图解析器和其他注解无法使用</span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>//配置拦截路径</span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>编写index.jsp和success.jsp文件，普通编写</li>
<li>编写servelt，在类上使用注解@Controller，存入spring容器，在方法上使用@RequestMapping，映射请求路<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span>()<span class="comment">//自动放入ioc容器，id默认时类名首字母小写</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)<span class="comment">//springMVC的注解，配置请求路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;<span class="comment">//返回的值被视图解析器接受，在进行字符串拼接，获得success.jsp的路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>打开springMVC配置文件，开启spring注解扫描和springMVC注解扫描，配置视图解析器<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启注解扫描，扫描controller--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cuit.cs"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!--一定注意WEB-INF前面一定要有一个斜杠,不然路径就会变成(successWeb-INF/pages/success.jsp),另外pages后面也要加斜杠,不然路径也会错误,想前面一样--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启springMVC的注解支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="6">
<li>springMVC各组件的功能<br><img src="/2020/06/20/ssm%E6%A1%86%E6%9E%B6/springMVC%E5%90%84%E7%BB%84%E5%BB%BA%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt></li>
</ol>
<ul>
<li>dispatcherServlet:控制作用,指挥路径,根据请求路径找到对应的执行方法,在将返回值转给视图解析器,视图解析器将返回值拼接之后找到jsp文件,在返回给浏览器.</li>
<li>HandlerMapping:负责将请求的路径映射到具体的执行方法上</li>
<li>HandlerAdapter:处理器适配器,去调用处理器(Handler)执行所有类型的方法</li>
<li>ViewResolver:视图解析器,负责跳转到方法指定的页面并且填充数据</li>
</ul>
<ol start="7">
<li>如果开启MVC注解,springMVC就可以自动配置处理器映射器和处理器适配器,不许要手动配置了,只需要配置视图解析器就行</li>
</ol>
<p>##springMVC的注解（请求类型）</p>
<ol>
<li><p>requestMapping:请求映射,将请求的路径映射到具体的执行方法.可以在类上写也可以在方法上写,在类上写是一级目录,方法是二级目录.属性中有value,这是指定请求路径,method指定请求方法(@RequestMapping(method={RequestMethod.POST})),params指定请求参数必须满足的条件(@RequestMapping(params={“username”}),指定参数中必须有一个名字叫username的参数,值随便),headers指定请求必须有的请求头(@RequestMapping(headers={“Accept”}),必须要有Accept这个请求头)</p>
</li>
<li><p>requesrParam,当表单中的变量名和参数列表中的名字不一样时,使用该注解能将两者映射起来,但是写了注解后,表单中的变量名只能叫这个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@RequestParam(value = <span class="string">"username"</span>)</span>String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello:"</span>+name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span> placeholder=<span class="string">"账户名"</span>&gt;&lt;br&gt;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span> placeholder=<span class="string">"年龄"</span>&gt;&lt;br&gt;</span><br><span class="line"><span class="comment">//还有个属性是required,表示必须要有指定的value这个参数,如果没有会报错,默认是true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>RequestBody,设置于请求体相关的注解,只有一个属性就是required,默认是true,是true时get方式是无效的,false时可以使用get方式,但是请求体式null,因为get方式将请求参数封装在地址栏中.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@RequestBody String Body)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello:"</span>+Body);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>PathVariable,在url请求路径上设置占位符,输入路径时可以省点力,个人暂时感觉作用不大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello/&#123;sid&#125;"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@PathVariable String id)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"hello:"</span>+id);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hiddenHttpMethodHeader,更改请求的方式,比如把post或者get改为delete等等,作用不大.</p>
</li>
<li><p>Requestheader,获取请求的请求头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@RequestHeader(value = <span class="string">"Accept"</span>)</span> String header)</span>&#123;<span class="comment">//这些注解都是注在参数上面,是将value指定的值赋给参数,再通过参数打印出来</span></span><br><span class="line">        System.out.println(<span class="string">"hello:"</span>+header);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cookieValue,拿到cookie的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@CookieValue(value = <span class="string">"JESSIONID"</span>)</span> String cookie)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello:"</span>+cookie);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ModelAttribute,写在方法上会使该方法再执行方法之前执行,用于当请求参数只能封装部分信息时,没有传过来的参数会使用从数据库中查询出来的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有返回值类型</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello:"</span>+user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">modelAttribute</span><span class="params">(String name,<span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"执行了"</span>);</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    uesr.setName(name);</span><br><span class="line">    uesr.setMoney(money);</span><br><span class="line">    user.(<span class="keyword">new</span> Data());</span><br><span class="line">    <span class="keyword">return</span> uesr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有返回值类型,将数据存入map集合中,执行方法从集合中取出，存入的位置是request域对象</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@ModelAttribute(<span class="string">"abd"</span>)</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello:"</span>+user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modelAttribute</span><span class="params">(String name,<span class="keyword">double</span> money,Map&lt;String,user&gt; map)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"执行了"</span>);</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    uesr.setName(name);</span><br><span class="line">    uesr.setMoney(money);</span><br><span class="line">    user.(<span class="keyword">new</span> Data());</span><br><span class="line">    map.put(<span class="string">"abd"</span>,user);</span><br><span class="line">    <span class="keyword">return</span> uesr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>SessionAttribute</p>
</li>
</ol>
<p>##响应类型和返回值类型</p>
<ol>
<li>返回值是String类型，方法返回值是String类型时，会调用视图解析器，根据你之前配置的路径去返回相应的页面。使用Model类将数据存入request域中，在从域对象中取出</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/string"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVoid</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"返回值是String类型方法执行"</span>);</span><br><span class="line">       <span class="comment">//模拟从数据库中查询对象</span></span><br><span class="line">       User user = <span class="keyword">new</span> User();</span><br><span class="line">       user.setMoney(<span class="number">65</span>);</span><br><span class="line">       user.setName(<span class="string">"fdsa"</span>);</span><br><span class="line">       <span class="comment">//这个就已经存入request对象中了</span></span><br><span class="line">       model.addAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>返回值是void类型，通过重定向和转发或者直接使用输出流返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/void"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVoid</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"void方法执行"</span>);</span><br><span class="line">        <span class="comment">//重定向,重定向任然属于一次请求，因此只需要更改项目内的相对路径，相当于是服务器内部进行跳转</span></span><br><span class="line">        <span class="comment">//request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request,response);</span></span><br><span class="line">        <span class="comment">//转发，转发的请求是新的请求，要写完整的url（带项目名），可以用request.getContextPath来获取带项目的路径，而新的请求</span></span><br><span class="line">        <span class="comment">//是相当于用户端发送的新请求，是不能访问到WEB-INF下的内容的，只能访问到webapp下的内容。因此success.jsp是无法访问的</span></span><br><span class="line">        <span class="comment">//response.sendRedirect(request.getContextPath()+"/index.jsp");</span></span><br><span class="line">        <span class="comment">//直接使用输出流写在浏览器上，想写中文需要先设置</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">"你好"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值是ModelAndView，和返回String的类型很像，String类型的底层就是调用ModelAndView对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/ModelAndView"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">testModelAndView</span><span class="params">(String username,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ModelAndView方法执行"</span>);</span><br><span class="line">        <span class="comment">//这个包是spring下的包，不需要考虑依赖问题。</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setMoney((<span class="keyword">double</span>)age);</span><br><span class="line">        user.setName(username);</span><br><span class="line">        mv.addObject(<span class="string">"user"</span>,user);<span class="comment">//底层也会存入request对象中</span></span><br><span class="line">        mv.setViewName(<span class="string">"success"</span>);<span class="comment">//会找视图解析器进行解析</span></span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回值是关键字，有点像返回值是void类型的，都是使用转发和重定向，但是void是直接调用Servlet原生API，关键字是springMVC封装好的，其底层也是调用原生API。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/keyWord"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testKeyWord</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"keyWord方法执行"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"forward:/WEB-INF/pages/success.jsp"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"forward:/index.jsp"</span>;<span class="comment">//spirngMVC自动帮我们加上了request.getContextPath()，并且重新发请求是访问不到webinf目录的</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置前端控制器，使其不拦截静态资源，前端控制器之前配置的是拦截所有资源。注意配置完之后要把服务器重新启动而不是重新部署，但是有时还是不成功，就进到tomcat的webapps/ROOT目录下将里面的内容全部删除（就是删除之前部署的项目），在重新打开ieda</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在springMVC配置文件中写上mvc:resourcem注意这个标签开启的前提是MVC支持注解开启。就是mvc:annotation-driven</span></span><br><span class="line">&lt;mvc:annotation-driven &gt;&lt;/mvc:annotation-driven&gt;</span><br><span class="line">    &lt;mvc:resources mapping="/js/**" location="/js/"&gt;&lt;/mvc:resources&gt;</span><br><span class="line">    &lt;script src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt;//此外注意资源的引用前面不需要加/</span><br></pre></td></tr></table></figure></li>
<li><p>发送异步请求,并返回数据，浏览器发送异步请求，spring能直接将传过来的json的数据封装到实体类中，前提是传来的数据名称和实体类中的变量名相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先要导入转json的依赖</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">       $(function () &#123;</span><br><span class="line">           $(<span class="string">"#btn"</span>).click(function () &#123;</span><br><span class="line">                alert(<span class="string">"aaf"</span>);</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    <span class="comment">//编写json格式，设置属性和值</span></span><br><span class="line">                    url:<span class="string">"test/Ajax"</span>,<span class="comment">//请求路径</span></span><br><span class="line">                    contentType:<span class="string">"application/json;charset=UTF-8"</span>,请求类型</span><br><span class="line">                    data:<span class="string">'&#123;"username":"hehe","money":"56"&#125;'</span>,<span class="comment">//请求参数</span></span><br><span class="line">                    dataType:<span class="string">"json"</span>,<span class="comment">//请求参数类型</span></span><br><span class="line">                    type:<span class="string">"post"</span>,</span><br><span class="line">                    success:function (data) &#123;</span><br><span class="line">                        <span class="comment">//解析服务器传回来的数据</span></span><br><span class="line">                        alert(data.name);</span><br><span class="line">                        alert(data.money);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/Ajax"</span>)</span><br><span class="line">    <span class="comment">//返回值也要以json的形式写回，就需要ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">User <span class="title">testAjax</span><span class="params">(@RequestBody User user)</span></span>&#123;<span class="comment">//由于json是在请求体中的，因此需要用RequestBody，但是注意变量是User，才能封装</span></span><br><span class="line">        System.out.println(<span class="string">"textAjax方法执行"</span>);</span><br><span class="line">        user.setName(<span class="string">"hanhan"</span>);<span class="comment">//修改了user的属性</span></span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> user;<span class="comment">//返回user</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>##参数绑定及类型自动转换</p>
<ol>
<li><p>请求参数的绑定,只要在方法中的参数列表中写上要封装的类型,spring会自动为封装到对应的数据类型.但是要求参数列表中的数据名字和request中的数据名一样.不管是get还是post请求都会封装,但是数据量大时就会使用post提交</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Account account)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello:"</span>+account);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果封装类型中包括对其他类型的引用,在提交请求时就要注明,例如user.name,这种方法之前在mybatis中的类型引用中也使用过.</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Account account)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello:"</span>+account);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">"/hello"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> name=<span class="string">"user.name"</span> placeholder=<span class="string">"用户名"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> name=<span class="string">"user.money"</span> placeholder=<span class="string">"用户金额"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span> placeholder=<span class="string">"账户名"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span> placeholder=<span class="string">"年龄"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装复杂数据类型list和map</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">"/hello"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"list[0].name"</span> placeholder=<span class="string">"用户名"</span>&gt;&lt;br&gt;</span><br><span class="line">    <span class="comment">//注意map的写法就行,中括号中是指定的键的名字.</span></span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"map['one'].money"</span> placeholder=<span class="string">"用户金额"</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span> placeholder=<span class="string">"账户名"</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span> placeholder=<span class="string">"年龄"</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>自定义数据类型转换器,可以根据自己的要求定制指定格式的类型转换器,在把他注册到springMVC的类型转换器之中(springMVC是基于组件的).自定义转换器需要实现Spring的Converter&lt;S,T&gt;接口.实现这个接口就可以转换自己想要的数据类型.</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"> &lt;!--开启springMVC的注解支持,使用转换器功能要在这里开启--&gt;</span><br><span class="line">    &lt;mvc:annotation-driven conversion-service="conversionService" &gt;&lt;/mvc:annotation-driven&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//转换器本身就是一个Bean对象,按照普通的Bean对象配置方式去配置就行,类成员converters是一个set集合,需要加上一个set标签.</span></span><br><span class="line">    &lt;bean id=<span class="string">"conversionService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"converters"</span>&gt;</span><br><span class="line">            &lt;set&gt;</span><br><span class="line">                &lt;bean class="cuit.cs.utils.myTransfer"&gt;&lt;/bean&gt;</span><br><span class="line">            &lt;/set&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取javaweb中的request和response对象只要在参数列表中写上这两个参数即可.</p>
</li>
</ol>
<p>##spring的文件上传</p>
<ol>
<li><p>文件上传首先要使用表单，表单的enctype属性必须是multitype/form-data,默认值是application/-www-form-urlencoded，post方式提交。</p>
</li>
<li><p>当使用multitype/form-data时，request.getParamter()方法就失效了，因为表单数据不再是键值对形式而是被分割成一段一段的。</p>
</li>
<li><p>文件解析需要的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>传统方式上传文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取request对象，通过request对象在服务器上创建文件夹</span></span><br><span class="line"><span class="comment">//判断文件是否存在，不存在则创建一个</span></span><br><span class="line"><span class="comment">//解析requset，获取文件上传项</span></span><br><span class="line"><span class="comment">//将文件名唯一编码在写入目标文件夹</span></span><br><span class="line">String path = request.getSession().getServletContext().getRealPath(<span class="string">"/uploads/"</span>);<span class="comment">//创建文件上传路径</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(path);<span class="comment">//创建文件</span></span><br><span class="line">        <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">            file.mkdirs();<span class="comment">//创建文件夹</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始解析request</span></span><br><span class="line">        DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">        ServletFileUpload upload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">        List&lt;FileItem&gt; fileItems = upload.parseRequest(request);</span><br><span class="line">        <span class="keyword">for</span> (FileItem fileItem :fileItems)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fileItem.isFormField())&#123;<span class="comment">//判断是否是文件上传项</span></span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                String name = fileItem.getName();</span><br><span class="line">                String UUid = UUID.randomUUID().toString().replace(<span class="string">"_"</span>, <span class="string">""</span>);</span><br><span class="line">                name = UUid+<span class="string">"_"</span>+name;</span><br><span class="line">                fileItem.write(<span class="keyword">new</span> File(path,name));</span><br><span class="line">                fileItem.delete();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>spring方式上传文件，spring的方式简单许多，因为spring提供了文件解析器组件，不用手动编写解析。但是注意<input type="file" name="upload">,控制器方法中的参数MultipartFile对象的变量名必须和表单中文件的name属性一样，并且文件解析器中的id必须是multipartResolver，不能改</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/upload"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testUpload2</span><span class="params">(MultipartFile upload,HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">//文件存在request对象中</span></span><br><span class="line">        System.out.println(<span class="string">"文件上传成功"</span>);</span><br><span class="line"></span><br><span class="line">        String path = request.getSession().getServletContext().getRealPath(<span class="string">"/uploads/"</span>);<span class="comment">//获取文件上传路径</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(path);<span class="comment">//创建文件</span></span><br><span class="line">        <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">            file.mkdirs();<span class="comment">//创建文件夹</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String fileName = upload.getName();<span class="comment">//文件名</span></span><br><span class="line">        upload.transferTo(<span class="keyword">new</span> File(path,fileName));<span class="comment">//只剩这两步了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"multipartResolver"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span><br><span class="line">        &lt;property name="maxUploadSize" value="10485760"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;//文件解析器名称</span><br></pre></td></tr></table></figure>
</li>
<li><p>跨服务器上传，暂时用不到，先🕊了。</p>
</li>
</ol>
<p>##异常处理及拦截器</p>
<ol>
<li>拦截器和过滤器很像，但是拦截器是spring自带的，使用spring框架才有拦截器，过滤器是java自带的，所有工程都能用</li>
<li>使用自定义异常处理器，异常处理的步骤是首先捕获异常，由自定义的异常类抛出信息，异常处理器接受到并跳转到友好页面。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testException"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testException</span><span class="params">()</span> <span class="keyword">throws</span> sysException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testException方法执行"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> sysException(<span class="string">"查询所有用户错误"</span>);<span class="comment">//抛出自己的异常</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在配置文件中配置异常处理器，把它当作正常的Bean对象来看就行</span></span><br><span class="line">     &lt;bean id="exceptionHandler" class="cuit.cs.exception.sysExceptionHandler"&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//异常处理器需要继承HandlerExceptionResolver接口，</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sysExceptionHandler</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span></span></span><br><span class="line"><span class="class">     @<span class="title">Override</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ModelAndView</span> <span class="title">resolveException</span>(<span class="title">HttpServletRequest</span> <span class="title">httpServletRequest</span>, <span class="title">HttpServletResponse</span> <span class="title">httpServletResponse</span>, <span class="title">Object</span> <span class="title">o</span>, <span class="title">Exception</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        sysException exception = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> sysException)&#123;</span><br><span class="line">            exception = (sysException)e;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            exception = <span class="keyword">new</span> sysException(<span class="string">"系统维护中"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存入错误信息到ModelAndView，通过ModelAndView来进行跳转</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.addObject(<span class="string">"errorMsg"</span>,exception.getMessage());</span><br><span class="line">        mv.setViewName(<span class="string">"error"</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 拦截器只拦截controller中的方法，且拦截器必须实现HandlerInterceptor接口，但是这个接口中的方法已经提前实现好了，如果不想用提前写好的方法可以重写方法，ctrl+o打开重写。拦截器的pre方法，在control方法执行之前执行，返回值为<span class="keyword">true</span>就放行，为<span class="keyword">false</span>就不放行，可以用转发跳转至其他页面。</span><br><span class="line">```java</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">        &lt;mvc:interceptor&gt;</span><br><span class="line">            &lt;mvc:mapping path=<span class="string">"/test/testInterceptor"</span>/&gt;&lt;!--配置哪些方法进行拦截--&gt;</span><br><span class="line">           &lt;!-- &lt;mvc:exclude-mapping path=<span class="string">""</span>/&gt;配置哪些方法不拦截--&gt;</span><br><span class="line">            &lt;bean class="cuit.cs.interceptor.testInterceptor"&gt;&lt;/bean&gt;//配置你的拦截器</span><br><span class="line">        &lt;/mvc:interceptor&gt;</span><br><span class="line">    &lt;/mvc:interceptors&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span><span class="comment">//true是放行，false不放行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"preHandler执行了"</span>);</span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/WEB-INF/pages/error.jsp"</span>).forward(request,response);<span class="comment">//使用重定向</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//后处理方法，在controller方法执行之后，success.jsp页面之前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//jsp页面执行后，该方法会执行    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> after <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment">//此外，还可以配置多个拦截器，形成拦截器链，在&lt;mvc:interceptors 中新增interceptor即可&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>##spirngMVC的踩雷</p>
<ol>
<li><p>提交参数中文乱码,将spring提供的过滤器在web.xml中注册即可,注册之后需要重新启动服务器,因为这是对服务器自身的配置而不是对项目的修改,重新部署不能成功.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span><span class="comment">&lt;!--注意这里是CharacterEncodingFilter自带的属性.不是点空格能自动显示出来的,要自己手打--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>1099端口占用,解决办法在<a href="https://blog.csdn.net/winy_lm/article/details/52095615" target="_blank" rel="noopener">这里</a> </p>
</li>
</ol>
<p>#ssm整合</p>
<ol>
<li><p>整合思路，首先搭建spring框架，在用spring整合MVC()，最后使用spring整合MyBatis。</p>
</li>
<li><p>使用的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.6.6<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- spring --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- log start --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- log end --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>导入依赖之后，构建三层架构(dao，service的接口和实现类以及contrller的编写)，之后就开始spring整合MVC，spring所需的完整头信息如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> 注解相关</span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">aop</span>相关</span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span> 事务控制相关</span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> 扫描包的信息</span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/aop/spring-aop-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/tx/spring-tx-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context/spring-context-3.2.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>首先搭建spring框架，注意ssm中我们只想让spring管理service和dao，controller交给MVC来管理，因此就要在配置文件中去配置不扫描controller文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--除了controller，其他注解都扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cuit.cs"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>搭建好MVC框架后，就可以开始整合了，MVC的配置文件如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置只扫描controller--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cuit.cs"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置不拦截静态资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/js/**"</span> <span class="attr">location</span>=<span class="string">"/js/"</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:resources</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置注解支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>搭建MVC环境时遇到了jar包冲突，还得从文档中把正确的pom下载下来，果然jar包冲突要命，springBoot大法好。</p>
</li>
<li><p>spring整合MVC，要在controller中使用service对象，需要使用spring的依赖注入，但是服务器一启动只会加载MVC配置文件，不会加载Spring配置文件，想要加载spring可以使用监听器(listener)，该监听器监听ServletContext对象，该对象在服务器启动时创建并且只有一个，当服务器关闭时会销毁。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--这样就可以将spring和mvc整合--&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>mybaits的整合核心是把mybatis的配置文件中的信息全部写到spring中，由spring进行管理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///spring"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"admin"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置工厂--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"factory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span><span class="comment">&lt;!--对应mybatis中的创建工厂，有了工厂就可以创建代理类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置接口所在包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mapperScanner"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span><span class="comment">&lt;!--相当于配置主文件中的各dao独立配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"cuit.cs.dao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>spring整合事务控制，很简单和之前的事务控制一样，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置声明式事务管理--&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--配置通知--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">read-only</span>=<span class="string">"false"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:method</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--配置AOP切入--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cuit.cs.service.impl.*ServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>#maven高级</p>
<ol>
<li>完成上面的学习后基本上已经完成了ssm框架的基本操作，接下来是完整的基于ssm的案例，我们完成一个项目时需要使用maven的父工程和子工程的概念来避免服务的重符代码</li>
<li>maven作为项目管理工具，有两大核心功能，一是依赖管理，二是一键构建。</li>
</ol>
<ul>
<li>maven对项目中的jar包是统一放在仓库中，只导入坐标，传统项目是把jar包都放在项目中</li>
<li>maven自身集成了tomcat插件，可以进行项目的编译，测试，打包，安装和发布</li>
</ul>
<p>##maven中的jar包冲突</p>
<ol>
<li>maven在我们导入jar包的时候，会自动把jar包所依赖的jar包一起引进，但是如果两个版本不同的包同时依赖一个jar包时，就可能产生jar包冲突。</li>
<li>解决jar包冲突有三个方法</li>
</ol>
<ul>
<li>第一声明优先原则，哪个jar包的坐标在上面哪个jar包就是先声明的。先声明的jar包的依赖包就会优先导入。</li>
<li>把传递依赖转为直接依赖，路径近者优先原则，直接路劲比依赖路径优先，就是把冲突的包直接导入坐标，指明版本</li>
<li>使用<exclusions>指定不导入哪个依赖包，标签内不需要写版本号，默认和上面的版本相同。（开发推荐使用这个）</exclusions></li>
</ul>
<p>##ssm所用到的最全的pom依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 统一管理jar包版本 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.6.6<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">shiro.version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">shiro.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.security.version</span>&gt;</span>5.0.1.RELEASE<span class="tag">&lt;/<span class="name">spring.security.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 锁定jar包版本 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 项目依赖jar包 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- log start --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- log end --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.security.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.security.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.security.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-taglibs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.security.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加tomcat7插件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><dependenciesManager>是版本锁定，为了防止子工程导入的jar包覆盖父工程的jar包，但是版本锁定只是指定版本并不是把jar包导入项目。</dependenciesManager></li>
</ol>
<p>##maven工程的拆分和聚合</p>
<ol>
<li><p>当项目多了的时候，就会出现服务重复的操作，比如卖家和买家都要查看订单的情况，都是从数据库中查询数据，如果两个都分别编写，就会造成重复代码，把工程拆分就可以提高代码的利用率。</p>
</li>
<li><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--模板和工程的区别</span></span><br><span class="line"><span class="comment">    1.工程不等于完整的项目，模板也不是，代码完整才是项目</span></span><br><span class="line"><span class="comment">    2.工程只能使用自己内部资源，是独立的，后天可以和其他工程和模块建立关联关系</span></span><br><span class="line"><span class="comment">    3.模块是属于父工程的，模块一旦创建所有父工程的资源都可以使用。</span></span><br><span class="line"><span class="comment">    4.灵魂比喻：模块就是后浪，可以使用父工程的所有资源，工程是前浪，只能使用自己拥有的资源</span></span><br><span class="line"><span class="comment">    5.但是模块之间天生没有关联吗，需要像导jar包依赖一样导入资源。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cuit.cs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>maven_dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>maven_service<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>maven_web<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--service引入dao模块，就像引入依赖一样--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cuit.cs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>maven的直接依赖和传递依赖，具体看<a href="https://blog.csdn.net/xzp_forever/article/details/87992971" target="_blank" rel="noopener">这里</a>,在项目中有时会遇到传递依赖不能用的情况，这时我们都是直接在导一次，并不会按照那个表去修改作用域。</p>
</li>
<li><p>父子工程创建好之后就可填充代码了，由于我们在service中引入了dao依赖，web中引入service依赖，所以我们不用写重复代码，dao中有的代码service都会有，只是不可见，而这时配置文件需要改变，先🕊了</p>
</li>
<li><p>父子工程的三种启动方式，第一种，直接启动父工程的tomcat插件，第二种启动本地的tomcat，记得部署，前面两种都不需要本地仓库有service和dao的jar包，但是第三种，通过web模块或者三个模块之一的tomcat插件启动就需要本地仓库中有service和dao的jar包，因为maven工程启动前都要根据pom文件中的依赖去吧jar包添加到项目中，就得先把父工程打包到本地仓库，就是使用父工程的install命令。</p>
</li>
</ol>
<p>##maven的私服</p>
<ol>
<li>暂时了解就可，实际开发并不需要我们去按照私服</li>
</ol>
<p>#ssm案例</p>
<ol>
<li>分模块构建，分为domain，service，dao，web，utils，五个模块，其中web就是表现层，是用来和浏览器交互的，因此使用web骨架构建</li>
<li>将各层的pom都引入其他模块的依赖，比如web要引入service和dao的依赖，service要引入dao的依赖,dao要引入domain的依赖，这个当缺失时会变红的，到时候看缺啥补啥<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cuit.cs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm_dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cuit.cs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm_service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cuit.cs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm_domain<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>按照ssm整合方式将各层整合，注意spring和springMVC都放在web的resources下。下面使用adminLTE，使用这个要把pages和plugins，css，img都复制一份放在webApps的下面，注意这次controller跳转的页面不是在WEB-INF下的pages里面，放在那里面是无法访问webApps下的资源的。并且adminLTE的资源一定要引全，不然页面无法显示。</li>
<li>完成这些之后就可以启动工程了。maven父子工程的三种启动方式在上面，今天试了在父工程下导入tomacat插件，真香，比tomcat本地部署快多了，以后就用他了。注意启动前把父工程的编译全部清空，使用maven的clean插件。</li>
</ol>
<p>##订单操作</p>
<ol>
<li><p>分页查询所有订单，使用pageHelper插件，在maven中引入坐标并且在spring中的sqlSessionFactoryBean中加入插件即可，</p>
</li>
<li><p>首先导入pageHelper的maven依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>接着在sqlSessionFactoryBean中加入插件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--传入插件--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"plugins"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--传入插件的配置--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.github.pagehelper.PageInterceptor"</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"helperDialect"</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">prop</span>&gt;</span><span class="comment">&lt;!--设置当前连接的数据库--&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"reasonable"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span><span class="comment">&lt;!--默认合理化，为true时，当第一页时点击上一页时部翻页，在尾页时点击下一页不翻页--&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用时只需在真正执行查询操作之前调用即可，就是在service层调用dao之前使用，但是中间不能有其他语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Orders&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       PageHelper.startPage(<span class="number">1</span>,<span class="number">5</span>);<span class="comment">//第一个数是页码，第二个数是每页显示的条数。</span></span><br><span class="line">       <span class="comment">//中间不能有语句，比如a=10就会失效，因为他是通过拼接字符串的方式实现分页查询的。</span></span><br><span class="line">       <span class="keyword">return</span> ordersDao.findAll();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于我们的分页展示不仅要显示订单数据还要显示总条数和每页的条数，PageHelper为我们提供了PageInfo对象，这个对象是专门的分页对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/findAll"</span>)<span class="comment">//分页版本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">findAll</span><span class="params">(@RequestParam(name = <span class="string">"page"</span>,required = <span class="keyword">true</span>,defaultValue = <span class="string">"1"</span>)</span> <span class="keyword">int</span> page,@<span class="title">RequestParam</span><span class="params">(name = <span class="string">"size"</span>,required = <span class="keyword">true</span>,defaultValue = <span class="string">"4"</span>)</span> <span class="keyword">int</span> size)</span>&#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        List&lt;Orders&gt; orders = ordersService.findAll(page,size);</span><br><span class="line">        PageInfo pageInfo = <span class="keyword">new</span> PageInfo(orders);<span class="comment">//将list集合传入，自动帮我们封装</span></span><br><span class="line">        mv.addObject(<span class="string">"pageInfo"</span>,pageInfo);</span><br><span class="line">        mv.setViewName(<span class="string">"orders-list"</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>##springSecurity的操作</p>
<ol>
<li><p>springsecurity的原理是security代替了Controller的作用，只需要指定登录，失败，成功的页面和指定Service，就完成Controller的配置，然后Service的接口要继承UserDetailsService，在实现类中重写public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException方法。<br><img src="/2020/06/20/ssm%E6%A1%86%E6%9E%B6/springSecurity%E5%8E%9F%E7%90%86.png" alt></p>
</li>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.security.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.security.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.security.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-taglibs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.security.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在web.xml中创建filter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>SpringSecurity314<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-security.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span><span class="comment">&lt;!--名字不能任意改变，必须是这个名字--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>springSecurity核心配置文件(手动配置版，不从数据库中读取数据)，主要是配置controller的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:security</span>=<span class="string">"http://www.springframework.org/schema/security"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/security</span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/security/spring-security.xsd"</span>&gt;</span>        </span><br><span class="line">          </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置不过滤的资源（静态资源及登录相关） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">security</span>=<span class="string">"none"</span> <span class="attr">pattern</span>=<span class="string">"/login.html"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">security</span>=<span class="string">"none"</span> <span class="attr">pattern</span>=<span class="string">"/failer.html"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span> <span class="attr">use-expressions</span>=<span class="string">"false"</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置资料连接，表示任意路径都需要ROLE_USER权限 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自定义登陆页面，login-page 自定义登陆页面 authentication-failure-url 用户权限校验失败之后才会跳转到这个页面，如果数据库中没有这个用户则不会跳转到这个页面。 </span></span><br><span class="line"><span class="comment">            default-target-url 登陆成功后跳转的页面。 注：登陆页面用户名固定 username，密码 password，action:login --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">security:form-login</span> <span class="attr">login-page</span>=<span class="string">"/login.html"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">login-processing-url</span>=<span class="string">"/login"</span> <span class="attr">username-parameter</span>=<span class="string">"username"</span></span></span><br><span class="line">            password-parameter="password" authentication-failure-url="/failer.html"&lt;!--username-parameter的属性可以不写的因为默认就是username--&gt;</span><br><span class="line">            default-target-url="/success.html" </span><br><span class="line">            /&gt;</span><br><span class="line">        <span class="comment">&lt;!-- 登出， invalidate-session 是否删除session logout-url：登出处理链接 logout-success-url：登出成功页面 </span></span><br><span class="line"><span class="comment">            注：登出操作 只需要链接到 logout即可登出当前用户 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">security:logout</span> <span class="attr">invalidate-session</span>=<span class="string">"true"</span> <span class="attr">logout-url</span>=<span class="string">"/logout"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">logout-success-url</span>=<span class="string">"/login.jsp"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关闭CSRF,默认是开启的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">security:csrf</span> <span class="attr">disabled</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">security:authentication-provider</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">security:user-service</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">password</span>=<span class="string">"&#123;noop&#125;user"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">authorities</span>=<span class="string">"ROLE_USER"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">security:user</span> <span class="attr">name</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"&#123;noop&#125;admin"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">authorities</span>=<span class="string">"ROLE_ADMIN"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">security:user-service</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数据库版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:security</span>=<span class="string">"http://www.springframework.org/schema/security"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans          </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd          </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/security          </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/security/spring-security.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置不拦截的资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">pattern</span>=<span class="string">"/login.jsp"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">pattern</span>=<span class="string">"/failer.jsp"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">pattern</span>=<span class="string">"/css/**"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">pattern</span>=<span class="string">"/img/**"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">pattern</span>=<span class="string">"/plugins/**"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        配置具体的规则 </span></span><br><span class="line"><span class="comment">        auto-config="true"  不用自己编写登录的页面，框架提供默认登录页面</span></span><br><span class="line"><span class="comment">        use-expressions="false" 是否使用SPEL表达式（没学习过）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span> <span class="attr">use-expressions</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置具体的拦截的规则 pattern="请求路径的规则" access="访问系统的人，必须有ROLE_USER的角色" --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER,ROLE_ADMIN"</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 定义跳转的具体的页面 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">security:form-login</span>  </span></span><br><span class="line"><span class="tag">            <span class="attr">login-page</span>=<span class="string">"/login.jsp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">login-processing-url</span>=<span class="string">"/login.do"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">default-target-url</span>=<span class="string">"/index.jsp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">authentication-failure-url</span>=<span class="string">"/failer.jsp"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 关闭跨域请求 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">security:csrf</span> <span class="attr">disabled</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 退出 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">security:logout</span> <span class="attr">invalidate-session</span>=<span class="string">"true"</span> <span class="attr">logout-url</span>=<span class="string">"/logout.do"</span> <span class="attr">logout-success-url</span>=<span class="string">"/login.jsp"</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 切换成数据库中的用户名和密码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">security:authentication-provider</span> <span class="attr">user-service-ref</span>=<span class="string">"userService"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置加密的方式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">security:password-encoder</span> <span class="attr">ref</span>=<span class="string">"passwordEncoder"</span>/&gt;</span><span class="comment">&lt;!--这个要暂时先关闭，如果开启的话密码是加密的，如果数据库中不是加密的密码就不能登录--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置加密类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"passwordEncoder"</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 提供了入门的方式，在内存中存入用户名和密码 </span></span><br><span class="line"><span class="comment">    &lt;security:authentication-manager&gt;</span></span><br><span class="line"><span class="comment">        &lt;security:authentication-provider&gt;</span></span><br><span class="line"><span class="comment">            &lt;security:user-service&gt;</span></span><br><span class="line"><span class="comment">                &lt;security:user name="admin" password="&#123;noop&#125;admin" authorities="ROLE_USER"/&gt;</span></span><br><span class="line"><span class="comment">            &lt;/security:user-service&gt;</span></span><br><span class="line"><span class="comment">        &lt;/security:authentication-provider&gt;</span></span><br><span class="line"><span class="comment">    &lt;/security:authentication-manager&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    </span><br><span class="line"> <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>security的源码分析</p>
</li>
</ol>
<ul>
<li>为什么filterName必须是springSecurityChain，</li>
</ul>
<p>##权限控制</p>
<ol>
<li>之前的权限控制是基于security实现的，目的是排除非法用户进入系统，但是合法用户之间也有不同的权限级别，对应能够访问不同的url。这时就有服务器端的方法级别的权限控制和页面端的权限控制。<br>三种方法的使用都需要在配置文件中配置，并且SpringSecurity默认是禁用注解的，要想开启注解，需要在继承web SecurityConfigurerAdapter的类上加@EnableGlobalMethodSecurity注解，并在该类中将AuthenticcationMannager定义为Bean。<br>在security配置文件中写，<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span> <span class="attr">jsr250-annotations</span>=<span class="string">"enabled"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span> <span class="attr">secured-annotations</span>=<span class="string">"enabled"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span> <span class="attr">pre-post-annotations</span>=<span class="string">"disabled"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>服务器端的权限控制：</li>
</ol>
<ul>
<li>JSR250的使用：<br>有三个注解，@RolesAllowed(表示访问对应方法是应该有的角色),@PermitAll(允许所有角色访问),@DenyAll(禁止所有角色访问)。例如，@RolesAllowed(“ADMIN”),注意security框架中角色都是ROLE_ADMIN之类的，但是RoleAllowed默认帮我们加上了<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsr250-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>还要导入依赖才能使用</span><br></pre></td></tr></table></figure></li>
<li>支持表达式的注解：Spring Security允许我们在定义URL访问或方法访问所应有的权限时使用SpringEL表达式，在定义所需的访问权限时如果对应的表达式返回结果为true则表示拥有对应的权限，反之则无。SpringSecurity可用表达式对象的基类是SecurityExpressionRoot，其为我们提供了如下在使用Spring EL表达式对URL或方法进行权限控制时通用的内置表达式。<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>hasRole([role]) 当前用户是否拥有指定角色。</td>
<td></td>
</tr>
<tr>
<td>hasAnyRole([role1,role2])   多个角色是一个以逗号进行分隔的字符串。如果当前用户拥有指定角色中的任意一个则返回true。</td>
<td></td>
</tr>
<tr>
<td>hasAuthority([auth])    等同于hasRole</td>
<td></td>
</tr>
<tr>
<td>hasAnyAuthority([auth1,auth2])  等同于hasAnyRole</td>
<td></td>
</tr>
<tr>
<td>Principle   代表当前用户的principle对象</td>
<td></td>
</tr>
<tr>
<td>authentication  直接从SecurityContext获取的当前Authentication对象</td>
<td></td>
</tr>
<tr>
<td>permitAll   总是返回true，表示允许所有的</td>
<td></td>
</tr>
<tr>
<td>denyAll 总是返回false，表示拒绝所有的</td>
<td></td>
</tr>
<tr>
<td>isAnonymous()   当前用户是否是一个匿名用户</td>
<td></td>
</tr>
<tr>
<td>isRememberMe()  表示当前用户是否是通过Remember-Me自动登录的</td>
<td></td>
</tr>
<tr>
<td>isAuthenticated()   表示当前用户是否已经登录认证成功了。</td>
<td></td>
</tr>
<tr>
<td>isFullyAuthenticated()  如果当前用户既不是一个匿名用户，同时又不是通过Remember-Me自动登录的，则返回true。</td>
<td></td>
</tr>
<tr>
<td>@PreAuthorize(#userId == authentication.principal.userId or hasAuthority(‘ADMIN’))</td>
<td></td>
</tr>
<tr>
<td>void changePassword(“userId”) long userId){ }</td>
<td></td>
</tr>
<tr>
<td>这里表示在changePassword方法执行之前，判断方法参数userId的值是否等于principal中保存的当前用户的userId，或者当前用户是否具有ROLE_ADMIN权限，两种符合其一就可以进行访问。</td>
<td></td>
</tr>
<tr>
<td>@PosyAuthorize允许方法调用，但是如果表达式计算结果为false，则抛出一个安全性异常</td>
<td></td>
</tr>
<tr>
<td>@PostAuthorize</td>
<td></td>
</tr>
<tr>
<td>User getUser(“returnObject.userId == authentication.principal.userId or hasPermission(returnObject,”ADMIN”)”);</td>
<td></td>
</tr>
<tr>
<td>@PostFilter 允许方法调用，但是必须按照表达式来过滤方法的结果</td>
<td></td>
</tr>
<tr>
<td>@PreFilter 允许方法调用，但必须在进入方法之前过滤输入值。</td>
<td></td>
</tr>
</tbody></table>
</li>
<li>@Secured注解：&lt;security:global-method-security secured-annotations=”enabled”/&gt;,注意使用@secured时，要将角色名写全，例如@Security(“ROLE_ADMIN”)，这种是spring自身集成的，不需要再pom文件中导入，而jsr250需要在导入依赖。</li>
</ul>
<p>##ssm案例踩雷</p>
<ol>
<li><p>跳转到页面上就只有文字，没有样式，原来是没有导入相关css和plugins，但是导入之后仍然不行，发现是放在web-INF目录下的pages中了，怪不得访问不到webApp下的资源，修改之后，能正常访问了，但是数据并没有显示，只有el表达式，发现是jsp中isElIgnored忘开了，打开之后就能访问了。</p>
</li>
<li><p>maven启动不了，按照视频中的做法，在web模块的pom中加了tomcat插件，但是运行说找不到dao模块和service模块，仔细想想，原因就在maven启动的三种方式上面，视频中使用的是web模块启动，是子工程，就需要本地仓库中有这个jar包，但是我并没有install把其他模块打包到仓库，当然找不到，于是就使用了父工程的tomcat插件运行，成功了。</p>
</li>
<li><p>product里的图像总是显示不了，通过浏览器的调试工具找到是路径出错了，路径中间夹杂着el表达式，立马想到没有开el表达式，现在好像jsp已经默认关闭el表达式了。还有就是打开提供的页面，里面的jscss等等资源全部不能获得，这是因为路径写的错误了，它提供的页面里面${pageContext.request.contextpath}和后面的资源路径之间没有空格，资源请求不到。</p>
</li>
<li><p>保存用户时老出错，说id为null，因为平常都是设置主键自增长的，没有过多考虑主键的问题，但是这次因为主键使用了uuid，而我没有像视频中使用oracle数据库，我用的是mysql数据库，就没有设置uuid，但是网上搜到的设置uuid的方法不起作用，于是我还是使用主键自增的做法。修改主键自增之后果然能正常插入数据库了。</p>
</li>
<li><p>发现新增了一个保存方法之后总是报404，一开始以为是找不到controller方法，但是后来发现方向错了，因为我在save方法中打印执行了这句话，控制台也确实输出了，这就说明进入了save方法，但是为什么报404呢，接着注意到，我返回的是关键字(return “redircet:product/findAll”),猜测可能是重定向的路径写错了，但是重定向的请求路径应该生改变才对，为什么这个没有变呢，难道视图解析器的重定向和response的重定向不同？如果是这样，就说的通了，请求save方法并不是找不到save而是重定向的路径写错了，但是地址栏的路径却没有变化，导致我一度一位是找不到save方法，一开始方向就错了。原因找到了，是两个综合原因，一是我用的是mysql，没有使用主键uuid，插入失败，二是重定向路径错误，少加了一个/，应该是 return “redirect:/product/findAll”;，而我一开始product前面少了个/，怪不得找不到路径。</p>
</li>
<li><p>又出现了中文乱码问题，这次我数据库使用的是utf-8字符集，并且连接池中的url使用指定使用utf-8编码jdbc.url=jdbc:mysql://localhost:3306/ssm?useUnicode=true&amp;characterEncoding=UTF-8。甚至还配了过滤器，但是还是不行，后来上网查，找到了一篇文章，详细记录了各种解决办法，详情看<a href="https://www.cnblogs.com/jing58/p/6061323.html" target="_blank" rel="noopener">这里</a>,后来我把tomcat的server.xml文件中的connector加了个URIE=utf-8，终于成功了，可能是我这次使用的是tomcat插件的缘故把。</p>
</li>
<li><p>调整每页显示的数据数时，发现点击没有变化，在changePage函数中将获得的选中值alert出来，但是发现弹出的是空白，就是说没有获得选中的数据，这时想起来之前页遇到过相同的问题，查询<a href="https://blog.csdn.net/renzhenhuai/article/details/19569593" target="_blank" rel="noopener">这里</a>得知，获得下拉框中的选中值需要加上optioned选项</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">changePageSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//获取下拉框的值</span></span><br><span class="line">            <span class="keyword">var</span> pageSize = $(<span class="string">"#changePageSize option:selected"</span>).val();;</span><br><span class="line"></span><br><span class="line">            alert(pageSize)</span><br><span class="line">            <span class="comment">//向服务器发送请求，改变没页显示条数</span></span><br><span class="line">            location.href = <span class="string">"$&#123;pageContext.request.contextPath&#125;/orders/findAll?page=1&amp;size="</span>+pageSize;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加资源权限管理时发现只能添加权限控制但是添加不了url，调试后发现controller只能拿到权限控制，但是拿不到url的数据，也就是问题出在页面上，检查后发现时文本框的name属性是大写的URL，与实体类中的的url小写不相符，就封装不上，因为参数自动封装只有name属性和实体类中的数据名一样才能自动封装。</p>
</li>
<li><p>&lt;security:password-encoder ref=”passwordEncoder”/&gt;，这个没有关闭的话，密码就会被加密，和数据库中的密码匹配不上，就会无法登录。</p>
</li>
<li><p>dao中查询时发现报错，说找不到UserId参数，检查之后发现是在参数上少加了@Param注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Insert</span>(<span class="string">"insert into role_user(userId,roleId) values(#&#123;userId&#125;,#&#123;roleId&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addRoleToUser</span><span class="params">(@Param(<span class="string">"userId"</span>)</span> Integer userId, @<span class="title">Param</span><span class="params">(<span class="string">"roleId"</span>)</span> Integer roleId)</span>;</span><br><span class="line">    <span class="comment">//因为不加@Param就是表明从传入的对象中取出叫userId的属性，而不是参数userId。</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JAVAWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVAWeb</title>
    <url>/2020/04/24/JAVAWeb/</url>
    <content><![CDATA[<h1 id="MVC框架设计"><a href="#MVC框架设计" class="headerlink" title="MVC框架设计"></a>MVC框架设计</h1><ol>
<li>MVC是一种用MVC(module-view-controller)设计创建web应用程序的模式</li>
<li><ul>
<li>M(module)模型表示程序的核心，例如表的各种操作</li>
<li>V(view)视图显示数据，例如在html上显示表的各种数据</li>
<li>C(controller)控制器控制输入和view与module之间的交互，例如将页面数据写入数据库<br>Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。<br>　　通常模型对象负责在数据库中存取数据。<br>View（视图）是应用程序中处理数据显示的部分。<br>　　通常视图是依据模型数据创建的。<br>Controller（控制器）是应用程序中处理用户交互的部分。<br>　　通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。<br><img src="/2020/04/24/JAVAWeb/MVC.jpg" alt></li>
</ul>
</li>
</ol>
<h1 id="网站案例结构"><a href="#网站案例结构" class="headerlink" title="网站案例结构"></a>网站案例结构</h1><ol>
<li>Web层：<br> a.servlet:前端控制器，用于控制前端页面和用户的交互。<br> b.html：视图层，用来展示相关内容，面向普通用户，如果面向内部人员，常常使用jsp展示<br> c.Jackson：json，因为html不能直接显示后端的数据，需要将数据序列化之后才能展示<br> d.BeanUtils：数据封装<br> e.Filter：用于向服务器发送请求之前进行的统一操作，例如统一字符集</li>
<li>Service层：<br> a.javamail：Java发送邮件的工具<br> b.redis：nosql数据库，提升查询效率<br> c.jedis：java的redis客户端</li>
<li>Dao层：<br> a.Mysql：数据库<br> b.Druid:数据池，提升效率<br> c.jdbc Template:jdbc的工具类</li>
<li>DAO负责一些底层操作，例如表的增删改查，并且一张表对应一个DAO，service相当于业务逻辑，就像行动大纲，列出流程，调用DAO的方法完成某一个功能，Servlet相当于控制器，用户页面的交互，例如将表中的数据读取出来写到页面上，或者将表单中的数据写回到表中。</li>
</ol>
<h1 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h1><h2 id="注册功能"><a href="#注册功能" class="headerlink" title="注册功能"></a>注册功能</h2><p>知识点：JQuery，<br><img src="/2020/04/24/JAVAWeb/regist.png" alt></p>
<h3 id="前台效果-V层"><a href="#前台效果-V层" class="headerlink" title="前台效果(V层)"></a>前台效果(V层)</h3><ol>
<li>表单校验：验证用户输入的数据是否符合要求，用Jquery中的正则表达式来约束，在写表单校验的时候，最后调用blur的时候，写函数名不需要加括号，<br>否则输入框会一直变红，无法消去。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">//当提交表单时校验所有输入</span><br><span class="line">$(&quot;#registerForm&quot;).submit(function()&#123;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;)</span><br><span class="line">//当鼠标离开某个输入框框时，就进行校验</span><br><span class="line">$(&quot;#username&quot;).blur(function(&#123;</span><br><span class="line">		checkusername();</span><br><span class="line">	&#125;))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>用户名：单词字符，8到20位<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">function checkUsername() &#123;</span><br><span class="line">            //单词字符，8到20位</span><br><span class="line">            //1. 获取用户名</span><br><span class="line">           var username= $("#username").val();</span><br><span class="line">           //定义正则表达式</span><br><span class="line">           var red_username = /^\w&#123;8,20&#125;$/;</span><br><span class="line">           //判断是否符合</span><br><span class="line">           var flag= red_username.test(username);</span><br><span class="line">           //如果正确就将原来的红边框消去</span><br><span class="line">           if (flag)&#123;</span><br><span class="line">               $("#username").css("border","");</span><br><span class="line">           &#125;else &#123;//如果不符合，就弹出红边框</span><br><span class="line">                $("#username").css("border","1px solid red");</span><br><span class="line">           &#125;</span><br><span class="line">           return flag;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li>密码：单词字符，8到20位<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var red_username = /^\w&#123;8,20&#125;$/;</span><br></pre></td></tr></table></figure></li>
<li>email：邮件格式<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var reg_email = /^\w+@\w+\.\w+$/;</span><br></pre></td></tr></table></figure></li>
<li>姓名：非空<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var reg_name= /^\s*$/g;</span><br></pre></td></tr></table></figure></li>
<li>手机号：11位<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/^1(?:3\d|4[4-9]|5[0-35-9]|6[67]|7[013-8]|8\d|9\d)\d&#123;8&#125;$/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>要将jquery放在js文件夹下，浏览器才能接受到jquery资源</li>
<li>正则表达式，常常用来规定数据的输入格式，用于表单校验</li>
</ol>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\”匹配“\”而“(”则匹配“(”。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。例如，zo<em>能匹配“z”以及“zoo”。</em>等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td>
</tr>
<tr>
<td>?</td>
<td>当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.</td>
</tr>
<tr>
<td>(pattern)</td>
<td>匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”</td>
</tr>
<tr>
<td>(?:pattern)</td>
<td>匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(</td>
</tr>
<tr>
<td>(?=pattern)</td>
<td>正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95</td>
</tr>
<tr>
<td>(?!pattern)</td>
<td>正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95</td>
</tr>
<tr>
<td>(?&lt;=pattern)</td>
<td>反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?&lt;=95</td>
</tr>
<tr>
<td>(?&lt;!pattern)</td>
<td>反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?&lt;!95</td>
</tr>
<tr>
<td>x&#124;y</td>
<td>匹配x或y。例如，“z</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。</td>
</tr>
<tr>
<td>[a-z]</td>
<td>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。</td>
</tr>
<tr>
<td>[^a-z]</td>
<td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</td>
</tr>
<tr>
<td>\cx</td>
<td>匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字字符。等价于[0-9]。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符。等价于[^0-9]。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。等价于\x0c和\cL。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。等价于\x0a和\cJ。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等价于\x0d和\cM。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。等价于\x09和\cI。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。等价于\x0b和\cK。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</td>
</tr>
<tr>
<td>\xn</td>
<td>匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。.</td>
</tr>
<tr>
<td>\num</td>
<td>匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td>\n</td>
<td>标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。</td>
</tr>
<tr>
<td>\nm</td>
<td>标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。</td>
</tr>
<tr>
<td>\nml</td>
<td>如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。</td>
</tr>
<tr>
<td>\un</td>
<td>匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>常用正则表达式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>用户名</td>
<td>/^[a-z0-9_-]{3,16}$/</td>
</tr>
<tr>
<td>密码</td>
<td>/^[a-z0-9_-]{6,18}$/</td>
</tr>
<tr>
<td>十六进制值</td>
<td>/^#?([a-f0-9]{6}</td>
</tr>
<tr>
<td>电子邮箱</td>
<td>/^([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})$/</td>
</tr>
<tr>
<td>/^[a-z\d]+(.[a-z\d]+)*@(<a href="-[\da-z]">\da-z</a>?)+(.{1,2}[a-z]+)+$/</td>
<td></td>
</tr>
<tr>
<td>URL</td>
<td>/^(https?://)?([\da-z.-]+).([a-z.]{2,6})([/\w .-]<em>)</em>/?$/</td>
</tr>
<tr>
<td>IP 地址</td>
<td>/((2[0-4]\d</td>
</tr>
<tr>
<td>/^(?:(?:25[0-5]</td>
<td>2[0-4][0-9]</td>
</tr>
<tr>
<td>HTML 标签</td>
<td>/^&lt;([a-z]+)([^&lt;]+)<em>(?:&gt;(.</em>)&lt;/\1&gt;</td>
</tr>
<tr>
<td>删除代码\注释</td>
<td>(?&lt;!http:</td>
</tr>
<tr>
<td>Unicode编码中的汉字范围</td>
<td>/^[\u2E80-\u9FFF]+$/</td>
</tr>
</tbody></table>
<ol start="4">
<li><p>js:JavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的。<br>是一种解释性脚本语言（代码不进行预编译）。<br>主要用来向HTML（标准通用标记语言下的一个应用）页面添加交互行为。]<br>可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。<br>跨平台特性，在绝大多数浏览器的支持下，可以在多种平台下运行（如Windows、Linux、Mac、Android、iOS等）。<br>Javascript脚本语言同其他语言一样，有它自身的基本数据类型，表达式和算术运算符及程序的基本程序框架。Javascript提供了四种基本的数据类型和两种特殊数据类型用来处理数据和文字。而变量提供存放信息的地方，表达式则可以完成较复杂的信息处理。<br>可以实现web页面的人机交互。<br>日常用途编辑<br>嵌入动态文本于HTML页面。<br>对浏览器事件做出响应。<br>读写HTML元素。<br>在数据被提交到服务器之前验证数据。<br>检测访客的浏览器信息。<br>控制cookies，包括创建和修改等。<br>基于Node.js技术进行服务器端编程。</p>
</li>
<li><p>Ajax 即“Asynchronous JavascriptAndXML”（异步JavaScript和XML），是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$.post("registUserServlet",$(this).serialize(),function (data) &#123;</span><br></pre></td></tr></table></figure>
<p>serialize是序列化函数，能将表单的数据转为键值对形式的数据<br>在这里使用Ajax是因为前端使用的是html作为视图层，不能直接获取到服务器的数据，要用Ajax的方式获取数据</p>
</li>
<li><p>注册页面的编写，可以大致将页面分为三个部分，头部，注册表单，尾部，其中头部和尾部可以分别编写html文件，再在regist中引用。登录，注册等按钮的功能可以使用href超链接，转到响应的功能页面，进行相关的操作。</p>
</li>
<li><p>session:Session 是 用于保持状态的基于Web服务器的方法。Session允许通过将对象存储在Web服务器的内存中在整个用户会话过程中保持任何对象。<br>Session通常用于执行以下操作<br>存储需要在整个用户会话过程中保持其状态的信息，例如登录信息或用户浏览Web应用程序时需要的其它信息。<br>存储只需要在页面重新加载过程中或按功能分组的一组页之间保持其状态的对象。<br>Session的作用就是它在Web服务器上保持用户的状态信息供在任何时间从任何设备上的页面进行访问。因为浏览器不需要存储任何这种信息，所以可以使用任何浏览器，即使是像Pad或手机这样的浏览器设备。这里用session来验证验证码</p>
</li>
</ol>
<h3 id="后台处理"><a href="#后台处理" class="headerlink" title="后台处理"></a>后台处理</h3><ol>
<li>Servlet:</li>
</ol>
<h2 id="用到的技术"><a href="#用到的技术" class="headerlink" title="用到的技术"></a>用到的技术</h2><ol>
<li><a href="#Jquery">Jquery</a></li>
<li><a href="#Ajax">Ajax</a></li>
<li><a href="#Servlet">Servlet</a></li>
</ol>
<h1 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML的DOM操作、事件处理、动画设计和Ajax交互。本质上是将一些JavaScript的重复操作进行封装，供用户调用。</p>
<h2 id="使用前要将jquery-3-3-1-min-js导入到项目中。"><a href="#使用前要将jquery-3-3-1-min-js导入到项目中。" class="headerlink" title="使用前要将jquery-3.3.1.min.js导入到项目中。"></a>使用前要将jquery-3.3.1.min.js导入到项目中。</h2><h2 id="JQuery对象和js对象的互相转换"><a href="#JQuery对象和js对象的互相转换" class="headerlink" title="JQuery对象和js对象的互相转换"></a>JQuery对象和js对象的互相转换</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="comment">//js</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElemByTagName(<span class="string">"div"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">//jquery</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> $divs = $(<span class="string">"div"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">//将两者的内容替换为“aaa”</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;divs.lenght;i++)&#123;</span></span><br><span class="line"><span class="actionscript">	divs[i].innerHtml(<span class="string">"aaa"</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="actionscript"><span class="comment">//jquery</span></span></span><br><span class="line"><span class="javascript">$(<span class="string">"div"</span>).html(<span class="string">"aaa"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">//由此可见，jquery的方法简便许多，而js的方法重复性非常高，但是jquery方法只能由jquery对象使用，js无法使用，所以就需要两者之间的转换</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">//js--&gt;jquery</span></span></span><br><span class="line"><span class="javascript">$(js对象)</span></span><br><span class="line"><span class="actionscript"><span class="comment">//jquery--&gt;js</span></span></span><br><span class="line">jq对象.get(索引)或者jq对象[索引]</span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">//上面两行代码可以改写为</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">//js--&gt;jquery</span></span></span><br><span class="line"><span class="javascript">$(divs).html(<span class="string">"aaa"</span>);</span></span><br><span class="line"><span class="actionscript"><span class="comment">//jquery--&gt;js</span></span></span><br><span class="line"><span class="actionscript">$divs.get[<span class="number">0</span>].innerHtml(<span class="string">"aaa"</span>);</span></span><br><span class="line"><span class="actionscript">$divs[<span class="number">0</span>].innerHtml(<span class="string">"aaa"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>1.</p>
<ul>
<li>事件绑定：在方法中内嵌一个function对象。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$("#id").click(function()&#123;</span><br><span class="line">	alert("adfa");</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>入口函数：等页面加载完成后再进入入口函数的内容，=window.onload()<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line"></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
两者的区别是onload只能绑定一次，而$可以绑定多次</li>
<li>样式控制：就是通过.css方法修改元素的css样式<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">	$("#id"),css("background","red");</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ol start="2">
<li><p><a href="https://www.runoob.com/jquery/jquery-ref-selectors.html" target="_blank" rel="noopener">选择器语法</a></p>
</li>
<li><p>分类：（具体语法在上面的超链接中）</p>
</li>
</ol>
<ul>
<li><p>基本选择器：<br>标签选择器：$(“html标签名”),获得所有匹配标签名的元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$("div")获取当前页面中的所有div元素</span><br></pre></td></tr></table></figure>
<p>id选择器：$(“#id名”)，获得所有匹配id的元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$("#btn")获取所有id值为btn的元素</span><br></pre></td></tr></table></figure>
<p>类选择器：$(“.类的属性值”)，获得所有匹配类名的元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$(".hanahn")获得所有类的属性值与hanahn匹配的元素</span><br></pre></td></tr></table></figure>
<p>中间加个逗号就可以选择多个条件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$("#two,span")//选择id=two和span内的所有元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>层级选择器：<br>后代选择器：$(“A B”),获得A中的所有B元素，相当获取儿子辈和孙子辈的所有元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$("body span")获得body里的所有span元素</span><br></pre></td></tr></table></figure>
<p>子选择器：$(“A &gt; B”)，获得A中的所有B子元素，相当只获取儿子辈的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$("body &gt; span"),获得body里的儿子级别的span元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性选择器：<br>属性名称选择器：选择指定属性名且含有名叫XX属性的元素，属性值不管</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$("div[color]").css选择div元素，且div元素中有属性叫color的元素</span><br></pre></td></tr></table></figure>
<p>属性选择器：选择指定属性=指定值的元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$("div[color='red']")获得div元素，且元素的color属性=red的元素</span><br></pre></td></tr></table></figure>
<p>属性复合选择器：包含多个属性条件的元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$("div[color='red'][display]")，获得div元素，且满足color=red&amp;&amp;有display属性的元素</span><br><span class="line">此外还有类似正则的写法</span><br><span class="line">$("div[color!='red']")，获得div元素，且满足color不等于red的元素</span><br><span class="line">$("div[color^='r']")，获得div元素，且满足color的开头=r的元素</span><br><span class="line">$("div[color$='d']")，获得div元素，且满足color的结尾=d的元素</span><br><span class="line">$("div[color*='d']")，获得div元素，且满足color的内容含有d的元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤选择器：<br>首元素选择器： A:first 获得选择元素的第一个元素<br>尾元素选择器： A:last 获得选择元素的最后一个元素<br>非元素选择器： A:not(条件) 不包括指定内容的元素，条件也是用选择器语法写的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$("div:not(.one)")//选择class！=one的元素</span><br></pre></td></tr></table></figure>
<p>偶数选择器： A:even 从0计数<br>奇数选择器： A:odd 从0计数<br>等于索引选择器：A:eq(index) 等于指定索引的元素<br>大于索引选择器： A:gt(index) 大于指定索引的元素<br>等于索引选择器： A:lt(index) 小于指定索引的元素<br>标题选择器: header () 获得标题为(h1~h6)的元素</p>
</li>
<li><p>表单过滤选择器<br>可用元素选择器： :enabled 获得可用元素<br>不可用元素选择器： :disabled 获得不可用元素<br>选中选择器： :checked 获得单选/复选框中的元素<br>选中选择器： selected 获得下拉框中的元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> 注意下拉框选中的个数要获取select的子元素，option才能获取选中个数</span><br><span class="line">$("#b4").click(function () &#123;</span><br><span class="line">				alert($("select[name='job'] &gt; option:selected").length);</span><br><span class="line"></span><br><span class="line">			&#125;)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ol start="4">
<li>DOM操作<ul>
<li>内容操作：val获取值，text获取纯文本，html获取标签之间的内容<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$(function () &#123;</span><br><span class="line">       var value = $("#myInput").val();//val获取value值</span><br><span class="line">       alert(value);</span><br><span class="line">       var html = $("#myDiv").html();//获取div间的所有元素，不止包括纯文本和标签</span><br><span class="line">       alert(html);</span><br><span class="line">        // var html = $("#myDiv").html("aaaa");//获取div间的所有元素，还可以更改标签内的内容，甚至可以写新标签</span><br><span class="line">        var text = $("#myDiv").text();</span><br><span class="line">        document.write(text);//获取div间的纯文本，不包括标签</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li>
<li>属性操作：attr获取/设置值，removeAttr删除属性，prop获取/设置值，removeProp删除属性,attr和prop区别，如果是操作的标签的固有属性，用prop，用的是自定义属性，用attr<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$(function () &#123;</span><br><span class="line">        var name = $("#bj").attr("name");</span><br><span class="line">        alert(name);</span><br><span class="line">       $("#bj").attr("name","北京");</span><br><span class="line">        var name1 = $("#bj").attr("name");</span><br><span class="line">            alert(name1);</span><br><span class="line">        $("#bj").attr("discription","帝都");</span><br><span class="line">        $("#bj").removeAttr("discription");</span><br><span class="line">        var check= $("#hobby").prop("checked");</span><br><span class="line">        alert(check);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li>
<li>class属性操作：addclass，增加属性，removeclass，删除属性，toggleclass如果有这个属性存在就删除，没有就创建。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$(function () &#123;</span><br><span class="line">		    	//<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"采用属性增加样式(改变id=one的样式)"</span>  <span class="attr">id</span>=<span class="string">"b1"</span>/&gt;</span></span><br><span class="line">			$("#b1").click(function () &#123;</span><br><span class="line">				$("#one").prop("class","second");</span><br><span class="line">			&#125;)</span><br><span class="line">			//<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"采用属性增加样式(改变id=one的样式)"</span>  <span class="attr">id</span>=<span class="string">"b1"</span>/&gt;</span></span><br><span class="line">			$("#b2").click(function () &#123;</span><br><span class="line">				$("#one").addClass("second");</span><br><span class="line">			&#125;)</span><br><span class="line">			//<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"removeClass"</span>  <span class="attr">id</span>=<span class="string">"b3"</span>/&gt;</span></span><br><span class="line">			$("#b3").click(function () &#123;</span><br><span class="line">				$("#one").removeClass("second");</span><br><span class="line">			&#125;)</span><br><span class="line">			//<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">" 切换样式"</span>  <span class="attr">id</span>=<span class="string">"b4"</span>/&gt;</span></span><br><span class="line">			$("#b4").click(function () &#123;</span><br><span class="line">				$("#one").toggleClass("second");</span><br><span class="line">			&#125;)</span><br><span class="line">			//<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">" 通过css()获得id为one背景颜色"</span>  <span class="attr">id</span>=<span class="string">"b5"</span>/&gt;</span></span><br><span class="line">			$("#b5").click(function () &#123;</span><br><span class="line">				$("#one").css("backgroundColor");//一个参数是获取对应的值，两个是设置参数的值</span><br><span class="line">			&#125;)</span><br><span class="line">			//	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">" 通过css()设置id为one背景颜色为绿色"</span>  <span class="attr">id</span>=<span class="string">"b6"</span>/&gt;</span></span><br><span class="line">			$("#b6").click(function () &#123;</span><br><span class="line">				$("#one").css("background","green");</span><br><span class="line">			&#125;)</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li>
<li>CRUD：append和prepend元素是父子关系，before和after元素是兄弟关系。remove删除元素，empty清空元素<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$(function () &#123;</span><br><span class="line">		 // <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"将反恐放置到city的后面"</span>  <span class="attr">id</span>=<span class="string">"b1"</span>/&gt;</span></span><br><span class="line">			 $("#b1").click(function () &#123;//append和prepend元素是父子关系</span><br><span class="line">			 	//append,将对象2放在对象1的后面</span><br><span class="line">				//  $("#city").append($("#fk"));</span><br><span class="line">				 //appendTo,将对象1放在对象2后面</span><br><span class="line">				 // $("#fk").appendTo($("#city"))</span><br><span class="line">			 &#125;)</span><br><span class="line">			 // <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"将反恐放置到city的最前面"</span>  <span class="attr">id</span>=<span class="string">"b2"</span>/&gt;</span></span><br><span class="line">			 //prepend</span><br><span class="line">			 // $("#b2").click(function () &#123;</span><br><span class="line">			 // 	$("#city").prepend($("#fk"));</span><br><span class="line">			 // &#125;)</span><br><span class="line">			 //prependTo</span><br><span class="line">			 // $("#b2").click(function () &#123;</span><br><span class="line">			 // 	$("#fk").prependTo($("#city"));</span><br><span class="line">			 // &#125;)</span><br><span class="line">			 // <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"将反恐插入到天津后面"</span>  <span class="attr">id</span>=<span class="string">"b3"</span>/&gt;</span></span><br><span class="line">			 //insert和after元素是兄弟关系</span><br><span class="line">			 //after</span><br><span class="line">			 // $("#b3").click(function () &#123;</span><br><span class="line">			 // 	$("#tj").after($("#fk"));</span><br><span class="line">			 // &#125;)</span><br><span class="line">			 //insertAfter</span><br><span class="line">			 // $("#b3").click(function () &#123;</span><br><span class="line">				//  $("#fk").insertAfter($("#tj"));</span><br><span class="line">			 // &#125;)</span><br><span class="line">			 // <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"将反恐插入到天津前面"</span>  <span class="attr">id</span>=<span class="string">"b4"</span>/&gt;</span></span><br><span class="line">			 //before和insertBefore即可</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<p>##动画和遍历</p>
<ol>
<li>动画的三种隐藏方式</li>
</ol>
<ul>
<li>默认显示和隐藏元素<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">speed有三种默认值，fast，slow，normal，或者自定义毫秒数，控制动画的速度</span><br><span class="line">easing swing linear swing是先慢再快在慢 linear就是线性匀速的</span><br><span class="line">fn是动画完成时执行的函数，每个元素执行一次</span><br><span class="line">show(speed,easing,fn)</span><br><span class="line">hide(speed,easing,fn)</span><br><span class="line">toggle(speed,easing,fn)</span><br></pre></td></tr></table></figure></li>
<li>滑动显示和隐藏<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">slideDown(speed,easing,fn)</span><br><span class="line">slideUp(speed,easing,fn)</span><br><span class="line">slideToggle(speed,easing,fn)</span><br></pre></td></tr></table></figure></li>
<li>淡入淡出显示和隐藏<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">fadeIn(speed,easing,fn)</span><br><span class="line">fadeOut(speed,easing,fn)</span><br><span class="line">fadeToggle(speed,easing,fn)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>遍历</li>
</ol>
<ul>
<li>js的遍历<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">for(初始值，条件；自增长度)</span><br><span class="line">//js的遍历方式</span><br><span class="line">                //首先拿到ul下的所有值，用选择器，并存放到数组中去</span><br><span class="line">                var cities = $("#city li");//返回的对象相当于数组，可以使用下标</span><br><span class="line">               //  for (var i=0;i<span class="tag">&lt;<span class="name">cities.length;i++)&#123;</span></span></span><br><span class="line"><span class="tag">               //      <span class="attr">alert</span>(<span class="attr">cities</span>[<span class="attr">i</span>]<span class="attr">.innerHTML</span>);</span></span><br><span class="line"><span class="tag">               //  &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">                //<span class="attr">1.</span> <span class="attr">jq</span>对象<span class="attr">.each</span>(<span class="attr">callback</span>)<span class="attr">callback</span>是回调函数</span></span><br><span class="line"><span class="tag">                // $("#<span class="attr">city</span> <span class="attr">li</span>")<span class="attr">.each</span>(<span class="attr">function</span> (<span class="attr">index</span>,<span class="attr">element</span>) &#123;//可以在回调函数里定义相关操作</span></span><br><span class="line"><span class="tag">                //     // <span class="attr">alert</span>(<span class="attr">this.innerHTML</span>);//<span class="attr">this</span>表示当前对象</span></span><br><span class="line"><span class="tag">                //     //如果想要获取索引值，可以在函数参数列表中加入参数</span></span><br><span class="line"><span class="tag">                //     //<span class="attr">2.</span>还可以定义为<span class="attr">jq</span>对象可以调用更多的方法</span></span><br><span class="line"><span class="tag">                //     <span class="attr">alert</span>($(<span class="attr">element</span>)<span class="attr">.html</span>()+<span class="attr">index</span>);</span></span><br><span class="line"><span class="tag">                // &#125;)</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">                //$<span class="attr">.each</span></span></span><br><span class="line"><span class="tag">                // $<span class="attr">.each</span>(<span class="attr">cities</span>,<span class="attr">function</span> () &#123;//首先要获取要遍历的对象</span></span><br><span class="line"><span class="tag">                //     <span class="attr">alert</span>($(<span class="attr">this</span>)<span class="attr">.html</span>());</span></span><br><span class="line"><span class="tag">                // &#125;)</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">                //<span class="attr">for</span>方式</span></span><br><span class="line"><span class="tag">                <span class="attr">for</span> (<span class="attr">li</span> <span class="attr">of</span> <span class="attr">cities</span>)&#123;//同上，也要先定义遍历对象</span></span><br><span class="line"><span class="tag">                    <span class="attr">alert</span>($(<span class="attr">li</span>)<span class="attr">.html</span>());</span></span><br><span class="line"><span class="tag">                &#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>##事件绑定</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//标准绑定</span><br><span class="line">jq对象.事件方法(回调函数)</span><br><span class="line">//链式编程，简化一个标签绑定多个操作的书写</span><br><span class="line">           //  $("#name").mouseover(function () &#123;</span><br><span class="line">            //      alert("来了");</span><br><span class="line">            //  &#125;).mouseout(function () &#123;</span><br><span class="line">            //      alert("zoule");</span><br><span class="line">            //  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//onoff绑定</span><br><span class="line">jq对象.on("事件名称"，回调函数)</span><br><span class="line">jq对象.off("事件名称"，回调函数)</span><br><span class="line"></span><br><span class="line">$("#btn3").toggle(function () &#123;//1.9之后的版本是步支持toggle方法的，可以添加插件来解决jquery-migrate-1.0.0.js</span><br><span class="line">                $("#div").css("backgroundColor","pink");</span><br><span class="line">            &#125;,function () &#123;</span><br><span class="line">                $("#div").css("backgroundColor","green");</span><br><span class="line">            &#125;);</span><br><span class="line">//事件切换</span><br><span class="line">jq对象.toggle(fn1,fn2)</span><br></pre></td></tr></table></figure>



<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><ol>
<li><p>原生js实现ajax</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">function fun() &#123;</span><br><span class="line">        var xmlHttp;</span><br><span class="line">        if (window.XMLHttpRequest)&#123;</span><br><span class="line">            //code for IE7+,chrome, firefox,Safari</span><br><span class="line">            xmlHttp = new XMLHttpRequest();</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            //code for IE6 IE5</span><br><span class="line">            xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");</span><br><span class="line">        &#125;</span><br><span class="line">        //建立连接</span><br><span class="line">        /*</span><br><span class="line">        * 第一个参数是请求方法</span><br><span class="line">        *       get方法参数在URL的后面，send为空</span><br><span class="line">        *       post方法参数在send方法里面</span><br><span class="line">        * 第二个是请求URL</span><br><span class="line">        * 第三个是同步或异步请求（true是异步，false是同步）</span><br><span class="line">        * */</span><br><span class="line">        xmlHttp.open("GET","AJAXServlet?username=delisha",true);</span><br><span class="line"></span><br><span class="line">        //发送请求</span><br><span class="line">        xmlHttp.send();</span><br><span class="line"></span><br><span class="line">        //接受并处理来自服务器的响应</span><br><span class="line">        //获取方式，xmlHTTP.responseText</span><br><span class="line">        //当服务器响应之后获取</span><br><span class="line"></span><br><span class="line">        xmlHttp.onreadystatechange=function () &#123;</span><br><span class="line">            if (xmlHttp.readyState==4 &amp;&amp; xmlHttp.status==200)&#123;</span><br><span class="line">                //获取服务器的响应结果</span><br><span class="line">                var responseText = xmlHttp.responseText;</span><br><span class="line">                alert(responseText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Jquery实现，jQuery有三种，分别是$.ajax $.GET $POST</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;//只要记住几个常用的参数即可，每个参数之间要用逗号分割，最后一个不需要加逗号</span><br><span class="line">	url:"ajaxServlet",   //请求路径</span><br><span class="line">	type:"POST",    //不写默认是GET</span><br><span class="line">	data:"username=jaxck&amp;password=a",   //请求参数</span><br><span class="line">	//还有一种写法，推荐使用第二种，类似json的键值对</span><br><span class="line">	data:&#123;"username":"jaxck","password":"a"&#125;</span><br><span class="line">	success:function(data)&#123;//data是变量，用来接受服务器返回的数据，即json、</span><br><span class="line">		alert(data.flag);</span><br><span class="line">	&#125;,</span><br><span class="line">	error:function()&#123;//响应出错时执行的操作</span><br><span class="line">		alert("error!")</span><br><span class="line">	&#125;,</span><br><span class="line">	dataType:"json"  //指定服务器返回的数据类型</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$.GET(url,&#123;data&#125;,function()&#123;&#125;,type)</span><br><span class="line">//url,请求路径</span><br><span class="line">//data，请求参数,格式时&#123;username:"jack"&#125;</span><br><span class="line">//function，回调函数</span><br><span class="line">//type，返回数据类型	</span><br><span class="line"></span><br><span class="line">POST只要把GET改以下即可，其他参数一样</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>#Json</p>
<h2 id="概念：JavaScript-object-notation-JavaScript对象表示法-，作用类似于Java中的实体类，用来封装数据的。现在多用于存储和交换信息，类似xml，但比xml更小，更快，更易解析"><a href="#概念：JavaScript-object-notation-JavaScript对象表示法-，作用类似于Java中的实体类，用来封装数据的。现在多用于存储和交换信息，类似xml，但比xml更小，更快，更易解析" class="headerlink" title="概念：JavaScript object notation(JavaScript对象表示法)，作用类似于Java中的实体类，用来封装数据的。现在多用于存储和交换信息，类似xml，但比xml更小，更快，更易解析"></a>概念：JavaScript object notation(JavaScript对象表示法)，作用类似于Java中的实体类，用来封装数据的。现在多用于存储和交换信息，类似xml，但比xml更小，更快，更易解析</h2><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol>
<li>基本规则，数据在名称/值对中（名称和值都用引号括起来），数据由逗号分割，花括号保存对象，方括号保存数组<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取值类型由以下几种</span></span><br><span class="line">数字：整数或浮点数</span><br><span class="line">字符串：在双引号中</span><br><span class="line">逻辑值：true或者false</span><br><span class="line">数组：用方括号 &#123;"provience":[&#123;&#125;,&#123;&#125;]&#125;</span><br><span class="line">对象：用花括号  &#123;"China":&#123;"provience":"jiangsu","asfd":"dsaf"&#125;&#125;</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>##json数据的获取</p>
<ol>
<li>json对象.键名</li>
<li>json对象[“键名”]</li>
<li>数组对象[]</li>
</ol>
<p>##json和Java对象的互相转换</p>
<ol>
<li>在服务器和浏览器之间需要一个数据交换的载体，就是json，但是服务器如果用Java语言编写，就不能解析json数据，因为json是js的，得通过Jackson转为实体类，在通过Dao与数据库之间相互交换数据</li>
<li>Java转JSON<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.建立实体类</span></span><br><span class="line">Person p = new Person();</span><br><span class="line"><span class="comment">//2.赋值</span></span><br><span class="line">p.setName("hanahn");</span><br><span class="line"><span class="comment">//3.转换方法</span></span><br><span class="line"><span class="comment">//3.1创建核心类</span></span><br><span class="line">ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line">objectMapper.write(参数1, obj)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数1：</span></span><br><span class="line"><span class="comment">	File：将obj转为字符串，并写入到文件中</span></span><br><span class="line"><span class="comment">	Writer：将obj转为字符串，并写入到字符输出流中</span></span><br><span class="line"><span class="comment">	OutPutStream：将obj转为字符串，并写入到字节输出流中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">objectMapper.writeValueAsString(obj)</span><br><span class="line"><span class="comment">//将对象转为json字符串</span></span><br></pre></td></tr></table></figure></li>
<li>注解(要在实体类中的属性上加注解)</li>
</ol>
<ul>
<li>@JsonIgnore:在json字符串中忽略该属性<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">   privat eint age;</span><br><span class="line">   <span class="keyword">private</span> String gender;</span><br><span class="line">   <span class="comment">//@JsonIgnore//忽略该字符串</span></span><br><span class="line">   <span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">   <span class="keyword">private</span> Date brithday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>@JsonFormat:给该属性指定格式</li>
</ul>
<ol start="4">
<li>json转java：和Java转json差不多，只是最后的方法是readvalue(json,class);<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String json = <span class="string">""</span>;<span class="comment">//json格式书写</span></span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">objectMapper.readValue(json,Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h1 id="navicat常用快捷键"><a href="#navicat常用快捷键" class="headerlink" title="navicat常用快捷键"></a>navicat常用快捷键</h1><p>ctrl+q 打开查询窗口<br>ctrl+/ 注释<br>ctrl +shift+/ 解除注释<br>ctrl+r 运行选中的SQL语句<br>ctrl+l 删除选中行内容<br>ctrl+d 复制当前行内容并粘贴到下一行<br>ctrl+w 关闭当前查询窗口</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol>
<li>在使用导入的项目时，要重新写配置文件，更改数据库名称</li>
<li>在启动服务器前，要将JDBCUtils中的配置文件路径前面的/去掉，不然服务器会报错找不到配置文件<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties");</span><br></pre></td></tr></table></figure>







</li>
</ol>
<h2 id="后台代码"><a href="#后台代码" class="headerlink" title="后台代码"></a>后台代码</h2><ol>
<li>编写RegisetUser，UserService，Userservicelmpl，UserDao，UserDaolmpl</li>
<li>使用@webservelt替代xml注解时，会报错，因为没有导包，需要的包是javax.servlet.annotation.WebServlet，并且<version>3.0-alpha-1</version>servlet包必须是3.0以上版本才支持，最后重要的是还必须得导入tomcat得依赖包方法如下:</li>
</ol>
<ul>
<li>打开项目结构<br><img src="/2020/04/24/JAVAWeb/servlet.png" alt></li>
<li>点击模块右边的+号<br><img src="/2020/04/24/JAVAWeb/servlet1.png" alt></li>
<li>选择第二个库，然后选择tomcat即可<br><img src="/2020/04/24/JAVAWeb/servlet2.png" alt></li>
</ul>
<ol start="3">
<li>编写过滤器，统一字符编码</li>
<li>json的定义</li>
<li>项目启动失败的原因是没有导入tomcat的插件，导致一直启动失败。</li>
<li>直接导入的项目里的tomcat插件不能下载，从网上又找了一个插件<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">path</span>&gt;</span>/travel<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>##JDBC</p>
<ol>
<li>JDBCUtils工具类的编写简化数据库相关操作</li>
<li>JDBC Template：JDBC的封装</li>
<li>druid时区错误，加上一段代码即可<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">url=jdbc:mysql://127.0.0.1:3306/valkyries?serverTimezone=GMT%2B8</span><br></pre></td></tr></table></figure></li>
<li>validconnection 报错，是因为druid版本太低，在pom.xml中将其版本改为1.1.10<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><ol>
<li>首先在sevlet中创建验证码<br>用画笔对象，通过随机生成字符串函数创建验证码，写入session中，服务器从session中读取并验证</li>
<li>使用验证码时，要将表单提交的return值改为false，而不再是依赖checkusername&amp;&amp;checkname&amp;&amp;checkemail的返回值，因为这样的话只要表单符合<br>约束，就可以提交，这时是同步提交，而验证码是异步提交，所以得由post提交后由registerServlet判断是否正确，根据返回得值判断验证码是否正确</li>
</ol>
<p>##邮件激活</p>
<ol>
<li>邮箱激活：确保用户填写的邮箱是正确的，便于日后推广。</li>
<li>发送激活邮件，用户点击后就能验证，修改user里的status就能知道是否已经激活<br><img src="/2020/04/24/JAVAWeb/email.png" alt></li>
</ol>
<p>#登录和退出功能</p>
<ol>
<li>逻辑图<br><img src="/2020/04/24/JAVAWeb/login.png" alt></li>
<li>登录成功之后用location.href无法跳转，网上查阅资料后得知可能和表单的提交和href的执行先后有关，如果是用表单的提交的话，就像regist那样，在函数里return false 就能阻止表单提交，而login是用的button点击事件，不能用return false，用window.parent.Location.href=“xxxx”，就能提交，或者将按钮放在表单外，就可以不受表单提交的影响</li>
<li>登录成功后显示欢迎回来，+name，但是发现按照视频的写法失败，浏览器提示data is not definded和cannot property name of null，就是data为null，找不到。经百度查询，将script放在header的最后，但是没有用，并不是html元素未加载完全的原因。查询csdn，得知在findUserServlet中打印user，发现是null，也就是说session中根本没有user，即loginServlet中没有将user存入session中，因此，在login成功后，加上request.getSession().setAttribute(“user”,u);即可</li>
<li>退出：登录的实质就是指session中有user对象，这也映证了上面一个问题，退出就是访问servlet销毁session，跳转至登录页面</li>
</ol>
<p>#优化servlet</p>
<ol>
<li>减少servelt的数量，现在是一个功能一个servlet，可以优化功能为用户的方法，即数据库一张表对应一个servlet，具体功能写成方法<br><img src="/2020/04/24/JAVAWeb/BaseServlet.png" alt></li>
<li>BaseServlet继承HttpServlet，并重写service方法，这样当访问UserServlet时，就会调用BaseServlet中service进行方法分发，在去寻找UserServlet里的对应方法</li>
<li>改了路径后，页面的路径也要改动，改为user/方法名，注意serviceImpl里的邮件激活的路径也要改</li>
</ol>
<p>#分类数据展示功能<br><img src="/2020/04/24/JAVAWeb/category.png" alt></p>
<ol>
<li>又出现了bug，这次是因为categroy数组返回时，将data[i]写成了data，就变成了数组对象，当然显示不出名字。</li>
</ol>
<p>#旅游线路的分页展示</p>
<ol>
<li>注意使用非页展示使要将redis打开，不然会报timeout错误</li>
<li>特别注意，从github上复制的代码，前端一定要修改拼接字符串中的单引号，因为复制粘贴后就会又斜杆分隔符产生。</li>
</ol>
<h1 id="SQL数据库"><a href="#SQL数据库" class="headerlink" title="SQL数据库"></a>SQL数据库</h1><h2 id="数据库基本操作"><a href="#数据库基本操作" class="headerlink" title="数据库基本操作"></a>数据库基本操作</h2><ol>
<li>注释：–空格(单行注释)，/**/多行注释，#mysql独有</li>
<li>CRUD：增删改查，create，retrieve(查询)，update，delete<ul>
<li>创建数据库(create)<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--直接创建数据库</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名;</span><br><span class="line"><span class="comment">--如果不存在数据库1就创建数据库2</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> esists db2;</span><br><span class="line"><span class="comment">--创建数据库并制定字符集</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db3 <span class="keyword">default</span> <span class="built_in">character</span> <span class="keyword">set</span> gbk;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ul>
<li>查看所有数据库<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"><span class="comment">--查看某个数据库的定义信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> db3;</span><br></pre></td></tr></table></figure></li>
<li>修改数据库(alter)<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--修改数据库默认的字符集</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> 数据库名 <span class="keyword">default</span> <span class="built_in">character</span> 字符集;</span><br></pre></td></tr></table></figure></li>
<li>删除数据库(drop)<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--删除数据库3</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> db3;</span><br></pre></td></tr></table></figure></li>
<li>查看正在使用的数据库(select)<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--select是MySQL中的一个全局函数</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">database</span>()</span><br></pre></td></tr></table></figure></li>
<li>使用切换数据库(use),要想使用一个数据库，首先得确定当前使用的就是目标数据库，如果不是，就需要切换数据库<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> 数据库名</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h2><ol>
<li>对表操作前首先得选中一个数据库</li>
</ol>
<ul>
<li>创建表，注意是先写字段名再写字段类型，和编程的顺序不同，另外字段类型也不同，每个字段类型中间用逗号分隔,最后一个不需要逗号,表名后面是括号不是花括号<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">	字段名<span class="number">1</span> 字段类型,</span><br><span class="line">	字段名<span class="number">2</span> 字段类型,</span><br><span class="line">	);</span><br><span class="line"><span class="comment">/*常用数据类型</span></span><br><span class="line"><span class="comment">int</span></span><br><span class="line"><span class="comment">double</span></span><br><span class="line"><span class="comment">varchar 字符串类型</span></span><br><span class="line"><span class="comment">date 日期类型格式为 yyyy-mm-dd</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<table>
<thead>
<tr>
<th>Text类型</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>CHAR(size)</td>
<td>保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。</td>
</tr>
<tr>
<td>2</td>
<td>VARCHAR(size)</td>
<td>保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。</td>
</tr>
<tr>
<td>3</td>
<td>TINYTEXT</td>
<td>存放最大长度为 255 个字符的字符串。</td>
</tr>
<tr>
<td>4</td>
<td>TEXT</td>
<td>存放最大长度为 65,535 个字符的字符串</td>
</tr>
<tr>
<td>5</td>
<td>BLOB</td>
<td>用于 BLOBs（Binary Large OBjects）。存放最多 65,535 字节的数据。</td>
</tr>
<tr>
<td>6</td>
<td>MEDIUMTEXT</td>
<td>存放最大长度为 16,777,215 个字符的字符串。</td>
</tr>
<tr>
<td>7</td>
<td>MEDIUMBLOB</td>
<td>用于 BLOBs（Binary Large OBjects）。存放最多 16,777,215 字节的数据。</td>
</tr>
<tr>
<td>8</td>
<td>LONGTEXT</td>
<td>存放最大长度为 4,294,967,295 个字符的字符串。</td>
</tr>
<tr>
<td>9</td>
<td>LONGBLOB</td>
<td>用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。</td>
</tr>
<tr>
<td>10</td>
<td>ENUM(x,y,z,etc.)</td>
<td>允许您输入可能值的列表。可以在ENUM列表中列出最大65535个值。如果列表中不存在插入的值，则插入空值。注释：这些值是按照您输入的顺序排序的。可以按照此格式输入可能的值： ENUM(‘X’,’Y’,’Z’)</td>
</tr>
<tr>
<td>11</td>
<td>SET</td>
<td>与 ENUM 类似，不同的是，SET 最多只能包含 64 个列表项且 SET 可存储一个以上的选择。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Number类型</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TINYINT(size)</td>
<td>带符号-128到127 ，无符号0到255。</td>
</tr>
<tr>
<td>2</td>
<td>SMALLINT(size)</td>
<td>带符号范围-32768到32767，无符号0到65535, size 默认为 6。</td>
</tr>
<tr>
<td>3</td>
<td>MEDIUMINT(size)</td>
<td>带符号范围-8388608到8388607，无符号的范围是0到16777215。 size 默认为9</td>
</tr>
<tr>
<td>4</td>
<td>INT(size)</td>
<td>带符号范围-2147483648到2147483647，无符号的范围是0到4294967295。 size 默认为 11</td>
</tr>
<tr>
<td>5</td>
<td>BIGINT(size)</td>
<td>带符号的范围是-9223372036854775808到9223372036854775807，无符号的范围是0到18446744073709551615。size默认为20</td>
</tr>
<tr>
<td>6</td>
<td>FLOAT(size,d)</td>
<td>带有浮动小数点的小数字。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。</td>
</tr>
<tr>
<td>7</td>
<td>DOUBLE(size,d)</td>
<td>带有浮动小数点的大数字。在 size 参数中规显示定最大位数。在 d 参数中规定小数点右侧的最大位数。</td>
</tr>
<tr>
<td>8</td>
<td>DECIMAL(size,d)</td>
<td>作为字符串存储的DOUBLE类型，允许固定的小数点。在size参数中规定显示最大位数。在d参数中规定小数点右侧的最大位数。</td>
</tr>
<tr>
<td>注意：以上的 size 代表的并不是存储在数据库中的具体的长度，如int(4)并不是只能存储4个长度的数字。实际上intsize所占多少存储空间并无任何关系。int(3)、int(4)、int(8) 在磁盘上都是占用 4 btyes 的存储空间。就是在显示给用户的方式有点不同外，int(M) 跟 int 数据类型是相同的。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>例如：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1、int的值为10 （指定zerofill）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>int（9）显示结果为000000010</td>
<td></td>
<td></td>
</tr>
<tr>
<td>int（3）显示结果为010</td>
<td></td>
<td></td>
</tr>
<tr>
<td>就是显示的长度不一样而已 都是占用四个字节的空间</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Date类型</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>DATE()</td>
<td>日期。格式：YYYY-MM-DD注释：支持的范围是从 ‘1000-01-01’ 到 ‘9999-12-31’</td>
</tr>
<tr>
<td>2</td>
<td>DATETIME()</td>
<td>*日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td>
</tr>
<tr>
<td>3</td>
<td>TIMESTAMP()</td>
<td>*时间戳。TIMESTAMP 值使用 Unix 纪元(‘1970-01-01 00:00:00’ UTC)至今的秒数来存储。格式：YYYY-MM-DDHH:MM:SS注释：支持的范围是从 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-09 03:14:07’ UTC</td>
</tr>
<tr>
<td>4</td>
<td>TIME()</td>
<td>时间。格式：HH:MM:SS注释：支持的范围是从 ‘-838:59:59’ 到 ‘838:59:59’</td>
</tr>
<tr>
<td>5</td>
<td>YEAR()</td>
<td>2 位或 4 位格式的年。注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。</td>
</tr>
<tr>
<td>*即便DATETIME和TIMESTAMP返回相同的格式，它们的工作方式很不同。在INSERT或UPDATE查询中，TIMESTAMP自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>查看表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看某个数据库中的所有表</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="comment">--查看表结构</span></span><br><span class="line">desc 表名;</span><br><span class="line"><span class="comment">--查看创建表的sql语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个结构相同的表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 新表名 <span class="keyword">like</span> 旧表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br><span class="line"><span class="comment">--如果不存在不删除，存在删除</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> esists <span class="string">'create'</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>修改表的结构(增加ADD)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">ADD</span> 列名 类型;</span><br></pre></td></tr></table></figure></li>
<li><p>修改列的类型(MODIFY)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">MODIFY</span> 列名 类型;</span><br></pre></td></tr></table></figure></li>
<li><p>插入数据(插入字符串数据要加上单引号)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 (字段名<span class="number">1</span>，字段名<span class="number">2</span>，字段名<span class="number">3</span>) <span class="keyword">values</span> (值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>删除数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件表达式;</span><br></pre></td></tr></table></figure></li>
<li><p>设置主键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> primary <span class="keyword">key</span>(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>设置id自增</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">change</span> <span class="keyword">id</span> <span class="keyword">id</span> AUTO_INCREMENT;</span><br><span class="line"><span class="comment">--设置初始值</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 AUTO_INCREMENT = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>##表的约束</p>
<ol>
<li>约束是为了保证数据的正确性，完整性，有效性，限定非法数据的插入</li>
<li>分类：</li>
</ol>
<ul>
<li>主键约束：primary key（自动增长）auto_increment<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, </span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">--添加非空</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>;</span><br><span class="line"><span class="comment">--删除非空,只需要修改列名的属性</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">int</span>;</span><br></pre></td></tr></table></figure></li>
<li>非空约束：not null<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">--添加非空</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">MODIFY</span> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">--删除非空,只需要修改列名的属性</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">MODIFY</span> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li>
<li>唯一约束：unique<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unique</span>, </span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">--添加非空</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unique</span>;</span><br><span class="line"><span class="comment">--删除非空,只需要修改列名的属性</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">int</span>;</span><br></pre></td></tr></table></figure></li>
<li>主键约束：foreign key constraint 外键名称 foreign Key (当前表的外键) reference 表名(列名)<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">drop</span> <span class="keyword">foreign</span> <span class="keyword">key</span> 外键名称 <span class="comment">--删除外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">add</span> <span class="keyword">constraint</span> employee_foreign <span class="keyword">foreign</span> <span class="keyword">key</span> (<span class="keyword">id</span>) <span class="keyword">reference</span> employee(UID)<span class="comment">--添加外键</span></span><br><span class="line"><span class="comment">--设置级联更新,这样一张表更新，另一张表就会更新</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">add</span> <span class="keyword">constraint</span> employee_foreign <span class="keyword">foreign</span> <span class="keyword">key</span> (<span class="keyword">id</span>) <span class="keyword">reference</span> employee(UID) <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span></span><br><span class="line"><span class="comment">--级联删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">add</span> <span class="keyword">constraint</span> employee_foreign <span class="keyword">foreign</span> <span class="keyword">key</span> (<span class="keyword">id</span>) <span class="keyword">reference</span> employee(UID) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>##数据库的多表操作</p>
<ol>
<li>表之间的关系有四种，一对一，一对多，多对一，多对多</li>
<li>一对多实现,在多的表中建立外键，指向一的表的主键</li>
<li>多对多的实现，需要第三张中间表，中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键。并且为了保证两个主键不会出现一摸一样的情况，需要联合主键  primary key(rid,uid)</li>
<li>一对一实现，在任意一个表中添加外键指向另一表的主键，并且令外键唯一</li>
</ol>
<p>##数据库涉及范式</p>
<ol>
<li>就是数据库涉及时的规范</li>
<li>分类：有六类，但是一般项目只要前面三式</li>
</ol>
<ul>
<li><p>第一范式：每一列都是不可分割的原子项，就是每一列都是单独的列，里面不包含其他子列。<br><img src="/2020/04/24/JAVAWeb/%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F.png" alt><br>这里面的系就可以拆分为系名和系主任两个独立选项</p>
</li>
<li><p>第二范式：在第一范式的基础上，非码属性必须完全依赖于候选码（在第一范式的基础上消除非主属性对主码的部分函数依赖），消除部分依赖<br>上面的表中存在这许多问题，这些问题的解决就需要用到二三范式。</p>
</li>
<li><p>存在的问题：首先，数据有冗余。姓名，系名和系主任有大量重复，其次数据添加存在问题，添加新开设的系和系主任时数据不合法，最后数据删除存在问题，一名同学毕业后回将其所在的系和系主任都删除</p>
</li>
<li><p>函数依赖：A–&gt;B，如果通过A属性的值，可以确定唯一b属性的值，就称b依赖于a。例如表中学号–&gt;姓名（姓名依赖于学号，通过学号可以找到唯一姓名），（学号，课程）–&gt;分数(通过学号和课程可以确定唯一的分数，依赖于属性组)</p>
</li>
<li><p>完全函数依赖：A–&gt;B，如果A是一个属性组，则B属性值需要依赖A属性组中的所有属性值，例如（学号，课程名称）–&gt;分数</p>
</li>
<li><p>部分函数依赖：A–&gt;B，如果A是一个属性组，B属性的确定只需要A属性组的一些属性值，例如（学号，课程名称）–&gt;姓名</p>
</li>
<li><p>传递函数依赖：A–&gt;B,B–&gt;C,如果通过A属性的值，可以确定唯一B属性的值，在通过B属性的值可以确定唯一C属性的值，例如学号–&gt;系名，系名–&gt;系主任。</p>
</li>
<li><p>码：在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性（属性值）为该表的码，例如（学号，课程名称）<br>主属性：码属性组的所有属性<br>非主属性：除码属性的所有属性</p>
</li>
</ul>
<p><img src="/2020/04/24/JAVAWeb/%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F1.png" alt><br>第二范式是为了消除非主属性对主属性的部分依赖，就是要把表拆分为完全依赖的表，解决第一个数据冗余问题，第一张表中，分数完全依赖于学号和课程名称，第二张表中，姓名系主任，系名都完全依赖学号，因此可以删除一大部分冗余数据。但是第二三个问题没有解决，还需要第三范式。</p>
<ul>
<li>第三范式：在第一二范式的基础上，任何非主属性不依赖于其他非主属性（消除传递依赖）<br><img src="/2020/04/24/JAVAWeb/%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F.png" alt><br>系主任完成依赖于系名，系名依赖于学号，因此系主任传递依赖于学号，就可以拆分，同理系名也传递依赖学号，就可以把这两个分出去。就解决了插入和删除对其他数据的影响。因此判断表设计是否合理，就是看其有没有数据冗余，插入删除数据会不会对其他数据产生影响。</li>
</ul>
<p>##数据库的多表查询</p>
<ol>
<li>多表查询会查询除许多不需要的数据，这时就需要去除这些无用的数据，需要用到内连接，外连接和子查询。</li>
<li>内连接：分为隐式和显式，隐式用where来删除无用的信息。显式是select 字段 from 表1 inner join 表2 on 条件</li>
<li>外连接：也分为左外和右外，select 字段 from 表1 left （outer） join 表2 on 条件，括号中可写可不写，左连接是查询左表所有数据和右表的并集部分，就是左表全部查询，右表如果没有对应信息就会默认空，右表相反，语句吧left改为right即可。</li>
<li>子查询：</li>
</ol>
<ul>
<li>子查询的结果是单行单列的，子查询可以作为条件，使用运算符（&gt; &lt; =）去判断。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">where</span> 字段 = (<span class="keyword">select</span> <span class="keyword">MAX</span>(字段) <span class="keyword">from</span> 表<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li>查询结果是多行单列的,查询的结果作为集合在其中查询<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emploment e <span class="keyword">where</span> e.id <span class="keyword">in</span> (<span class="keyword">select</span> * <span class="keyword">form</span> depaetment  <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'市场部'</span> <span class="keyword">or</span> <span class="keyword">name</span> = <span class="string">'技术部'</span>)</span><br></pre></td></tr></table></figure></li>
<li>查询结果是多行多列的，子查询可以作为虚拟表进行查询<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> depr t1, (<span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> emp.date &gt; <span class="number">12</span>) t2 <span class="keyword">where</span> t1.id = t2.id</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="表单注册"><a href="#表单注册" class="headerlink" title="表单注册"></a>表单注册</h1><ol>
<li><div> 可定义文档中的分区或节（division/section）。<div>标签可以把文档分割为独立的、不同的部分。它可以用作严格的组织工具，并且不使用任何格式与其关联。如果用 id 或 class 来标记 <div>，那么该标签的作用会变得更加有效。并且不推荐使用align属性来确定div的对齐方式，通过样式来确定对齐方式</div></div></div></li>
<li><p>表单中的action属性是指定向哪个地方发送表单数据，是本站就写相对URL，外部网站就写绝对URL</p>
</li>
<li><p><label> 标签为 input 元素定义标注（标记）。label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。<label> 标签的 for 属性应当与相关元素的 id 属性相同。for属性会将label和某个元素绑定，就是点击某段文字，就会触发与之绑定的组件</label></label></p>
</li>
<li><p>colspan 属性规定单元格可横跨的列数,即一个单元格可以横跨几列，colspan=”0” 指示浏览器横跨到列组的最后一列。</p>
</li>
<li><p>设置背景图片</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">	background: url("") no-repeat center;<span class="comment">&lt;!--no-repeat是为了让图片不出现重复--!&gt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>类选择器，设置某一类的共同样式，前面要加上点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.rg_layout&#123;</span><br><span class="line">            width: 900px;</span><br><span class="line">            height: 500px;</span><br><span class="line">            border: 8px solid #EEEEEE;</span><br><span class="line">            background: white;</span><br><span class="line">            margin: auto;</span><br><span class="line">            margin-top: 15px;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>让div变成水平放置，用浮动float</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.rg_center&#123;</span><br><span class="line">            border: 1px solid red;</span><br><span class="line">            float: right;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>子类选择器,首先通过&gt;找到子类，在通过first-child找到第一个子元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.rg_left &gt; p:first-child&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>内边框是padding，设置内部元素与外部的间距</p>
</li>
<li><p>并集选择器，将相同的样式设置成多个id</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">#username,#birthday,#name,#email,#password,#checkcode,#tel&#123;</span><br><span class="line">            border: 1px solid #A6A6A6;</span><br><span class="line">            width: 251px;</span><br><span class="line">            height: 32px;</span><br><span class="line">            border-radius: 5px;</span><br><span class="line">            padding-left: 10px;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>













</li>
</ol>
<p>#注意点<br>baseservlet优化之后记得修改，激活成功，请登录<a href="login.html"></a>,改为login的绝对路径，因为原来activeservlet和login是在同一travel路经下的，而用的userservlet后，路径就回多一个/user，就不可能找到login的路径，同时，找login的路径，一定要把服务器打开找路径，不然找到的只是login静态资源的路径，服务器打开时也会找不到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">active</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取激活码</span></span><br><span class="line">        String code = request.getParameter(<span class="string">"code"</span>);</span><br><span class="line">        <span class="keyword">if</span>(code != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//2.调用service完成激活</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = service.active(code);</span><br><span class="line">            <span class="comment">//3.判断标记</span></span><br><span class="line">            String msg = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="comment">//激活成功</span></span><br><span class="line">                msg = <span class="string">"激活成功，请&lt;a href='http://localhost/travel/login.html'&gt;登录&lt;/a&gt;"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//激活失败</span></span><br><span class="line">                msg = <span class="string">"激活失败，请联系管理员!"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将信息返回,注意这里不是用json返回，而是用response以html形式返回，用json只能显示键值对,不能显示点击超连接的效果</span></span><br><span class="line">            response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">            response.getWriter().write(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h1><ol>
<li>servlet(server applet)是sun公司开发的一款用于开发动态web资源的技术，web资源分为动态和静态的两种。在服务器上运行的小程序<br><img src="/2020/04/24/JAVAWeb/Servlet.png" alt></li>
<li>动态和静态的区别</li>
</ol>
<ul>
<li>动态web资源是客户端请求的动态资源，先将资源交于web容器，在由web容器连接数据库，数据库处理数据后交由web容器返回给客户端解析渲染处理</li>
<li>静态资源是web容器从内存中直接调取返回给客户端</li>
<li>静态资源一般是设计好的html页面，而动态资源是根据设计好的程序按照需求来动态响应</li>
<li>静态资源的交互性差，动态资源的交互性好</li>
<li>静态资源不需要数据库参与程序处理，而动态资源需要</li>
</ul>
<h2 id="servlet的实现方法"><a href="#servlet的实现方法" class="headerlink" title="servlet的实现方法"></a>servlet的实现方法</h2><p>sun在java中提供了servlet的接口，只需要完成两个步骤</p>
<ul>
<li>编写Java类，实现servlet接口</li>
<li>在WEB-INF目录下的web.xml中配置Servlet<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">			 http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置Servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置Servlet的别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置Servlet的路径，也就是全限定类名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.itcast.web.servlet.ServletDemo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置Servlet的访问路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Servlet的别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置访问路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>##Servlet的原理<br>tomcat通过解析web.xml文件，获取到<Servlet-class>标签下的Servlet对应的全限定类名，将类的字节码文件加载进内存，调用Class.forName().newInstance(),创建一个新的对象，掉用对象中的service方法，完成所需的功能。</Servlet-class></p>
<p>##Servlet的生命周期方法<br>Init：只执行一次，可以通过配置指定在服务器启动时执行或者在第一次访问Servelt时启动<br>配置在Servelt中用<load-on-startup>标签控制，为负数是指定第一次被访问时执行，为0或正数是在服务器启动时执行。由于Init只执行一次，即Servelt是单例对象，那么就会存在多线程安全问题，解决方法就是在方法中定义局部变量，不在Servlet中定义成员变量<br>Service每次访问Servlet时执行，destory在服务器正常关闭时才会执行</load-on-startup></p>
<p>##Servelt的体系结构<br>Servlet是接口，其下有GenericServlet的子抽象类和HttpServlet的孙子抽象类。其中GenericServlet只有Service的抽象，其他方法默认为空，HttpServlet封装了Http协议的相关操作，使用者不需要再根据请求的类型做相应的处理，直接写在doGet和doPost方法里。</p>
<p>##路径配置</p>
<ol>
<li>一个Servlet可以匹配多个路径，<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(&#123;<span class="string">"/d4"</span>,<span class="string">"/ddd4"</span>,<span class="string">"/d4"</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li>其他路径配置方式<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/xxx/xx  <span class="comment">// 多层路径方式</span></span><br><span class="line">/xxx<span class="comment">/* //写什么样的路径都会访问</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>##Http(HyperText Transfer protocol)超文本传输协议</p>
<ol>
<li>请求消息格式:</li>
</ol>
<ul>
<li>请求行<br>  请求方式 请求url 请求协议/版本<pre><code>GET    /login.html Http/1.1</code></pre></li>
<li>请求头<br>  请求头名称： 值<br>  常见的请求头：<br>  user-Agent：告诉服务器浏览器的版本，从而解决浏览器的兼容问题<br>  Accept:告诉服务器浏览器可以接受的数据格式<br>  Accept-Language:浏览器的语言环境<br>  refer:<a href="https://cn.bing.com/" target="_blank" rel="noopener">https://cn.bing.com/</a> 告诉服务器当前请求从哪里来，防止盗链和统计工作。</li>
<li>请求空行<br>  就是空行，分割请求头和请求体</li>
<li>请求体<br>  GET是没有请求体的，因为请求体中装的是请求的一些参数，而GET方式的话，请求参数是装在请求行(url)中的<br>  username=zhangsan</li>
</ul>
<ol start="2">
<li>响应消息格式：</li>
</ol>
<h1 id="一些杂谈"><a href="#一些杂谈" class="headerlink" title="一些杂谈"></a>一些杂谈</h1><ol>
<li><p>得到表单提交的数据用String name = request.getParameter(“name”);<br>这里request.getParameter(“name”)的作用是获得提交的表单中name值为“name”的value，这是通过表单标签的action属性完成，这个属性是规定了表单获得的数据发送到哪个页面</p>
</li>
<li><p>Servlet的框架是由两个Java包组成:javax.servlet和javax.servlet.http. 在javax.servlet包中定义了所有的Servlet类都必须实现或扩展的的通用接口和类.在javax.servlet.http包中定义了采用HTTP通信协议的HttpServlet类.</p>
</li>
<li><p>Servlet的框架的核心是javax.servlet.Servlet接口,所有的Servlet都必须实现这一接口.在Servlet接口中定义了5个方法,其中有3个方法代表了Servlet的声明周期:</p>
</li>
<li><p>init方法,负责初始化Servlet对象<br>service方法,负责相应客户的请求<br>destory方法,当Servlet对象退出声明周期时,负责释放占有的资源</p>
</li>
<li><p>ServletConfig:代表当前Servlet在web.xml中的配置信息（用的不多）</p>
</li>
</ol>
<p>String getServletName()  – 获取当前Servlet在web.xml中配置的名字<br>String getInitParameter(String name) – 获取当前Servlet指定名称的初始化参数的值<br>Enumeration getInitParameterNames()  – 获取当前Servlet所有初始化参数的名字组成的枚举<br>ServletContext getServletContext()  – 获取代表当前web应用的ServletContext对象<br>在Servlet的配置文件中，可以使用一个或多个<init-param>标签为servlet配置一些初始化参数。</init-param></p>
<p>当servlet配置了初始化参数后，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig对象传递给servlet。进而，程序员通过ServletConfig对象就可以得到当前servlet的初始化参数信息。</p>
<p>这样做的好处是：如果将数据库信息、编码方式等配置信息放在web.xml中，如果以后数据库的用户名、密码改变了，则直接很方便地修改web.xml就行了，避免了直接修改源代码的麻烦</p>
<ol start="6">
<li><p>不管是客户端还是服务端，要想跳转，就得把跳转页面放在web文件夹下，而不是放在WEB-INF文件夹下</p>
</li>
<li><p>servlet用web动态项目做的project，打开时要加127.0.0.1:8080/j2ee/listHero，不直接加listHero，并且点击增删查改操作时，点击跳转后会无法跳转，这也是由于上述原因，只要按上面格式输入就好(其实就是相对路径和绝对路径)，通过web动态项目run as就是相对路径，要加上项目名称</p>
</li>
</ol>
<h1 id="tomcat匹配的jdk"><a href="#tomcat匹配的jdk" class="headerlink" title="tomcat匹配的jdk"></a>tomcat匹配的jdk</h1><ol>
<li>如果是用的how2j提供的tomcat，那么Java的jdk版本必须是1.8(我之前用的是13，打开tomcat就闪退)，具体安装教程how2j上也有。</li>
<li>如果想用url访问html文件，必须在tomcat/bin/webapps下手动新建一个ROOT(大写)文件夹，才能在网站上看见。</li>
<li>tomcat的乱码显示问题</li>
<li>部署项目时要加上端口号，并且在server配置文件里写文件路径时，要新建一个web项目文件</li>
<li>用eclipsse打开时，会发现报failed to find JDK….jvm,这是因为jdk版本与eclipse版本不一致导致，全部用how2j提供的版本进行下载</li>
</ol>
<h1 id="部署servlet时的错误"><a href="#部署servlet时的错误" class="headerlink" title="部署servlet时的错误"></a>部署servlet时的错误</h1><ol>
<li>将WEB-INF文件错打成了WEB_INF,</li>
</ol>
<h1 id="jdbc查询语句中String里面不加单引号，但是在sql中要加"><a href="#jdbc查询语句中String里面不加单引号，但是在sql中要加" class="headerlink" title="jdbc查询语句中String里面不加单引号，但是在sql中要加"></a>jdbc查询语句中String里面不加单引号，但是在sql中要加</h1><p>#爬虫时遇到的问题</p>
<ol>
<li>spring里的@table（）配置出错，这是因为IDEA没有和数据库建立连接，博客，是因为驱动和sql版本不对，换成5.1即可</li>
<li>application要放在itcast.cn.crawler.jd的下面，放在其他包下面可能不能运行</li>
<li>爬取京东网页内容时爬取失败，发现是要先登录，这是因为没有进行模拟登录，没有设置headers信息，不能被服务器识别为浏览器。设置headwes信息即可</li>
<li>获取spu和sku失败，经过调试后发现，有的spu是空值，没有对空值的情况进行处理，进行处理后发现spu为空值时，ware-type=”0”，就将其设为条件，当=0时，就令spu=null，sku找不到是因为select根本没有获取到元素，视频中的选择器写错了，应该是”img”,它写为了”[data-sku]”，改过之后就能正常下载了。</li>
</ol>
<p>#IDEA中resource下创建多级目录</p>
<ol>
<li>在左边小窗口中的设置中选择取消紧凑中间包选项即可</li>
<li>alt+7，显示类下的所有方法</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JAVAWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言提高</title>
    <url>/2020/04/24/c%E8%AF%AD%E8%A8%80%E6%8F%90%E9%AB%98/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ol>
<li>数据类型的实质是指向一定大小的内存空间的别名<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b[<span class="number">23</span>];</span><br><span class="line"><span class="comment">//b是数组首元素的地址，而&amp;b是整个数组</span></span><br></pre></td></tr></table></figure></li>
<li>数据类型的封装<br>void字面意思是无类型，void*则为无类型指针，即可以指向所有类型的指针，malloc就是典型的例子</li>
<li>函数本质上也是一种数据类型，因为满足变量的三定义，名称，返回值，参数</li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol>
<li>既能读又能写的内存对象，不可以修改的叫常量</li>
<li>变量相当于门牌号，读写数据是向变量名所指的内存空间读写，而不是在变量名里读写</li>
<li>内存四区模型和函数调用模型</li>
</ol>
<p>#输入一串数字，以回车作为结束符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;La.data[i++]);</span><br><span class="line">		La.length++;</span><br><span class="line">		ch=getchar();</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">'\n'</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>#指针</p>
<h2 id="如果定义了一个指针但是没有指向，要为指针分配空间才能存储数据，因为指针只是定义了，"><a href="#如果定义了一个指针但是没有指向，要为指针分配空间才能存储数据，因为指针只是定义了，" class="headerlink" title="如果定义了一个指针但是没有指向，要为指针分配空间才能存储数据，因为指针只是定义了，"></a>如果定义了一个指针但是没有指向，要为指针分配空间才能存储数据，因为指针只是定义了，</h2><p>但是指向不知道，会出现segmentation fault</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>int (<em>p)(int,int);<br>表示返回值为int,参数为两个int型的函数指针p。<br>以函数指针作为形参，即可实现函数名作为参专数，由另一个函数调用。<br>如使用方法：<br> 1、定义函数指针类型<br>使用typedef更直观更方便<br>// 定义一个原型为int Fun( int a );的函数指针<br>typedef int (</em>PTRFUN) ( int aPara );<br>typedef的功能是定义新的类型。这里定义了一种PTRFUN的类型，并定义这种类型为指向某种函数的指针，<br>这种函数以一个int为参数并返回char类型。后面就可以像使用int,char一样使用PTRFUN了。<br>##行指针<br>行指针只有取<em>才是首地址，才能和char *等价<br>二级指针就相当于二维数组的数组名，取一次</em>是每行的首地址，再去一次*是每行具体的元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">char</span>**s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pwd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(s[i]); j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">strlen</span>(s[<span class="number">4</span>]); k++)</span><br><span class="line"><span class="keyword">if</span> (s[i][j] == s[i][k]) cnt++;</span><br><span class="line">pwd = pwd * <span class="number">10</span> + cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#链表<br>##有序表的合并，用一个新表存储比较好的数据，而不是在原来的链表上操作<br>##链表逆置，就想到头插法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">reverse</span><span class="params">( struct ListNode *head )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">L</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>)),*<span class="title">p</span>,*<span class="title">q</span>;</span><span class="comment">//L就是新的头节点</span></span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    p=head;<span class="comment">//遍历的是p，相当于中间变量</span></span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        q=(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        q-&gt;data=p-&gt;data;</span><br><span class="line">        q-&gt;next=L-&gt;next;<span class="comment">//头插法</span></span><br><span class="line">        L-&gt;next=q;<span class="comment">//头插法  q,新节点</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>#宏定义<br>##宏定义的类型是字符串，如果像转为其他格式需要提前转好</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N ((int)4)<span class="comment">//int型的数据</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N ((char)4)<span class="comment">//char型的数据</span></span></span><br></pre></td></tr></table></figure>
<p>#c函数<br>##不区分大小写函数<br>stricmp</p>
<p>#杂项<br>取模运算，范围是<br>rand（） % （b - a + 1）+ a，显然，rand（）% （b - a + 1）的范围是[0，b - a]，<br>再加上a之后的范围就是[a，b]下面的代码是生成[0，2]和[3，8]范围内的随机数<br>##删除文本文件中指定内容<br>    1.创建临时文件，便读取边删除，调用ststem函数删除元文件，在将文件改为原来的名字<br>    2.将文件全部读入内存，删除指定内容，用w方式打开文件，在读写进去（不推荐，只适合空间小的文件，可能把内存撑爆）<br>    3.删除文件后不断调用fseek函数调动指针位置（不推荐，不停调用底层代码，效率低，并且算法是最复杂的）</p>
<p>##程序设计的一般思路<br>    1.分析设计：<br>        1.分析每个功能模块涉及到的操作，画出或写出流程图和伪代码<br>        2.在此基础上提炼出每个模块都涉及的一些反复执行的操作，设计成子函数，<br>    2.完成代码框架设计：<br>        1.完成主函数代码<br>        2.确定所有子函数功能即参数<br>    3.逐一完成每个子函数功能的实现及调试<br>    4.实现大部分功能，程序已经能运行演示<br>    5.优化代码</p>
<p>##fscanf也是可以以转义符的格式读取数据的<br>例如fscanf(fp,”%s\n%s\t%s\n%s\t%s\n%c\n%s\n%s\n”,pNew-&gt;question,pNew-&gt;option_A,pNew-&gt;option_B,pNew-&gt;option_C,pNew-&gt;option_D,&amp;pNew-&gt;rightAnswear,pNew-&gt;difficulty,pNew-&gt;knowledge);</p>
<p>##c语言读取文本文件时，devc用的时ANSI编码，而我的记事本我把它改成默认utf-8的编码，因此会显示乱码，问题不大，只要点击文件-&gt;另存为-&gt;文件类型的下面有个编码，选择ANSI即可。</p>
<p>##字符串拼接的两种方法，strcat和sprintf，区别就是sprintf按照指定格式拼接，而stract直接拼接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *firstName = <span class="string">"Theo"</span>;</span><br><span class="line">    <span class="keyword">char</span> *lastName = <span class="string">"Tsao"</span>;</span><br><span class="line">    <span class="keyword">char</span> *name = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(firstName) + <span class="built_in">strlen</span>(lastName));</span><br><span class="line">    <span class="built_in">strcpy</span>(name, firstName);</span><br><span class="line">    <span class="built_in">strcat</span>(name, lastName);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *firstName = <span class="string">"Theo"</span>;</span><br><span class="line">    <span class="keyword">char</span> *lastName = <span class="string">"Tsao"</span>;</span><br><span class="line">    <span class="keyword">char</span> *name = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(firstName) + <span class="built_in">strlen</span>(lastName));</span><br><span class="line">    <span class="built_in">sprintf</span>(name, <span class="string">"%s%s"</span>, firstName, lastName);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##将缓存区清空，用fflush(stdin),可以不用getchar()清空缓存区，清空屏幕用system(“CLS”)<br>回到主界面用while循环；</p>
<h1 id="字符串与数组"><a href="#字符串与数组" class="headerlink" title="字符串与数组"></a>字符串与数组</h1><ol>
<li>c语言中没有String类型，只有字符数组，而当字符数组充当字符串时，编译器会自动在结尾加上’\0’作为结束标志<br>但是如果只是简单的字符数组，是单个赋值的时候就不会再结尾添加结束标志<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[] = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s1[]=&#123;<span class="string">"abcde"</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeofs:%d\n"</span>,<span class="keyword">sizeof</span>(s));<span class="comment">//5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"lengthofs:%d\n"</span>,<span class="built_in">strlen</span>(s));<span class="comment">//5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeofs1:%d\n"</span>,<span class="keyword">sizeof</span>(s1));<span class="comment">//6自动加了结束标志</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"lengthofs:%d\n"</span>,<span class="built_in">strlen</span>(s1));<span class="comment">//5</span></span><br></pre></td></tr></table></figure>
但是两者都能正常输出字符串，因为建立完数组之后，编译器会将剩余空间的值置为0</li>
</ol>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><ol>
<li>文件使用之后一定要关闭，不然会留在缓冲区，如果进行多次读写操作时，就会出现无法读出写入操作</li>
</ol>
<h1 id="指针的递增"><a href="#指针的递增" class="headerlink" title="指针的递增"></a>指针的递增</h1><ol>
<li><em>p++和(</em>p)++<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*p++等价于*(p++)，p肯定是个指针，这句话的意思是先取出*p的值，然后让指针指向下一个数据。</span><br><span class="line">(*p)++的意思是先把*p的值取出来，然后把*p的值++。</span><br><span class="line">使用中要注意到右++是先使用后++，所以可能会造成一些误解。下面举一个例子。</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span> &#125;;</span><br><span class="line">	 <span class="keyword">int</span> arrp[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> arrq[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = arrp;</span><br><span class="line">    <span class="keyword">int</span> *q = arrq;</span><br><span class="line">    <span class="keyword">int</span> a = *p++;<span class="comment">//将arrp[1]的值给a，同时让p指向下一个元素</span></span><br><span class="line">    <span class="keyword">int</span> b = *p;<span class="comment">//*p指向了arrp[2]</span></span><br><span class="line">    <span class="keyword">int</span> c = (*q)++;<span class="comment">//将arrq[1]赋值给c，然后arrq[1]自增</span></span><br><span class="line">    <span class="keyword">int</span> d = *q;<span class="comment">//将arrq[1]赋值给c，</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d,%d,%d"</span>,a,b,c,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">//以上两者没有区别</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *c;</span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> d;</span><br><span class="line"><span class="comment">//c是一个指向常整型的指针（指向的内存空间不可修改，指针自身可修改）</span></span><br><span class="line"><span class="comment">//d是一个常指针，（指针自身不能修改，但是指针指向的内存空间可以修改）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> e;</span><br><span class="line"><span class="comment">//e是一个指向常整型的常指针（指针自身和指针指向的内存空间都不能修改）</span></span><br><span class="line"><span class="comment">//就是CONST右边的变量的另一个是不能变的</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>c语言中的const是一个冒牌货，在编译时const确实是不能修改，不然报错，但是可以通过指针修改const的值<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a = <span class="number">9</span>;</span><br><span class="line">	<span class="comment">/*a = 10;*/</span></span><br><span class="line">	<span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">	p = &amp;a;</span><br><span class="line">	*p = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, *p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, a);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="二级指针做输入的三种内存模型"><a href="#二级指针做输入的三种内存模型" class="headerlink" title="二级指针做输入的三种内存模型"></a>二级指针做输入的三种内存模型</h1><ol>
<li><p>用字符指针数组指向不同的字符串,交换的是指针的指向</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* myArray[] = &#123; <span class="string">"aaaa"</span>,<span class="string">"dsf"</span>,<span class="string">"dsfafds"</span>,<span class="string">"dsaf"</span>,<span class="string">"dsafads"</span> &#125;;<span class="comment">//这是字符数组，而不是字符串，没有0</span></span><br><span class="line">	<span class="comment">//打印</span></span><br><span class="line">	<span class="comment">/*for (int i = 0; i &lt; sizeof(myArray)/sizeof(myArray[0]); i++)&#123;</span></span><br><span class="line"><span class="comment">		printf("%s==", myArray[i]);</span></span><br><span class="line"><span class="comment">		printf("%s\n", *(myArray+i));</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> count = <span class="keyword">sizeof</span>(myArray) / <span class="keyword">sizeof</span>(myArray[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span>* temp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; count; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(myArray[i],myArray[j]&gt;<span class="number">0</span>))&#123;</span><br><span class="line">				<span class="comment">//交换指针</span></span><br><span class="line">				temp = myArray[i];</span><br><span class="line">				myArray[i] = myArray[j];</span><br><span class="line">				myArray[j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用二维数组存储多个字符串，交换的是内存块,其内存模型在人看来是二维的，但是计算机中没有二维内存的概念。二维数组在内存中仍然是一维的，例子：char [10][20],在内存中就是分配了200个字节的总空间，其中每20个字节就是一个大的部分，总共有10个大部分，数组中每个元素就是占20个字节的内存空间，数组指针加加就是每次跳过20个字节内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> myBuf[<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">char</span> myArray[<span class="number">10</span>][<span class="number">30</span>] = &#123; <span class="string">"asfda"</span>,<span class="string">"afdsda"</span>,<span class="string">"dfasgfd"</span>,<span class="string">"fdsgsz"</span> &#125;;</span><br><span class="line">	<span class="comment">//打印</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count ; i++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,myArray[i]);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//这里交换的及时mybuf[30]这个内存区</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>建立字符指针数组，为数组每个元素分配空间，构成第3种内存模型</p>
</li>
</ol>
<ul>
<li>指针也是一种数据类型，数据类型的实质就是一定大小的内存空间，那么指针就一定是一种数据类型，他的内存大小经过编译器计算是4个字节(字符指针和int指针都是4个字节)</li>
<li><img src="/2020/04/24/c%E8%AF%AD%E8%A8%80%E6%8F%90%E9%AB%98/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%AC%AC%E4%B8%89%E7%A7%8D%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span>** p2 = <span class="literal">NULL</span>;<span class="comment">//二级指针</span></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">	<span class="comment">//给二级指针分配内存空间，每个内存空间里面存放者一个字符指针，就相当于字符指针数组</span></span><br><span class="line">	p2 = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*)*num);</span><br><span class="line">	<span class="comment">//printf("%d", sizeof(p2));</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p2[i] = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">100</span>);<span class="comment">//给每个字符指针分配100个字节的空间</span></span><br><span class="line">		<span class="built_in">sprintf</span>(p2[i], <span class="string">"%d%d%d"</span>, i + <span class="number">1</span>, i + <span class="number">1</span>, i = <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p2[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放内存,根据先申请后释放原则，就是栈</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p2[i]!=<span class="literal">NULL</span>)<span class="comment">//释放字符串的空间</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(p2[i]);</span><br><span class="line">			p2[i] = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (p2!=<span class="literal">NULL</span>)<span class="comment">//释放字符指针的空间</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(p2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>#数组</p>
<ol>
<li><p>数组名是数组首元素的地址，而&amp;数组名是整个数组的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c[<span class="number">200</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c是首元素的地址，c+1步长是4个字节</span></span><br><span class="line"><span class="comment">//&amp;c是整个数组的地址，&amp;c+1步长是200*4=800</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>二维数组的名称除了sizeof和对名称取地址外，就是一个指向第一个一维数组的指针，一维数组也是除了对数组名进行sizeof和取地址外，都指向数组中首元素的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************二维数组*************/</span></span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">int</span>(*p)[<span class="number">5</span>];</span><br><span class="line">	p = a;</span><br><span class="line">	<span class="keyword">int</span>(*p1)[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line">	p1 = &amp;a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a=%d"</span>, a);<span class="comment">//a就是数组首元素的地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p=%d\n"</span>, p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p+1=%d\n"</span>, p + <span class="number">1</span>);<span class="comment">//每次加1就是加一个元素的内存空间，就是5*4=20</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"&amp;a=%d"</span>, &amp;a);<span class="comment">//这个就是整个数组的地址，</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p1=%d\n"</span>, p1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p1+1=%d\n"</span>, p1 + <span class="number">1</span>);<span class="comment">//加一就是加整个数组的步长，就是3*5*4=60个字节</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*************一维数组************/</span></span><br><span class="line">	<span class="keyword">int</span> c[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">int</span>* p2 = <span class="literal">NULL</span>;</span><br><span class="line">	p2 = c;</span><br><span class="line">	<span class="keyword">int</span>(*p3)[<span class="number">5</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c=%d"</span>, c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p2=%d"</span>, p2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p2+1%d"</span>, p2 + <span class="number">1</span>);<span class="comment">//就是整个数组，步长5*4=20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组的下标可以为负数，但前提是当前指针已经偏移过，不然可能指向其他的随机地方</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span>* p = a;</span><br><span class="line">	p = a + <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, p[<span class="number">-1</span>]);<span class="comment">//a+2是第三个元素，就是3，-1就相当于把当前指针向前移，就是第二个元素2，如果没有使p移动，直接写</span></span><br><span class="line">	<span class="comment">//写负的下标，就会指向a的前面一个元素，是随机的。</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>#结构体</p>
<ol>
<li>结构体之间的复制尽量使用手动复制而不是系统提供的p1=p2，因为当两个结构体都是在栈上时，p1=p2会将p2的内容全部拷贝至p1，但是如果结构体中有指针类型的数据例如Char *name，那么创建结构体时必然在堆上开辟空间，这时两个结构体的复制就是将p2.name的地址拷贝一份到p1.name,在最后的释放资源步骤中，释放完p2.name之后释放p1.name时就会报错，甚至泄露。解决方法是strcpy(p1.name,p2.name)                                         </li>
<li>结构体取地址是代表整个结构体的地址，这点和数组不同，数组名就代表首地址，取&amp;代表整个数组，结构体名字就是结构体</li>
</ol>
<p>#变量名和内存的关系（从<a href="https://blog.csdn.net/u012252959/article/details/82662542" target="_blank" rel="noopener">这里</a>转载）</p>
<p>有了前面两篇的基础，下面正式开扒变量名和内存的关系，先看一段大家很熟悉的代码：</p>
<ol>
<li>基本类型</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">　　<span class="keyword">int</span> i;</span><br><span class="line">　　scanf_s(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line">　　<span class="comment">//int i;在这一句就为i分配了内存(但尚未对这块内存进行初始化)，所以可以通过&amp;i直接使用这块内存。赋值就更不用说啦，i = 3;。</span></span><br></pre></td></tr></table></figure>
<p>　<br>-　变量名i，是为方便编程人员使用，是这块内存的别名，指代到块内存，对编程人员i代表这块内存中存储的值实际上是i指到这个内存，然后取值通常我们都是通过变量名来使用已知的内存的。</p>
<ul>
<li><p>i代表取这块内存中存储的值，而&amp;i代表取这块内存的址。程序本身是不为i这个变量名分配空间的。在最终的机器代码中，是不会出现变量名的，这一在分析反汇编语言时可以看出。那么编译器是如何处理变量名的呢，变量名会存储在符号表中，并将符号表中的索引对应到实际物理空间(地址)<br>上去，当调用这个变量时，查找符号表就可以找到对应的地址并取值了。</p>
</li>
<li><p>上面分析的是基本数据类型(如int、char等)的变量名。C中除了变量名之外，还有函数名、常量名、指针名、数组名、结构名等。和变量名不同，这些标识符都是直接对应着地址的。基本数据类型的变量，和地址的对应关系需要取址符&amp;才能得到地址，而其余的这些，名字本身就对应着地址。</p>
</li>
</ul>
<p>　　例如char *pc = “se”;，就是将字符串常量”se”的首地址(位于静态存储区)赋值给了字符指针pc。这也就解释了为什么不需要为pc分配地址就可以为其赋值，而不会遇到类似下面代码所带来的野指针问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">　　<span class="keyword">int</span> *pi;　　*pi = <span class="number">1</span>;</span><br><span class="line">　　<span class="comment">//int *pi句，是为pi分配空间，而不是开辟pi所指向的空间。没有置空的话pi可能会乱指向，引起内存崩溃。</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>不同类型变量的变量名和内存间的关系:</li>
</ol>
<ul>
<li>C对常量是怎么处理的呢？比如上面的i=3;中的常量3，存储常量3的地址并不是随机分配的，是在程序中的数据段中(.data?这个我也还不是很确定，希望知道的前辈们给个指导)，也就是程序本身并不为3分配内存，而是直接写入指令。3是数字常量，对于字符常量和字符串常量，又分别是怎么处理的呢？字符常量和数字常量是一样的处理方式，都是类似汇编中的立即数，直接写入指令；<br>　　而字符串常量，则是存储在静态存储区，可以使用&amp;(“string”)取得具体地址。也就是字符串常量名字本身指代着地址，只是不能直接操作(和int i中的i相同)。<br>再看各种类型的变量名，c中的数据类型除常量之外大致有5种：<br>基本数据类型：int、float、double、char等：<br>　　对各基本数据类型的变量名及其声明时的处理方式都是一样的，声明时即分配内存，并使用变量名直接操作这段内存；使用取地址符号&amp;取得地址的数字表示，至于声明时要不要做初始化，要看是不是全局变量或者 static变量了。<br>这类变量名指向一个地址空间，但不能直接当做地址使用，而是通过取址符&amp;操作其地址。</li>
<li>构造数据类型：数组、结构、联合：</li>
<li>数组：数组在声明时，即分配了空间，int a[5];<br>　　一旦声明a[5]，相当于有a、a[0]、a[1]、a[2]、a[3]、a[4]这6个变量名。a[i]的指代方式和普通的变量名int i相同，指到一个对应的内存空间；关键是变量名a，本身就可以做地址用。我们知道a是数组名，但a并不代表整个数组的地址，而是指向数组首元素的地址（虽然在数值上是相同的，下面会有详细解释），所以可以有 int <em>p = a;。那么&amp;a又怎么解释呢？对于int i而言，i代表一个空间，&amp;i表示i所代表的空间地址；那么&amp;a应该也是表示a所代表的地址了，也就是整个数组的地址。<br>　　a、&amp;a和&amp;a[0]同代表地址，且由于数组是顺序存储，所以a、&amp;a和&amp;a[0]所表示的地址在数据上是相同的，但是实际的指代意义却是不同的：<br>a是个int<em>类型的数据，相当于&amp;(</em>a)，是指向数组首元素的地址；<br>&amp;a指代整个数组，是个int(</em>)[]类型的数据，是指针数组的地址；<br>&amp;a[0]则是仅指代一个存储int的空间，是int<em>类型的数据。载编译器编译时会转为机器能看懂的形式，就是（a+i）的样子，由此可以推断获得数据实际上是靠a+偏移量（i）</em>a所指向数据类型的字节数。<br>　　也就是数组名，本身可以作为地址使用，指代该数组的首元素的地址。</li>
<li>结构体<br>　　结构体在声明的时候，就分配了空间。结构体和数组不同，结构体类型的变量名并不能直接当作地址使用，这一点和基本数据类型相同。需要对结构体名使用取址符&amp;才能进行地址操作，并且取址所得到地址代表的是指向结构体的指针，只是在数据上和结构体中的首元素地址相同。<br>　　对于结构体中的各个元素，其名称的指代关系和其数据类型相同，并不因为是结构体的元素而受到影响。具体见下面代码：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">char</span> sex</span><br><span class="line">	<span class="keyword">char</span>* name;  </span><br><span class="line">	<span class="keyword">int</span> score[<span class="number">5</span>];</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">st1</span>;</span><span class="comment">//st1是结构体stu类型       </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d/n"</span>, &amp;st1);<span class="comment">//&amp;st1是 stu*类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d/n"</span>, &amp;st1.age);    <span class="comment">//&amp;st1.age是 int*类型，st1.age就是个int型，名字指向地址，但不能直接作地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d/n"</span>, &amp;st1.sex);    <span class="comment">//&amp;st1.sex是 char*类型，名字解析同上   </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d/n"</span>, &amp;st1.name);   <span class="comment">//&amp;st1.name是 char**类型，st1.name是char*类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d/n"</span>, st1.score);   <span class="comment">// st1.score是个数组类型，名字代表数组中首元素的地址  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>3)<br>       联合：联合是特殊的结构体，为节省空间，在其各元素依次存储，各元素的首地址均相对变量的基地址偏移为0，具体各变量名的分析和结构体同。<br>指针类型<br>　　声明一个指针类型 int <em>p;，则是为存储指针p分配空间，而并不会为p所指向的内存做任何动作，这就是野指针的原因。如下代码，p就是一个未指向任何已知内存的指针，为</em>p赋值，自然会出现错误：<br>　　int *p;　　*p = 1;<br>　　指针中，char *是个很特殊的指针。一般的指针，仅指向一个所定义类型的内存，而char *则可以指向一个字符串，之所以可以实现这个功能是字符串结尾符’/0’的存在标识了字符串的结束。如下的代码，就是将pc指向了“string”所指代的静态存储区地址。</p>
<p>　　char *pc = “string”;<br>　　这就是char *pc = “string”;合法，而int *p =1;不合法的原因。因此，不管指针变量是全局的还是局部的、静态的还是非静态的，都应该在声明它的同时进行初始化，要么赋予一个有效的地址，要么赋予NULL。</p>
<p>　　另外，声明一个指针，只是在栈区为指针本身的存储分配了地址，而不限制指针所指向的内存到底是在栈区还是在堆区还是在静态存储区。这也就造成了 函数调用返回值 会因实现不同而有不同意义，是函数调用结束后返回值有效性不同的原因。详见《从字符串截取说指针和地址》</p>
<p>空类型</p>
<p>　　C中有void关键字，但其实C中是并没有空类型的。比如我们不能做如下定义：</p>
<pre><code>void a;</code></pre><p>　　因为C、C++是静态类型的语言，定义变量就会分配内存。然而，不同类型的变量所占内存不同，如果定义一个任意类型的变量，就无法为其分配内存。所以，C、C++中没有任意类型的变量。</p>
<p>　　但是定义void *p;是合法的，void *所定义的p表示以指针，所指向的类型未定。因为void *p;声明是为指针p分配了空间，无论指针指向什么类型，存储指针所需的空间的固定的，所以不存在因为所需空间大小而无法为p分配空间的问题。</p>
<p>　　但void *p的使用也是很受限制的，由于不知道其指向的数据类型，所以是不能对p进行自增操作的；void的主要作用有两点，一个是限制函数的返回值，一个是限制函数的参数类型；void *则常用于指针的类型转换。如下代码：</p>
<p>　　int *pi;　　float *pf;<br>　　如果想将pi指向pf所指向的内存空间，就必须进行类型转换：pi = (int *)pf;。</p>
<p>　　而如果是void *p，就不需要转换，可以直接为指针赋值。这样的直接赋值，只能是将一个已知类型的指针赋值给void *p，而不能是将void *p未加强制转换地赋值给一个已知类型的指针，如：</p>
<pre><code>void *p;    int *pi;    float *pf;    p = pf;   // pf = p;就是非法的，不能将 &quot;void *&quot; 类型的值分配到 &quot;float *&quot; 类型的实体    p = pi;</code></pre><p>　　但需要注意的是，即使进行了转换，p仍然是个void<em>类型的指针，不能对其进行sizeof(p)等涉及所指类型的操作，同样地p也不能直接用于具体数据类型的操作。如下面的代码中</em>p = 1.73; 和printf(“%f”, *p)都是非法的：</p>
<pre><code>void *p;    float *pf;    p = pf;
*p = 1.73;           //*pf  = 1.73;合法    printf(&quot;%f&quot;, *p);    //printf(&quot;%f&quot;, *pf); 合法</code></pre><p>　　这样说来，void *的意义何在呢？可以使用强制类型转换使用void *p作为中介，见下面的代码：</p>
<p>　　float <em>pf;　　void *p;　　float f=1.6;　　p = (void</em>)&f;　　pf = (float*)p;<br>　　这样，float *pf就指向了float f所在的地址，但注意p依然不能直接使用。这个例子，只是为我们展示了void *有这样的功能，但平常代码中很少这样无意义地转换，更多地是将void *作为函数参数，这样就可以接受任意类型的指针了，典型的如内存操作函数memcpy和memset的函数，其原型分别为：</p>
<p>　　void * memcpy(void <em>dest, const void *src, size_t len);　　void * memset ( void * buffer, int c, size_t num );<br>　　也可以编写自己的将void *作为函数参数的函数，由于char是C中最小长度的变量，其它任何变量的长度都是它的整数倍。可以使用char</em>作为中转，详见下面的函数实现：</p>
<p>//这里差不 多是前后数反转放, 4个字节4次交换<br>//这里 形参=实参  void* =float*   ,相反则不行.<br>void swap(void *pvData1, void *pvData2, int iDataSize)<br>{<br>    unsigned char  *pcData1 = NULL;<br>    unsigned char  *pcData2 = NULL;<br>    unsigned char  ucTmp1;<br>    pcData1 = (unsigned char *)pvData1;<br>    pcData2 = (unsigned char *)pvData2;<br>    do{<br>        ucTmp1= *pcData1;<br>        *pcData1     = *pcData2;<br>        *pcData2     = ucTmp1;<br>        pcData1++;        pcData2++;<br>    }<br>    while (–iDataSize &gt; 0);<br>}<br>int main()<br>{<br>    float fa = 1.23,fb = 2.32;<br>    float *f1=&amp;fa, *f2=&fb;<br>    int iDataSize = sizeof(float)/sizeof(char);<br>    swap(f1, f2, iDataSize);<br>    cout&lt;&lt;fa&lt;&lt;” “&lt;&lt;fb&lt;&lt;endl;<br>    return 0;<br>} </p>
<p>NULL</p>
<p>　　C中对NULL的预定义有两个：</p>
<p>　　#define NULL    0　　#define NULL    ((void *)0)<br>　　并且标准C规定，在初始化、赋值或比较时，如果一边是变量或指针类型的表达式，则编译器可以确定另一边的常数0为空指针，并生成正确的空指针值。即在指针上下文中“值为0的整型常量表达式”在编译时转换为空指针。那么也就是上面的两个的定义在指针上下文中是一致的了。</p>
<p>　　我们经常在声明一个指针时，为避免野指针的情况常用的int *pi = NULL;中的NULL，是会被自动转换为(void *)0的。所以下面的代码也是合法的：</p>
<p>int *pi = 0;if(pi == 0){ …… }</p>
<p>前面是形容词,后面的被修饰的名词才是重点</p>
<p>指针函数(返回指针的函数,函数指针(指向函数的指针<br>指针常量(指针是常量, 常量指针(指向常量的指针 . 这就好理解了</p>
<p>函数类型 和 函数指针</p>
<p>　　尽管函数并不是变量，但它在内存中仍有其物理地址。每个函数都有一个入口地址，由函数名指向这个入口地址，函数名相当于一个指向其函数入口的指针常量。</p>
<p>　　可以将函数名赋值给一个指针，使该指针指向这个函数的入口，即是函数指针。</p>
<p>　　这里注意和指针函数区分开来：</p>
<p>　　指针函数是一个返回指针的函数，指针函数具体定义方式：</p>
<p>　　　　char *Convert(char *pName , int length);</p>
<p>　　函数指针的定义要和具体所指向的函数的形式一致，如对函数int Max(int a, int b)定义一个函数指针：</p>
<p>　　int (<em>pMax)(int a, int b);　　pMax = Max;<br>　　int (</em>pMax)(int a, int b)句中，函数指针pMax外的括号一定要带上[s1] ，因为“()”的优先级高于“*”，如果无括号，就变成了int *pMax(int a, int b)的形式，变成了一个函数(指针函数)的声明了。pMax=Max句将代表函数int Max(int a, int b)入口地址的其函数名Max，赋值给了指向同类型函数的指针pMax。这样pMax就和Max有相同的指代作用，并且pMax还可以指向与int Max(int a, int b)同参同返回值的函数。</p>
<p>　　int Max(int a, int b);　　int Min(int a, int b);<br>　　int (<em>p)(int a, int b);    int max, min;    p = Max;    max = (</em>p)(3, 5);   //进行调用时，也要记得带括号(<em>p)    p = Min;    min = (</em>p)(3, 5)<br>　　执行中对指针p指向进行截图：</p>
<p>　　最后需要注意的是，由于函数在内存中的分布方式并不是齐整的，所以函数指针并没有++自增运算和—自减运算。</p>
<p> [s1]</p>
<p>　　通过括号强行将pMax首先与“*”结合，也就意味着，pMax是一个指针；接着与后面的“()”结合，说明该指针指向的是一个函数，然后再与前面的int结合，也就是说，该函数的返回值是int。由此可见，pfun是一个指向返回值为int的函数的指针。</p>
]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c语言提高</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法实战</title>
    <url>/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ol>
<li>通过指针引用数组元素，<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a [<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p=&amp;a;</span><br><span class="line">(p+i)<span class="comment">//第i个元素的地址</span></span><br><span class="line">*(p+i)<span class="comment">//第i个元素</span></span><br></pre></td></tr></table></figure>
！！！！数组名为第一个元素a[i]的地址，是一个指针常量，不能进行a++运算，<br>要用a+1进行运算(递归注意，就是这里错的)。但是用<code>int *p=a</code>之后就可以用p++。</li>
<li>对数组进行操作的话，函数只要传入首个元素的地址就可以(数组是连续内存)，再知道数组的长度，就可以对数组进行索引和一系列操作<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">     <span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line">     <span class="keyword">int</span> x = <span class="built_in">max</span>(a,n);</span><br><span class="line">     <span class="keyword">double</span> m = average(a,n);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"max = %d,average =  %f"</span>,x,m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> *p;<span class="comment">//定义一个指针，指向a数组，这样可以执行p++操作（详见1）</span></span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">max</span> = *p;</span><br><span class="line">     <span class="keyword">for</span>(p=a;p&lt;a+n;p++)&#123;  <span class="comment">//n是数组长度，p向后一个不是二进制的+1，而是数组元素类型占用内存+1(这样就直观表现为数组元素向后+1)</span></span><br><span class="line">     	<span class="keyword">if</span>(*p&gt;<span class="built_in">max</span>)&#123;</span><br><span class="line">     		<span class="built_in">max</span>=*p;</span><br><span class="line">     	&#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       itn *p;</span><br><span class="line">       <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(p=a;p&lt;a+n;p++)&#123;</span><br><span class="line">       	sum+=(<span class="keyword">double</span>)*p;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">double</span> average = sum/(<span class="keyword">double</span>)n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> average;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>对字符串数组进行操作时，容易忘记最后加上一个中止符号(‘\0’),<br>先省略。。。。。。</li>
</ul>
<ol start="3">
<li>行指针和二维数组</li>
</ol>
<ul>
<li>行指针的定义方式<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据类型  (* 变量名)[每行的元素个数]</span></span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>]<span class="comment">//每行元素个数为4个</span></span><br></pre></td></tr></table></figure></li>
<li>访问具体元素只能用列指针访问，有三种形式<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//数组下标访问</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//列指针访问</span></span><br><span class="line">*(a[<span class="number">2</span>]+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//行指针访问</span></span><br><span class="line">*(*(a+<span class="number">2</span>)+<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li>
<li>编写子函数时，如果是二维数组，那么传入的参数就得是行指针，而不是普通指针<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">ArrayOutput</span> <span class="params">(<span class="keyword">int</span> (*p)[<span class="number">4</span>],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="4">
<li><p>数组名是地址常量，用++操作是无法操作的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++,a++)&#123;</span><br><span class="line"> prinf(<span class="string">"%d"</span>,*a);<span class="comment">//这段是错误的，因为a是地址常量，++无法改变地址，而a+i就可以访问数组其它元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++,a++)&#123;</span><br><span class="line"> prinf(<span class="string">"%d"</span>,*(a+i));<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符数组和字符指针<br>区别：</p>
</li>
</ol>
<p>-字符数组有无穷个元素组成，每个元素存放一个字符，而字符指针中存放的是字符串首字符的地址，不是存放的字符串</p>
<ul>
<li>可以对字符串指针赋值，而不能对数组名赋值<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *s ;</span><br><span class="line">s=<span class="string">"i love china!"</span>;<span class="comment">//对</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">13</span>];</span><br><span class="line">a[<span class="number">0</span>]=<span class="string">"i"</span>;<span class="comment">//对</span></span><br><span class="line">a=<span class="string">"i love china"</span>;<span class="comment">//错</span></span><br></pre></td></tr></table></figure></li>
<li>编译时为字符串数组分配若干个存储单元，为字符指针分配一个存储单元</li>
<li>字符指针的值可以改变，而数组名是常量地址，无法更改<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *s;</span><br><span class="line">s+=<span class="number">7</span>;<span class="comment">//对</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">13</span>];</span><br><span class="line">a+=<span class="number">7</span><span class="comment">//错</span></span><br></pre></td></tr></table></figure></li>
<li>初始化并不等价<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">13</span>]=<span class="string">"i love china"</span>;<span class="comment">//正确，</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">13</span>];</span><br><span class="line">str[]=<span class="string">"i love china"</span>;<span class="comment">//错误，因为一旦数组大小确定了之后，在接下来的引用中都必须带上下标，并且数组名是常量地址，无法赋值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str*=<span class="string">"i love china"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str*;</span><br><span class="line">str=<span class="string">"i love china"</span><span class="comment">//这是等价的，因为str*中存储的是地址</span></span><br></pre></td></tr></table></figure></li>
<li>字符数组中的元素值是可以改变的，但是字符指针中的值是不能改变的，因为常量是不能改变的，数组中的并不是常量，而是复制在数组中的副本，但是指针中所指向的就是常量<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">13</span>]=<span class="string">"i love china"</span>;</span><br><span class="line">str[<span class="number">3</span>]=<span class="string">"e"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *str=<span class="string">"i love china"</span>;</span><br><span class="line">*(str+<span class="number">2</span>)=<span class="string">"e"</span>;<span class="comment">//错</span></span><br></pre></td></tr></table></figure></li>
<li>可以用字符指针指向一个格式字符串，这样就可以减少输入麻烦<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *format;</span><br><span class="line">format=<span class="string">"%d %d"</span>;</span><br><span class="line"><span class="built_in">printf</span>(format,a,b);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="6">
<li>指针数组<br>指针数组中存放的是地址，适合用来处理与字符串相关的问题，比用字符数组更加灵活，并且字符串一般是长度不相等的，用指针比二维数组节省空间</li>
</ol>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><ol>
<li><p>概念：递归算法的思想实质就是分治策略，将一个问题拆解成不能再拆解的最小问题(递推分解)，再将最小问题的解返回给上一级(回归分治)。并且在运行到最小问题的时候一定要给出结束的条件，否则会无线递归，占用完内存最终导致程序崩溃。</p>
</li>
<li><p>递归与循环的区别：递归在底层实际上是对线程栈的压栈和出栈(递归是先调用的函数最后运算)，每调用一次都会压栈一次，并记录相关的局部变量信息，无限的递归耗用的是内存资源，而死循耗用的是CPU资源，死循环并不会引起程序的异常，但递归耗完内存就会引发程序的崩溃。</p>
</li>
<li><p>与循环十分类似，但是递归是通过不断打开新函数来运算的，效率上明显不如循环，实际上也是经常用循环而不是用递归。</p>
</li>
<li><p>实例：求n!阶乘</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factrial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//设立的终止条件</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n*factrial(n<span class="number">-1</span>);<span class="comment">//重复的步骤</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题分析：首先找出问题的重复步骤，此题中是n!=1<em>2</em>3<em>….n,那么可见每次n+1就是重复步骤。但是递归是由大问题向小问题分解，就变成了n!=n</em>n-1<em>n-1….</em>1(这也符合栈先进后出的特点)。终止条件显而易见，就是n==1，return 1。<br>程序分析：当n&gt;1时，程序运行到<code>return n*factrial(n-1)</code>时，会打开factrial(n-1)函数，以此类推，最后变为：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">n<span class="number">*fac</span>trial(n-1)<span class="number">*fac</span>trial(n-2)<span class="built_in">..</span><span class="built_in">..</span><span class="number">*fac</span>trial(1)</span><br></pre></td></tr></table></figure>
<p>其中<code>factrial(1) return 1</code>，那么返回上一级函数是2，在上一级就是3。</p>
</li>
</ol>
<p><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E9%80%92%E5%BD%921.jpeg" alt><br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E9%80%92%E5%BD%922.jpeg" alt></p>
<h1 id="一些退出用法"><a href="#一些退出用法" class="headerlink" title="一些退出用法"></a>一些退出用法</h1><p>exit（0）：正常运行程序并退出程序；</p>
<p>exit（1）：非正常运行导致退出程序；</p>
<p>return（）：返回函数，若在主函数中，则会退出函数并返回一值。</p>
<p>详细说：</p>
<ol>
<li><p>return返回函数值，是关键字；  exit 是一个函数。</p>
</li>
<li><p>return是语言级别的，它表示了调用堆栈的返回；而exit是系统调用级别的，它表示了一个进程的结束。</p>
</li>
<li><p>return是函数的退出(返回)；exit是进程的退出。</p>
</li>
<li><p>return是C语言提供的，exit是操作系统提供的（或者函数库中给出的）。</p>
</li>
<li><p>return用于结束一个函数的执行，将函数的执行信息传出个其他调用函数使用；exit函数是退出应用程序，删除进程使用的内存空间，并将应用程序的一个状态返回给OS，这个状态标识了应用程序的一些运行信息，这个信息和机器和操作系统有关，一般是 0 为正常退出， 非0 为非正常退出。</p>
</li>
<li><p>非主函数中调用return和exit效果很明显，但是在main函数中调用return和exit的现象就很模糊，多数情况下现象都是一致的。</p>
</li>
</ol>
<p>exit（0）与exit（1）对你的程序来说，没有区别。对使用你的程序的人或者程序来说，区别可就大了。<br>一般来说，exit 0 可以告知你的程序的使用者：你的程序是正常结束的。如果 exit 非 0 值，那么你的程序的使用者通常会认为你的程序产生了一个错误。</p>
<p>以 shell 为例，在 shell 中调用完你的程序之后，用 echo $? 命令就可以看到你的程序的 exit 值。在 shell 脚本中，通常会根据上一个命令的 $? 值来进行一些流程控制。</p>
<h1 id="assert-断言"><a href="#assert-断言" class="headerlink" title="assert(断言)"></a>assert(断言)</h1><ol>
<li>assert是宏定义，其作用是类似if else，当条件满足时才会继续运行，否则终止程序运行，避免了if语句冗长的表达式，其结构为assert(int expression)，expression是表达式，当表达式返回值为0时结束，但是频繁调用assert会影响性能</li>
<li>可以通过在包含include的语句前插入#include NDEBUG来禁用<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="指针与int相加"><a href="#指针与int相加" class="headerlink" title="指针与int相加"></a>指针与int相加</h1><ol>
<li>指针与int n相加，则表示指针p的指向向后移动了n个p指向的元素所占有的空间值，相当于向后移了n个元素<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line">p=&amp;a;<span class="comment">//假设p值为2000，那么p+4就是2004；</span></span><br><span class="line">p=p+<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">int</span> *p1;</span><br><span class="line">p1=&amp;b;<span class="comment">//p值为2000，那么p+4就是2000+4*4=2016，因为int是4个字节</span></span><br><span class="line">p1+=<span class="number">4</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="gt-和-的区别"><a href="#gt-和-的区别" class="headerlink" title="-&gt;和.的区别"></a>-&gt;和.的区别</h1><p>.的左边是一个表达式结果为结构体的表达式，而-&gt;的左边是指向结构体的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> date;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> *<span class="title">length</span>;</span></span><br><span class="line">&#125;Tree,*PTree;</span><br><span class="line"></span><br><span class="line">Tree.date=a;<span class="comment">//Tree为结构体，用.</span></span><br><span class="line">PTree-&gt;date=b;<span class="comment">//PTree为指针，用-&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="主函数的参数"><a href="#主函数的参数" class="headerlink" title="主函数的参数"></a>主函数的参数</h1><ol>
<li>主函数的参数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[]</span><br></pre></td></tr></table></figure>
argc是控制台传入主函数的字符串个数，而argv是指针数组，本质是二级指针</li>
<li>过程<br>首先切换到可执行程序所在目录(第一个字符),接着输入要传入主函数的参数<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/main.png" alt></li>
</ol>
<h1 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h1><ol>
<li>定义：类型名 (*变量名）（参数表列）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></li>
<li>通过指针变量来访问函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">p=<span class="built_in">max</span>;<span class="comment">//不能再其后加上参数列表，ex：p=max(*P)(a,b);</span></span><br><span class="line">c=(*P)(a,b);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> z,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"> <span class="comment">//交换两数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>函数指针进行自加和+n都是无意义的</li>
<li>函数指针可以作为参数传入函数，这样在函数中就可以调用实参函数</li>
</ol>
<p>#各种指针的区分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;<span class="comment">//整数</span></span><br><span class="line"><span class="keyword">int</span> *P;<span class="comment">//指针指向整型</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];<span class="comment">//数组</span></span><br><span class="line"><span class="keyword">int</span> *p[<span class="number">4</span>];<span class="comment">//行指针，每行4个元素</span></span><br><span class="line"><span class="keyword">int</span> (*P)[<span class="number">4</span>];<span class="comment">//指针数组，元素类型为指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;<span class="comment">//函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">P</span><span class="params">()</span></span>;<span class="comment">//返回值是整型指针的函数</span></span><br><span class="line"><span class="keyword">int</span> (*P)();<span class="comment">//指向函数的指针</span></span><br><span class="line"><span class="keyword">int</span> **P;<span class="comment">//二级指针，存放的是指针的地址</span></span><br><span class="line"><span class="keyword">void</span> *P;<span class="comment">//只返回地址不返回数据类型的指针</span></span><br></pre></td></tr></table></figure>

<h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><ol>
<li>四种函数，malloc,calloc,realloc,free</li>
<li>malloc函数(动态内存分配，链表创建的基础)：其函数原型为void <em>malloc(unsigned int size)，size是输入数据的长度，返回类型是void</em>类型，需要指定类型。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Head = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));<span class="comment">//定义头节点</span></span><br><span class="line"><span class="comment">//node是重命名后的结构体变量名(即相当与指定int*类型指针一样，sizeof()*n用来计算n个结构体的长度。</span></span><br></pre></td></tr></table></figure></li>
<li>realloc(再分配函数)<br>用来冲新分配内存，原型是：(void<em>)realloc(void</em> ptr,size_t size);<br>ptr是需要重新分配内存的指针所指向的空间，size是新的内存空间大小。</li>
</ol>
<ul>
<li>size可以比原来大或者小，当内存不够用时，就可以调用realloc来重新分配内存</li>
<li>如果ptr指向NULL，那么作用和malloc是一样的，而size值为0时，ptr指向的空间就会被释放，类似free()。</li>
<li>注意点：</li>
<li>ptr必须是在动态内存分配成功的指针，像int *i，int a[2]这样的指针时不行的，即只有通过malloc，calloc，realloc分配成功的指针才能被再次分配内存</li>
<li>再分配成功后，原来ptr指针就会被系统回收，一定不能对ptr指针做任何操作，包扩free，但是可以对realloc的返回值进行正常操作</li>
<li>如果扩大内存，就会把数据复制到新地址（新地址可能与原地址相同也可能不同，单依旧不能对原地址进行任何操作），如果是缩小内存，原数据会被复制并截取新长度</li>
<li>如果分配失败，ptr指向的内存不会被释放，内容也不会被改变，依然可以正常使用<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> input,n;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* numbers = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span>* more_numbers = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"Enter an integer value (0 to end): "</span>);<span class="comment">//输入0表示结束</span></span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;input);</span><br><span class="line">        count++;<span class="comment">//每次递增，表示内存分配的空间，因为realloc是复制再重新分配，而不是在原地址直接增加内存，因此要递增</span></span><br><span class="line">        more_numbers = (<span class="keyword">int</span>*) <span class="built_in">realloc</span> (numbers, count * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//分配count个空间</span></span><br><span class="line">        <span class="keyword">if</span> (more_numbers!=<span class="literal">NULL</span>) &#123;<span class="comment">//如果分配内存成功，那么more_numbers就非空</span></span><br><span class="line">            numbers=more_numbers;<span class="comment">//将numbers指向more_numbers</span></span><br><span class="line">            numbers[count<span class="number">-1</span>]=input;<span class="comment">//调用内存分配的函数都是连续空间，因此类似数组，可以用下标来访问。只不过内存大小shi可以改变的，即动态数组</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">free</span> (numbers);<span class="comment">//失败就释放指针</span></span><br><span class="line">            <span class="built_in">puts</span> (<span class="string">"Error (re)allocating memory"</span>);</span><br><span class="line">            <span class="built_in">exit</span> (<span class="number">1</span>);<span class="comment">//非正常运行导致程序退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(input!=<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"Numbers entered: "</span>);</span><br><span class="line">    <span class="keyword">for</span> (n=<span class="number">0</span>;n&lt;count;n++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,numbers[n]);</span><br><span class="line">    <span class="built_in">free</span> (numbers);</span><br><span class="line">    system(<span class="string">"pause"</span>);<span class="comment">//暂停</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>calloc</li>
</ol>
<ul>
<li>原型：void* calloc(unsigned n,unsignedsize);n是要开辟的元素个数，size是字节大小</li>
<li>与malloc的区别：calloc一般是用来给数组扩大空间的，并且会对分配的内存全部初始化为0，会降低程序的运行效率<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//calloc相当于</span></span><br><span class="line">p=<span class="built_in">malloc</span>();</span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="built_in">size</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="5">
<li>free函数</li>
</ol>
<ul>
<li>原型：void free(void *p);</li>
<li>作用是释放p所指向的内存空间，p应为最近一次调用内存分配的函数，无返回值</li>
</ul>
<h1 id="链表-哈希表的基础"><a href="#链表-哈希表的基础" class="headerlink" title="链表(哈希表的基础)"></a>链表(哈希表的基础)</h1><ol>
<li><p>链表的实质就是由结构体转变而来，不过多了一个指针域。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; node ;<span class="comment">//重命名结构体变量，方便下一步</span></span><br></pre></td></tr></table></figure>
<p>重命名typedef可以避免字母打错等错误。</p>
</li>
<li><p>头节点：是链表的第一个节点，一般不存放数据(用来指向整个链表)。</p>
</li>
<li><p>malloc函数(动态内存分配，链表创建的基础)：其函数原型为void <em>malloc(unsigned int size)，size是输入数据的长度，返回类型是void</em>类型，需要指定类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Head = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));<span class="comment">//定义头节点</span></span><br><span class="line"><span class="comment">//node是重命名后的结构体变量名(即相当与指定int*类型指针一样，sizeof()*n用来计算n个结构体的长度。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>！！！链表建立时都是建的结构体指针，而不是结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node *Head;</span><br><span class="line">node *pend;</span><br><span class="line">node *pnew;</span><br></pre></td></tr></table></figure></li>
<li><p>建立流程：</p>
<ul>
<li>定义头节点(Head)，尾节点(pend)，新节点(pnew)<br>由于要用头节点来指向整个链表，数据域不赋值，因此需要一个节点来代替头节点进行节点的更替。</li>
<li>确定输入多少个值(由具体情况而定)，每次输入都要为pnew动态分配内存，输入值赋给新节点的数据域，旧节点的指针域指向新节点，新节点变为旧节点。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node *Head;<span class="comment">//创建头节点</span></span><br><span class="line">     Head = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">   Head-&gt;next = <span class="literal">NULL</span>;<span class="comment">// 头节点后面没有新节点，所以是NULL</span></span><br><span class="line">   node *pnew,*pend;</span><br><span class="line">   pend = Head;<span class="comment">// 当输入数据为0个时，尾节点就等于头节点，用尾节点代替头节点进行连接操作</span></span><br><span class="line">   <span class="keyword">int</span> n;</span><br><span class="line">   <span class="keyword">for</span>(;n!=<span class="number">-1</span>;)&#123;</span><br><span class="line">     pnew = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));<span class="comment">//为新节点分配内存</span></span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">     pnew-&gt;data = n;<span class="comment">// 新节点的数据域赋值为n</span></span><br><span class="line">     pend-&gt;next = pnew; <span class="comment">//旧节点的指针域指向新节点，不然下一步无法完成，因为旧节点没有新节点的地址，没有办法找到新节点</span></span><br><span class="line">     pend = pnew; <span class="comment">//新节点变为旧节点</span></span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> pend-&gt;next = <span class="literal">NULL</span>;<span class="comment">// 尾节点的指针域赋为NULL，表示后面没有新元素</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h1 id="结构体和链表中的问题"><a href="#结构体和链表中的问题" class="headerlink" title="结构体和链表中的问题"></a>结构体和链表中的问题</h1><ol>
<li>头节点，首元节点， 头指针的区别：链表分为带头节点和不带头节点两种，带头结点的链表的头指针指向的第一个节点的数据域是空的(有时用来存放链表的长度)，头节点的指针域指向首元节点，不带头节点的链表的头指针指向首元节点，首元节点是存储数据的第一个节点。头节点存在的作用是为了使操作统一化，不用考虑对首元节点操作的特殊情况</li>
<li>不带头节点是，如果对首元节点进行增删的操作的话，会改变头指针的值，解决办法有两种，一种是用二级指针指向头指针，这样就是二级指针的值在变化，另一种是返回新的头指针</li>
<li>删除首元节点：直接将头节点指向头节点之后的节点就可以</li>
<li>链表的增删查改都是通过指针移动到目标节点，在为pre和p赋值，而不是直接用p和pre向后走，这样经常容易出错</li>
<li>永远不对头指针直接进行操作，一旦头指针改变，就找不会完整的链表，用工作指针来进行操作</li>
<li>单链表的逆序是不能向数组那样简单的头尾颠倒，因为单链表的指向是单向的，只能指向后一个节点，用双链表就可以直接换，单链表用头插法重新建立链表输出</li>
<li>如果想建立不带头节点的单链表的话，while中的if(head==NULL)中才能为head分配空间，因为一旦分配空间后head的值就会改变，不再是NULL，也就无法进入if语句</li>
<li>两个有序链表的合并</li>
</ol>
<h1 id="有序链表的合并"><a href="#有序链表的合并" class="headerlink" title="有序链表的合并"></a>有序链表的合并</h1><ol>
<li>单链表的可以用选择插入，一边比较一边插入<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">先🕊了</span><br></pre></td></tr></table></figure></li>
<li>或者连接完后在进行排序</li>
</ol>
<h1 id="文件操作有关函数"><a href="#文件操作有关函数" class="headerlink" title="文件操作有关函数"></a>文件操作有关函数</h1><ol>
<li>ftell() 函数用于得到文件位置指针当前位置相对于文件首的偏移字节数；</li>
<li>B中fseek()函数用于设置文件指针的位置；</li>
<li>C中rewind()函数用于将文件内部的位置指针重新指向一个流(数据流/文件)的开头；</li>
<li>D中ferror()函数可以用于检查调用输入输出函数时出现的错误。</li>
<li>若读文件还未读到文件末尾， feof()函数的返回值是（ 0），到尾返回-1，一般不适用eof判断是否末尾，应为eof要返回两次才能确定结束，<br>用fgetc==NULL判断更方便</li>
<li>已知函数的调用形式fread(buffer, size, count, fp)；其中buffer代表的是一个指针，指向要读入数据的存放地址。</li>
<li>字符串赋值结束后要加上结束标志0。</li>
<li>二进制文件现在一般使用的是dat后缀，但实际上不止这些，像jpg，avi等文件本质上也是一种二进制文件，不过由于需要特定的解码器打开，后缀名有所不同</li>
<li>fscanf和fread返回值是读到的数据个数</li>
<li>如果文件名要从键盘输入的话，就得在fopen里面的文件地址不加双引号，加了就是字符数组名，而我们要传的是指针</li>
</ol>
<h1 id="有时只有先判断条件符不符合时才能进入下一步，就先输入判断是否能进入循环体，再在循环体的末尾输入"><a href="#有时只有先判断条件符不符合时才能进入下一步，就先输入判断是否能进入循环体，再在循环体的末尾输入" class="headerlink" title="有时只有先判断条件符不符合时才能进入下一步，就先输入判断是否能进入循环体，再在循环体的末尾输入"></a>有时只有先判断条件符不符合时才能进入下一步，就先输入判断是否能进入循环体，再在循环体的末尾输入</h1><h1 id="文本文件与二进制文件的区别"><a href="#文本文件与二进制文件的区别" class="headerlink" title="文本文件与二进制文件的区别"></a>文本文件与二进制文件的区别</h1><ol>
<li>文本文件本质上是一个二级制文件，在进行读写时，需要翻译，而二进制文件不需要，读写速度更快</li>
<li>文本文件已于理解，二进制不易阅读和理解</li>
<li>文本文件的利用率低，有的字符拥有过大的空间，占用内存大，二进制利用率高，占用内存少</li>
<li>不同系统对文本文件的转义字符操作有所不同，因此需要针对操作系统作对应的更改，移植性差，二进制文件直接可以读写，移植性高</li>
<li>文本文件对对应解码器的要求低，记事本基本上可以打开所有文本，但不同类型的二级制文件需要相应的解码器才能浏览</li>
</ol>
<p>#GetMemory</p>
<ol>
<li><p>栈中分配局部变量空间，是系统自动分配空间。定义一个 char a；系统会自动在栈上为其开辟空间。由于栈上的空间是自动分配自动回收的，所以栈上的数据的生存周期只是在函数的运行过程中，运行后就释放掉，不可以再访问。<br>堆区分配程序员申请的内存空间，堆上的数据只要程序员不释放空间，就一直可以访问到，不过缺点是一旦忘记释放会造成内存泄露。<br>静态区是分配静态变量，全局变量空间的。<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E5%AD%98%E5%82%A8%E5%88%86%E5%B8%83.png" alt></p>
</li>
<li><p><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/GetMemory1.png" alt> </p>
</li>
</ol>
<p>分析：<br>毛病出在函数GetMemory1 中。编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 _p，编译器使 _p = p。如果函数体内的程序修改了_p的内容，就导致参数p的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，_p申请了新的内存，只是把 _p所指的内存地址改变了，但是p丝毫未变。所以函数GetMemory并不能输出任何东西。事实上，每执行一次GetMemory1就会泄露一块内存，因为没有用free释放内存。Test1中调用GetMemory1时，函数参数为str的副本不是str本身</p>
<ol start="3">
<li><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/GetMemory2.png" alt><br>结果：输出hello<br>分析：动态分配的内存不会自动释放；<br>没有测试是否成功分配了内存，应该有if (*p == NULL) { ……} 之类的语句处理内存分配失败的其情况。</li>
<li><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/GetMemory3.png" alt><br>结果：输出乱码。<br>分析：字符数组p存在于栈空间，是局部变量，函数返回后，内存空间被释放，因此输出无效值。字符数组的值是可以修改的，例如p[0] = ‘t‘。</li>
<li><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/GetMemory4.png" alt><br>结果：输出hello<br>分析：p指向的是字符串常量，字符串常量保存在只读的数据段，是全局区域，但不是像全局变量那样保存在普通数据段（静态存储区）。无法对p所指的内存的内容修改，例如p[0] = ‘y;这样的修改是错误的。</li>
<li><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/GetMemory5.png" alt><br>结果：输出hello<br>分析：直接返回常量区。</li>
<li><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/GetMemory6.png" alt><br>结果：能够输出world，但程序存在问题。<br>分析：程序出现了野指针。</li>
<li>野指针只会出现在像C和C++这种没有自动内存垃圾回收功能的高级语言中, 所以java或c#肯定不会有野指针的概念. 当我们用malloc为一个指针分配一个空间后, 用完这个指针，把它free掉，但是没有让这个指针指向NULL或某一个特定的空间。如上面程序一样，将str进行free后，只是释放了指针所指的内存，但指针并没有释放掉，此时指针所指的是垃圾内存；这样的话，if语句永为真，if判断无效。delete也存在同样的问题。<br>防止产生野指针：（1）指针变量一定要初始化为NULL，因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。（2）当free或delete后，将指针指向NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。</li>
</ol>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>定义：根据哈希函数和冲突处理办法将数据存储在一段连续的空间中(就是数组)。</p>
<p>不同于其他查找函数需要对值进行匹配，哈希表在建立时为每一个数据建立一个独一无二的关键字，这样查找时可以根据关键字直接找到数据。就相当于map集合。</p>
<h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><p>哈希函数需要满足两个条件，假设哈希表有m个关键字，则取值范围是<br>[0，m-1]。</p>
<ol>
<li>哈希函数的值域必须在[0，m-1]的范围内。</li>
<li>保证哈希函数的每个值在[0,m-1]内的概率相等。</li>
</ol>
<hr>
<h1 id="哈希函数的几种办法"><a href="#哈希函数的几种办法" class="headerlink" title="哈希函数的几种办法"></a>哈希函数的几种办法</h1><ol>
<li>直接定址法：适用与线性数据，比如年龄，日期等</li>
<li>数字分析法：适用与某些数据中有大量重复字段，且可以预知全部的可能出现的值，取其中若干的字段作为关键字。</li>
<li>平方取中法：适用与字段较短，可以先平方，再取中间的字段作为关键字，因为中间的字段与每个数据都有关系，可以增加概率的平均性。</li>
<li>折叠法：将关键值分割为几个位数相同的部分，取这几个部分的叠加和作为哈希地址。</li>
</ol>
<ul>
<li>移位叠加<br>   各部分按照最低位对齐（舍去进位，即相加后多出切割位的数字），然后相加。</li>
<li>间界叠加<br>   关键字值从一端向另一端沿分界线来回折叠，然后对齐相加。</li>
</ul>
<ol start="5">
<li>除留余数法：被除数必须是素数，否则会出现关键字大量重复。（最大公倍数原理）</li>
</ol>
<hr>
<h1 id="处理冲突方法"><a href="#处理冲突方法" class="headerlink" title="处理冲突方法"></a>处理冲突方法</h1><p>当哈希函数值相同时，位置已经被其他数据占用，则按照冲突处理方法寻找下一个位置。</p>
<ol>
<li>开放定址法：令Hi=(H(key)+di)%m,其中H(key)时哈希函数，di是增量序列。</li>
</ol>
<ul>
<li>若di取1，2，3，4….m-1，则为线性探测再散列。</li>
<li>若di取1^2,-1^2,2^2,-2^2..+k^2,-k^2,则为二次探测再散列。</li>
<li>若di取伪随机数序列，则称伪随机探测再散列。</li>
</ul>
<ol start="2">
<li>链表寻址法： 对重复数据建立链表，并且将每个链表有序排列，</li>
<li>公共溢出区法： 将哈希表的一部分作为公共区，重复数据依次放入。</li>
</ol>
<hr>
<h1 id="哈希表中查找元素"><a href="#哈希表中查找元素" class="headerlink" title="哈希表中查找元素"></a>哈希表中查找元素</h1><p>  与插入的方法差不多，按关键字寻找，遇到冲突按照法则寻找。</p>
<p>#哈希表的基本操作</p>
<ol>
<li>当插入数据的索引是数字时，将数字作为数组的下标就可以，但是当数据索引时字符串时，就需要先把字符串转为数字在存入数组<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">pInfo <span class="title">init_hashTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  pInfo <span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Info) * MAX);<span class="comment">//为哈希表分配空间，哈希表本质是一块数组，每个元素就是存储的数据节点。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_hashTable</span><span class="params">(pInfo info,Info Node)</span> </span>&#123;</span><br><span class="line">  info[Node.key] = Node;<span class="comment">//直接将数据节点的索引作为哈希表的下标，但是这样一定会出现重复的数据索引，解决方法在下面。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Info <span class="title">find_HashTable</span><span class="params">(pInfo info,<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> info[key];<span class="comment">//直接返回索引所指向的空间即可，非常快速。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当索引是字符串时，进行转换，有三种方式，第一种是将字符串逐个转为ASCII码，累加得出哈希值,但是这样任然会出现重复值，因为aaa和abc的ASCII码是一样的。这时就要用到第二种方法，使用幂的连乘。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stringToInt_hashTable</span><span class="params">(<span class="keyword">char</span>* data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> hashCode = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (*data!=<span class="string">'\0'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    hashCode += *data - <span class="number">96</span>;</span><br><span class="line">    data++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>幂的连乘,例如abc就是a-96=1<em>27^1,b-96=2</em>27^2,c=3*27^3,然后这三个数加起来就是连乘的数字，选27是因为空格加64个字母正好是27个，这样就不可能有相同的哈希值的出现。因为对于每一个字母而言，各自的排列都是唯一的，相当于uuid。但是这样也有弊处就是哈希值非常大，经常会发送数组越界，这时就需要改进，改进的方法就是压缩，将大小控制在数组的范围之内。比如abc的哈希值就是60534，内存迟早耗尽<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stringToInt_hashTable</span><span class="params">(<span class="keyword">char</span>* data)</span> </span>&#123;<span class="comment">//ASCII的连乘</span></span><br><span class="line">  <span class="keyword">int</span> hashCode = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> mi = <span class="number">27</span>;</span><br><span class="line">  <span class="keyword">while</span> (*data!=<span class="string">'\0'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    hashCode += (*data - <span class="number">96</span>) * mi;</span><br><span class="line">    mi *= <span class="number">27</span>;</span><br><span class="line">    data++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>为了提高内存的利用率，就需要压缩哈希值。压缩方法就是对数组长度取模。原理是大于数组长度的部分一定可以取模，而剩下的不能取模的部分一定是小于数组长度的，就可以放的下。但是这样任然会有重复值，因为哈希值经过压缩，原来100000个数据经过压缩之后存放到100个内肯定会有冲突。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stringToInt_hashTable</span><span class="params">(<span class="keyword">char</span>* data)</span> </span>&#123;<span class="comment">//ASCII的连乘</span></span><br><span class="line">  <span class="keyword">int</span> hashCode = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> mi = <span class="number">27</span>;</span><br><span class="line">  <span class="keyword">while</span> (*data!=<span class="string">'\0'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    hashCode += (*data - <span class="number">96</span>) * mi;</span><br><span class="line">    mi *= <span class="number">27</span>;</span><br><span class="line">    data++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hashCode%<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>#哈希表解决冲突的办法</p>
<ol>
<li>解决冲突的方法在上面，但是这里主要介绍开放地址法和链地址法。</li>
<li>开放地址法：当出现地址冲突的时候，将哈希值++，寻找下一个可以插入的地方，直到插入完成。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typedef struct Info//数字版,开放地址版</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  int key;</span></span><br><span class="line"><span class="comment">//  char* name;</span></span><br><span class="line"><span class="comment">//&#125;Info ,*pInfo;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef struct Info//字符串版，开放地址版</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  char* key;</span></span><br><span class="line"><span class="comment">//  char* name;</span></span><br><span class="line"><span class="comment">//&#125;Info, * pInfo;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_hashTable</span><span class="params">(pInfo info, Info Node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> index = stringToInt_hashTable(Node.key);</span><br><span class="line">  <span class="keyword">while</span> (info[index].name!=<span class="literal">NULL</span>)<span class="comment">//不使用info[index]因为这样info[index]指向的是Info类型是不能使用NULL的，好像可以使用取地址符&amp;，明天试试</span></span><br><span class="line">  &#123;</span><br><span class="line">    ++index;</span><br><span class="line">    index = index % <span class="number">100</span>;<span class="comment">//这一步非常巧妙，因为如果当目标值到最后的位置都满了，但是目标值前面有空间，就可以插在前面</span></span><br><span class="line">    <span class="comment">//但是由于这时哈希值已经超出了数组的范围，只要在取余就能从头开始，继续寻找。</span></span><br><span class="line">  &#125;</span><br><span class="line">  info[index] = Node;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Info <span class="title">find_HashTable</span><span class="params">(pInfo info, <span class="keyword">char</span>* key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> index = stringToInt_hashTable(key);</span><br><span class="line">  <span class="keyword">while</span> (info[index].name!=<span class="literal">NULL</span>)<span class="comment">//当数据域不为空时就表明这块有数据，并且如果是哈希值相同的话，多余的一定是在它的后面，往后递增一定能找到。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(info[index].key, key) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> info[index];</span><br><span class="line">    &#125;</span><br><span class="line">    ++index;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  pInfo <span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Info));</span><br><span class="line">  <span class="keyword">new</span>-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">new</span>-&gt;name = <span class="string">"没有找到对应的数据，请检查输入是否正确"</span>;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">new</span>;<span class="comment">//返回不了NULL，只能手动置空返回。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stringToInt_hashTable</span><span class="params">(<span class="keyword">char</span>* data)</span> </span>&#123;<span class="comment">//ASCII的连乘，输入abc，哈希值就是(a-96)*27^0+(b-96)*27^1+(c-96)*27^2 = 784</span></span><br><span class="line">    <span class="keyword">int</span> hashCode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mi = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (*data!=<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      hashCode += (*data - <span class="number">96</span>) * mi;</span><br><span class="line">      mi *= <span class="number">27</span>;</span><br><span class="line">      data++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashCode%<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除就是将对应key的数据域置为空，这样就可以避免频繁的移动数组</span></span><br></pre></td></tr></table></figure></li>
<li>链表地址法：采取的是横向的增加方式，冲突的节点不再是往下占用其他的空间，而是在原有哈希值的后面使用链表继续连接。这样可以提高空间的利用率<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Info</span>//字符串版，链地址版,这样的话哈希表中每个元素其实就是一个链表。</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span>* key;</span><br><span class="line">  <span class="keyword">char</span>* name;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Info</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Info, *pInfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">pInfo* <span class="title">init_hashTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  pInfo* <span class="keyword">new</span> = (pInfo*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(pInfo) * MAX);<span class="comment">//这里只是给指针分配了空间，但是指针所指向的空间没有分配空间</span></span><br><span class="line">  <span class="built_in">memset</span>(<span class="keyword">new</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(pInfo) * MAX);<span class="comment">//初始化为0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_linkList</span><span class="params">(pInfo Head, pInfo Node)</span> </span>&#123;</span><br><span class="line">  Node-&gt;next = Head-&gt;next;</span><br><span class="line">  Head-&gt;next = Node;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_hashTable</span><span class="params">(pInfo* info,pInfo Node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> index = stringToInt_hashTable(Node-&gt;key);</span><br><span class="line">  <span class="comment">//不用管有没有数据，直接插入就是，因为有数据和没有数据都是一样的插入流程</span></span><br><span class="line">  <span class="keyword">if</span> (info[index]==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    info[index] = (pInfo)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Info));</span><br><span class="line">    info[index]-&gt;name = <span class="string">"1"</span>;<span class="comment">//表示当前头节点不为空；</span></span><br><span class="line">    insert_linkList(info[index], Node);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  insert_linkList(info[index],Node);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">pInfo <span class="title">find_hashTable</span><span class="params">(pInfo* info,<span class="keyword">char</span> * key )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> index = stringToInt_hashTable(key);</span><br><span class="line">  <span class="keyword">return</span> find_linkList(info[index],key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pInfo <span class="title">find_linkList</span><span class="params">(pInfo Head,<span class="keyword">char</span> * key)</span> </span>&#123;</span><br><span class="line">  pInfo p = Head-&gt;next;</span><br><span class="line">  <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(p-&gt;key,key)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> errorInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stringToInt_hashTable</span><span class="params">(<span class="keyword">char</span>* data)</span> </span>&#123;<span class="comment">//ASCII的连乘</span></span><br><span class="line">    <span class="keyword">int</span> hashCode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mi = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (*data!=<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      hashCode += (*data - <span class="number">96</span>) * mi;</span><br><span class="line">      mi *= <span class="number">27</span>;</span><br><span class="line">      data++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashCode%<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">pInfo <span class="title">errorInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  pInfo error = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Info));</span><br><span class="line">  error-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">  error-&gt;name = <span class="string">"没有找到对应的数据，请检查输入是否正确"</span>;</span><br><span class="line">  <span class="keyword">return</span> error;<span class="comment">//返回不了NULL，只能手动置空返回。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Info a1 = &#123; <span class="string">"a"</span>,<span class="string">"憨憨"</span>,<span class="literal">NULL</span> &#125;;</span><br><span class="line">  Info a2 = &#123; <span class="string">"tc"</span>,<span class="string">"憨憨王"</span>,<span class="literal">NULL</span> &#125;;</span><br><span class="line">  pInfo * myInfo = init_hashTable();</span><br><span class="line">  insert_hashTable(myInfo, &amp;a1);</span><br><span class="line">  insert_hashTable(myInfo, &amp;a2);</span><br><span class="line">  pInfo result = find_hashTable(myInfo, <span class="string">"a"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"键：%s，姓名：%s\n"</span>, result-&gt;key, result-&gt;name);</span><br><span class="line">  pInfo result1 = find_hashTable(myInfo, <span class="string">"tc"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"键：%s，姓名：%s\n"</span>, result1-&gt;key, result1-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>之前失败的原因是因为哈希表分配节点时分配的是Info，用pInfo接受，这样的话哈希表中每个元素其实是节点，而不是链表，这种结构是开放地址法使用的，正确的写法是为每个元素分配pInfo的空间，用pInfo*接收。</li>
</ol>
<p>#求各位数之和新解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">          temp=x%<span class="number">10</span>;<span class="comment">//取出最后一位数</span></span><br><span class="line">          x=x/<span class="number">10</span>;<span class="comment">//去掉最后一位数</span></span><br><span class="line">          y=temp+y*<span class="number">10</span>;<span class="comment">//在还原</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是求出未知数各个位置的和。<br>与之前从第一位开始求不同，这种更方便，无需根据具体位数设置相应个数的变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* run this program using the console pauser or add your own getch, system("pause") or input loop */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line"><span class="keyword">int</span> i,a,b,c,d,e,f,g,t; </span><br><span class="line"><span class="keyword">if</span>(N==<span class="number">3</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">100</span>;i&lt;=<span class="number">999</span>;i++)&#123;</span><br><span class="line">    a=i/<span class="number">100</span>;</span><br><span class="line">    b=(i%<span class="number">100</span>)/<span class="number">10</span>;</span><br><span class="line">    c=(i%<span class="number">100</span>)%<span class="number">10</span>;</span><br><span class="line">  t=a*a*a+b*b*b+c*c*c;</span><br><span class="line">    <span class="keyword">if</span>((a*<span class="number">100</span>+b*<span class="number">10</span>+c)==t)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a*<span class="number">100</span>+b*<span class="number">10</span>+c);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(N==<span class="number">4</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1000</span>;i&lt;=<span class="number">9999</span>;i++)&#123;</span><br><span class="line">    a=i/<span class="number">1000</span>;</span><br><span class="line">    b=i%<span class="number">1000</span>/<span class="number">100</span>;</span><br><span class="line">    c=i%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">    d=i%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">  t=a*a*a*a+b*b*b*b+c*c*c*c+d*d*d*d;</span><br><span class="line">    <span class="keyword">if</span>((a*<span class="number">1000</span>+b*<span class="number">100</span>+c*<span class="number">10</span>+d)==t)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"> <span class="keyword">if</span>(N==<span class="number">5</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">10000</span>;i&lt;<span class="number">99999</span>;i++)&#123;</span><br><span class="line">    a=i/<span class="number">10000</span>;</span><br><span class="line">    b=(i%<span class="number">10000</span>)/<span class="number">1000</span>;</span><br><span class="line">    c=(i%<span class="number">10000</span>)%<span class="number">1000</span>/<span class="number">100</span>;</span><br><span class="line">    d=(i%<span class="number">10000</span>)%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">    e=(i%<span class="number">10000</span>)%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">  t=a*a*a*a*a+b*b*b*b*b+c*c*c*c*c+d*d*d*d*d+e*e*e*e*e;</span><br><span class="line">    <span class="keyword">if</span>(a*<span class="number">10000</span>+b*<span class="number">1000</span>+c*<span class="number">100</span>+d*<span class="number">10</span>+e==t)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">if</span>(N==<span class="number">6</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">100000</span>;i&lt;<span class="number">999999</span>;i++)&#123;</span><br><span class="line">    a=i/<span class="number">100000</span>;</span><br><span class="line">    b=i%<span class="number">100000</span>/<span class="number">10000</span>;</span><br><span class="line">    c=i%<span class="number">100000</span>%<span class="number">10000</span>/<span class="number">1000</span>;</span><br><span class="line">    d=i%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>/<span class="number">100</span>;</span><br><span class="line">    e=i%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">    f=i%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">  t=a*a*a*a*a*a+b*b*b*b*b*b+c*c*c*c*c*c+d*d*d*d*d*d+e*e*e*e*e*e+f*f*f*f*f*f;</span><br><span class="line">    <span class="keyword">if</span>((a*<span class="number">100000</span>+b*<span class="number">10000</span>+c*<span class="number">1000</span>+d*<span class="number">100</span>+e*<span class="number">10</span>+f)==t)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a*<span class="number">100000</span>+b*<span class="number">10000</span>+c*<span class="number">1000</span>+d*<span class="number">100</span>+e*<span class="number">10</span>+f);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">if</span>(N==<span class="number">7</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1741723</span>;i&lt;<span class="number">9999999</span>;i++)&#123;</span><br><span class="line">    a=i/<span class="number">1000000</span>;</span><br><span class="line">    b=i%<span class="number">1000000</span>/<span class="number">100000</span>;</span><br><span class="line">    c=i%<span class="number">1000000</span>%<span class="number">100000</span>/<span class="number">10000</span>;</span><br><span class="line">    d=i%<span class="number">1000000</span>%<span class="number">100000</span>%<span class="number">10000</span>/<span class="number">1000</span>;</span><br><span class="line">    e=i%<span class="number">1000000</span>%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>/<span class="number">100</span>;</span><br><span class="line">    f=i%<span class="number">1000000</span>%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">    g=i%<span class="number">1000000</span>%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">    t=a*a*a*a*a*a*a+b*b*b*b*b*b*b+c*c*c*c*c*c*c+d*d*d*d*d*d*d+e*e*e*e*e*e*e+f*f*f*f*f*f*f+g*g*g*g*g*g*g;</span><br><span class="line">  <span class="keyword">if</span>((a*<span class="number">1000000</span>+b*<span class="number">100000</span>+c*<span class="number">10000</span>+d*<span class="number">1000</span>+e*<span class="number">100</span>+f*<span class="number">10</span>+g)==t)</span><br><span class="line">                          <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a*<span class="number">1000000</span>+b*<span class="number">100000</span>+c*<span class="number">10000</span>+d*<span class="number">1000</span>+e*<span class="number">100</span>+f*<span class="number">10</span>+g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然上面也可以用for循环+pow函数但还是不够简便。</p>
<hr>
<h1 id="逆序数输出（由末位新解联想）"><a href="#逆序数输出（由末位新解联想）" class="headerlink" title="逆序数输出（由末位新解联想）"></a>逆序数输出（由末位新解联想）</h1><ol>
<li><p>数学法：通过末尾取余将末尾数取出，在依次*10，便能输出逆序数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> number,x,t=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">  <span class="keyword">while</span>(number!=<span class="number">0</span>)&#123;</span><br><span class="line">    t=t*<span class="number">10</span>+number%<span class="number">10</span>;  <span class="comment">//每次t向前移动一位</span></span><br><span class="line">      number/=<span class="number">10</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,t);   </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串法：转为字符串逆序输出。。。。。</p>
</li>
</ol>
<hr>
<h1 id="另一种应用-回文数"><a href="#另一种应用-回文数" class="headerlink" title="另一种应用(回文数)"></a>另一种应用(回文数)</h1><ol>
<li><p>存为数组，用a[i]与a[n-i-1]相互比较</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(a[i]!=a[n-i<span class="number">-1</span>])&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"false"</span>);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line">   flag++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"true"</span>);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>反转一半数：用末尾数新解，对输入数后一半进行逆序排序，将它和变化后的number比较。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> number,t=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">  <span class="keyword">if</span>(number&lt;<span class="number">0</span>||(number%<span class="number">10</span>==<span class="number">0</span>&amp;&amp;number!=<span class="number">0</span>))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"false"</span>);         <span class="comment">// 数字为负数或者末尾是0但首位肯定不是0，就不可能是回文数</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(number&gt;t)&#123; <span class="comment">//当number&gt;t时，说明t的位数比number小，即没有到中间，并且中间数肯定等于自身，不需判定。</span></span><br><span class="line">      t=t*<span class="number">10</span>+number%<span class="number">10</span>;</span><br><span class="line">      number/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(number==t)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"true"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"false"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h1 id="p-和P-i的区别"><a href="#p-和P-i的区别" class="headerlink" title="p++和P+i的区别"></a>p++和P+i的区别</h1><ol>
<li>p++操作完后指针已经移位,要想重新输出,就要另设新指针,令新指针指向数组首地址才能继续输出,否则输出的是随机数,容易忘记,所以用p+i更加保险</li>
<li>数组名相当于指针常量,是不能像指针一样变动的,所以将数组名更改后数组的任然是原数组,不会变</li>
</ol>
<h1 id="数组的转置"><a href="#数组的转置" class="headerlink" title="数组的转置"></a>数组的转置</h1><ol>
<li>建立一个新数组，将i和j颠倒重新输入，就能转置</li>
<li>将左对角线右上方的数组元素与主对角线左下方的数组元素进行单方向交换<br>不一定是方阵，可以是任意MxN的矩阵<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j&gt;i)</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">/*将主对角线右上方的数组元素与主对角线左下方的数组元素进行单方向交换*/</span></span><br><span class="line"></span><br><span class="line">temp=n[i][j];</span><br><span class="line"></span><br><span class="line">n[i][j]=n[j][i];</span><br><span class="line"></span><br><span class="line">n[j][i]=temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"转置矩阵：\n"</span>);</span><br></pre></td></tr></table></figure></li>
<li>用第一种方法转置后，如果i和j不一样大，那么就得新建立一个长为m的行指针，<br>不然会出现运行时错误<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*P)[<span class="number">3</span>];<span class="comment">//原来是3x2矩阵</span></span><br><span class="line"><span class="keyword">int</span> (*a)[<span class="number">2</span>];<span class="comment">//转置后变为2x3矩阵，就要重新定义行指针</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="数组名不能自加仅限在同一函数中，传入函数时，函数规定的类型是指针类型，相当于将数组名的地复制了一份"><a href="#数组名不能自加仅限在同一函数中，传入函数时，函数规定的类型是指针类型，相当于将数组名的地复制了一份" class="headerlink" title="数组名不能自加仅限在同一函数中，传入函数时，函数规定的类型是指针类型，相当于将数组名的地复制了一份"></a>数组名不能自加仅限在同一函数中，传入函数时，函数规定的类型是指针类型，相当于将数组名的地复制了一份</h1><p>传给了形参列表中的参数，因此可以对形参自加</p>
<p>#数据结构</p>
<ol>
<li>根据视点的不同可以将数据结构分为逻辑结构和物理结构</li>
<li>逻辑结构</li>
</ol>
<ul>
<li>集合结构<br>集合结构中的元素同属于一个集合，元素之间没有关系，是平等的。<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84.png" alt></li>
<li>线性结构<br>线性结构中的元素之间是一对一的关系（除第一和最后一个元素外，每个元素都有唯一的前驱和后继）<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.png" alt></li>
<li>树形结构，数据元素之间存在一对多的层次关系<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.png" alt></li>
<li>图形结构，数据元素之间存在多对多的层次关系<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E5%9B%BE%E5%BD%A2%E7%BB%93%E6%9E%84.png" alt></li>
</ul>
<ol start="3">
<li>物理结构就是顺序存储（数组）和链式存储（链表）</li>
</ol>
<p>##线性结构（动态数组）</p>
<ol>
<li><p>动态数组<br>动态数组实质上是一个结构体，其中有指向堆区一维数组的二级指针（void**可以表示任意类型的二级指针，有点类似与java中的泛型），还有当前数组的长度和数组的最大容量<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84.png" alt></p>
</li>
<li><p>动态数组的初始化<br>首先判断输入的初始化数量是否小于0，在为结构体申请内存，再次判断结构体是否分配内存成功，成功则更新最大容量和初始化当前元素个数为0，在为二级指针在堆区上分配初始化个数的一级指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dynamicArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> ** pAddr;</span><br><span class="line">  <span class="keyword">int</span> m_size;</span><br><span class="line">  <span class="keyword">int</span> capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct dynamicArray* <span class="title">init_dynamicArray</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (capacity&lt;=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dynamicArray</span> * <span class="title">array</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">dynamicArray</span>));</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">array</span>==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">array</span>-&gt;m_capacity = capacity;</span><br><span class="line">  <span class="built_in">array</span>-&gt;m_size = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">array</span>-&gt;pAddr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">void</span>*)*<span class="built_in">array</span>-&gt;m_capacity);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>动态数组的插入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_dynamicArray</span><span class="params">(struct dynamicArray* <span class="built_in">array</span>,<span class="keyword">int</span> pos,<span class="keyword">void</span> * data)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">array</span>==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (data==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pos&lt;<span class="number">0</span>||pos&gt;<span class="built_in">array</span>-&gt;m_size)</span><br><span class="line">  &#123; <span class="comment">//尾插</span></span><br><span class="line">      pos = <span class="built_in">array</span>-&gt;m_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断是否满载</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">array</span>-&gt;m_size&gt;=<span class="built_in">array</span>-&gt;m_capacity)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//定义新的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = <span class="built_in">array</span>-&gt;m_capacity*<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//申请新的更大空间</span></span><br><span class="line">    <span class="keyword">void</span> **newSpace = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">void</span>*)*newCapacity);</span><br><span class="line">    <span class="comment">//将之前的数据复制</span></span><br><span class="line">    <span class="built_in">memcpy</span>(newSpace,<span class="built_in">array</span>-&gt;pAddr,<span class="built_in">array</span>-&gt;m_size);</span><br><span class="line">    <span class="comment">//释放之前的空间</span></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>-&gt;pAddr);</span><br><span class="line">    <span class="comment">//更改指针指向</span></span><br><span class="line">    <span class="built_in">array</span>-&gt;pAddr=newSpace;</span><br><span class="line">    <span class="comment">//更新元素个数</span></span><br><span class="line">    <span class="built_in">array</span>-&gt;m_size++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态数组的遍历<br>动态数组中由于存储的是void* 数据，因此需要用户指定存入的数据类型，就需要回调函数的出现<br>什么是回调函数？简单说就是方法A调用方法B，方法B执行完之后将数据返回给方法A，由方法A继续处理，详细知识看<a href="https://www.zhihu.com/question/19801131" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foreach_dynamicArray</span><span class="params">(struct dynamicArray* <span class="built_in">array</span>,<span class="keyword">void</span>(*myPrint)(<span class="keyword">void</span> *))</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">array</span>==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (myPrint==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>-&gt;m_size; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    myPrint(<span class="built_in">array</span>-&gt;pAddr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在myPrint函数中用户自定义输出数据的类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">void</span>* data)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p</span> = <span class="title">data</span>;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"姓名：%s，年龄：%d"</span>, p-&gt;name, p-&gt;age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态数组的删除<br>删除的思想不是释放资源，而是覆盖，用后面的数据覆盖前面的数据，这里提供两种，分别是按pos删除和按值删除，其中有个巧妙的点就是，按值删除其实就是调用按pos删除，将值对应的pos传入即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeByPos_dynamicArray</span><span class="params">(struct dynamicArray * <span class="built_in">array</span>,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">array</span>==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pos&lt;<span class="number">0</span>||pos&gt;m_size)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; <span class="built_in">array</span>-&gt;m_size<span class="number">-1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">array</span>-&gt;pAddr[i]=<span class="built_in">array</span>-&gt;pAddr[i+<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值删除也需要一个回调函数来判断两个void数据是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeByValue_dynamicArray</span><span class="params">(struct dynamicArray* <span class="built_in">array</span>, <span class="keyword">void</span> * data,<span class="keyword">int</span>(*myCompare)(<span class="keyword">void</span>*,<span class="keyword">void</span>*))</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">array</span>==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (data==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>-&gt;m_size; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (myCompare(<span class="built_in">array</span>-&gt;pAdrr[i],data))</span><br><span class="line">    &#123;</span><br><span class="line">      removeByPos_dynamicArray(<span class="built_in">array</span>, i);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">void</span>* data1, <span class="keyword">void</span>* data2)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> *<span class="title">p1</span> = <span class="title">data1</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> *<span class="title">p2</span> = <span class="title">data2</span>;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1-&gt;name, p2-&gt;name) == <span class="number">0</span> &amp;&amp; p1-&gt;age == p2-&gt;age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>##受限线性结构（链表）</p>
<p>##受限线性结构（栈）</p>
<ol>
<li>首先栈是线性表，具有线性关系即有前驱和后继，只不过比较特殊，不能在任意位置插入数据，只能在线性表尾部插入数据，注意这里的线性表尾部指栈顶而不是栈底。因此实现了先进后出的效果<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E6%A0%88.png" alt></li>
<li>特性：先进后出，是一种只能对表尾进行插入和删除的运算受限线性表，将表尾称作栈顶，另一端称为栈底，插入删除元素分别叫做入栈(push)和出栈(pop)。</li>
</ol>
<p>##网盘视频中的基于数组的栈</p>
<ol>
<li>视频中的栈使用的是void*指针来代表所有类型数据，不需要像下面的修改dataType的类型，更加通用，并且这种结构更加简便，符合优美代码的属性<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E6%A0%88.png" alt></li>
</ol>
<ul>
<li><p>栈的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1024</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> * data[<span class="number">1024</span>];<span class="comment">//使用的是数组，下面的那种是动态的可以增加的</span></span><br><span class="line">  <span class="keyword">int</span> m_size;<span class="comment">//栈的大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>栈的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">init_stack</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//初始化申请的是结构体</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SStack</span> * <span class="title">stack</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">SStack</span>));</span><span class="comment">//c语言中对类型检查不是很严格，void指针可以赋给任意类型的指针，编译器会在编译时自动转换，而c++有严格的类型检查，void*可以接受任意类型的指针，但是不能赋给任意的指针，除非显式转换</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span>==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将data初始化为0</span></span><br><span class="line">  <span class="built_in">memset</span>(<span class="built_in">stack</span>-&gt;data,<span class="number">0</span>,MAX*<span class="keyword">sizeof</span>(<span class="keyword">void</span>*));</span><br><span class="line">  <span class="comment">//初始化size为0</span></span><br><span class="line">  <span class="built_in">stack</span>-&gt;m_size=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>入栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_stack</span><span class="params">(<span class="keyword">void</span>* <span class="built_in">stack</span>, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (data == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断是否栈满 </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SStack</span>* <span class="title">myStack</span> = <span class="title">stack</span>;</span></span><br><span class="line">  <span class="comment">//如果栈满就不能在插入数据</span></span><br><span class="line">  <span class="keyword">if</span> (myStack-&gt;m_size == MAX)</span><br><span class="line">  &#123;<span class="comment">//后续可以改进，使得不够就可以在加，将myStack-&gt;data重定向就可，使用动态数组的技术。</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  myStack-&gt;data[myStack-&gt;m_size] = data;<span class="comment">//入栈，尾插</span></span><br><span class="line">  myStack-&gt;m_size++;<span class="comment">//跟新栈大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>出栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_stack</span><span class="params">(<span class="keyword">void</span>* <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果是空栈，不执行出栈</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SStack</span>* <span class="title">myStack</span> = <span class="title">stack</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (myStack-&gt;m_size &lt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行出栈</span></span><br><span class="line">  myStack-&gt;data[myStack-&gt;m_size - <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//更新栈的大小</span></span><br><span class="line">  myStack-&gt;m_size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获得栈顶元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">top_stack</span><span class="params">(<span class="keyword">void</span>* <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SStack</span>* <span class="title">myStack</span> = <span class="title">stack</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (myStack-&gt;m_size == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> myStack-&gt;data[myStack-&gt;m_size - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>栈的大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size_stack</span><span class="params">(<span class="keyword">void</span>* <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SStack</span>* <span class="title">myStack</span> = <span class="title">stack</span>;</span></span><br><span class="line">  <span class="keyword">return</span> myStack-&gt;m_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>判空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty_stack</span><span class="params">(<span class="keyword">void</span>* <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//真，除0之外都是逻辑真，栈不存在，size自然为0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SStack</span>* <span class="title">myStack</span> = <span class="title">stack</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (myStack-&gt;m_size &lt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//真</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//假，不为空</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>销毁栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_stack</span><span class="params">(<span class="keyword">void</span>* <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">  <span class="built_in">stack</span> = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>##基于链表的栈<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A0%88.png" alt>s</p>
<ul>
<li><p>初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">next</span>;</span><span class="comment">//只维护指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式的栈结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> <span class="title">pHeader</span>;</span><span class="comment">//头节点</span></span><br><span class="line">  <span class="keyword">int</span> m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* LinkStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function">LinkStack <span class="title">init_linkStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LStack</span> * <span class="title">myStack</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">LStack</span>));</span></span><br><span class="line">  <span class="keyword">if</span> (myStack==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  myStack-&gt;pHeader.next = <span class="literal">NULL</span>;</span><br><span class="line">  myStack-&gt;m_size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> myStack;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>入栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_linkStack</span><span class="params">(LinkStack <span class="built_in">stack</span>,<span class="keyword">void</span> * data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span>==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (data==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//入栈就是头插</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LStack</span>* <span class="title">myStack</span> = <span class="title">stack</span>;</span></span><br><span class="line">  <span class="comment">//拿到用户数据的前四个字节</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">myNode</span> = <span class="title">data</span>;</span></span><br><span class="line">  <span class="comment">//插入节点</span></span><br><span class="line">  myNode-&gt;next = myStack-&gt;pHeader.next;</span><br><span class="line">  myStack-&gt;pHeader.next = myNode;</span><br><span class="line">  <span class="comment">//更新栈的大小</span></span><br><span class="line">  myStack-&gt;m_size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>出栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_linkStack</span><span class="params">(LinkStack <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span>==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LStack</span>* <span class="title">myStack</span> = <span class="title">stack</span>;</span></span><br><span class="line">  <span class="comment">//如果是空栈就不出栈</span></span><br><span class="line">  <span class="keyword">if</span> (myStack-&gt;m_size==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//保存第一个有数据的节点，栈顶元素</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">pFirst</span> = <span class="title">myStack</span>-&gt;<span class="title">pHeader</span>.<span class="title">next</span>;</span></span><br><span class="line">  myStack-&gt;pHeader.next = pFirst-&gt;next;</span><br><span class="line">  <span class="comment">//更新链表的长度，栈的大小</span></span><br><span class="line">  myStack-&gt;m_size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获得栈顶元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">top_linkStack</span><span class="params">(LinkStack <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span>==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LStack</span>* <span class="title">myStack</span> = <span class="title">stack</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (myStack-&gt;m_size&lt;=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回第一个有数据的节点</span></span><br><span class="line">  <span class="keyword">return</span> myStack-&gt;pHeader.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>栈的大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回栈大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size_linkStack</span><span class="params">(LinkStack <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span>==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LStack</span>* <span class="title">myStack</span> = <span class="title">stack</span>;</span></span><br><span class="line">  <span class="keyword">return</span> myStack-&gt;m_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>判空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty_linkStack</span><span class="params">(LinkStack <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span>==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LStack</span>* <span class="title">myStack</span> = <span class="title">stack</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (myStack-&gt;m_size&lt;=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>销毁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_linkStack</span><span class="params">(LinkStack <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">  <span class="built_in">stack</span> = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="网上找的一种栈的版本，暂时不知道是基于数组的还是链表的，明天在更新"><a href="#网上找的一种栈的版本，暂时不知道是基于数组的还是链表的，明天在更新" class="headerlink" title="网上找的一种栈的版本，暂时不知道是基于数组的还是链表的，明天在更新"></a>网上找的一种栈的版本，暂时不知道是基于数组的还是链表的，明天在更新</h2><ol start="2">
<li>ElemType:是element type 的简体，代指元素类型，类似Java中的泛型，</li>
<li>与define的区别：</li>
</ol>
<ul>
<li>#define可以使用其他类型说明符对宏类型名进行拓展，但对typedef定义的类型名却不能这样<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERGE int </span></span><br><span class="line"><span class="keyword">unsigned</span> INTERGE n;<span class="comment">//真确</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INTERGE </span><br><span class="line"><span class="keyword">unsigned</span> INTERGE n;<span class="comment">//错误，typedef不能用说明符进行拓展</span></span><br></pre></td></tr></table></figure></li>
<li>顺序不同:#define 是前换后，typedef是后换前，<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI int<span class="comment">//将int用PI替代</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> PI<span class="comment">//将int重命名为PI</span></span><br></pre></td></tr></table></figure></li>
<li>连续定义多个变量时，typedef能保证定义的所有变量是同一类型，而#define不能保证<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OI int*</span></span><br><span class="line">OI p1,p2;<span class="comment">//相当于int*p1，p2，只有p1是指针，p2是int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* OI</span><br><span class="line">OI p1 ，p2；<span class="comment">//p1，p2都是指针；</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>栈的有关操作:</li>
</ol>
<ul>
<li>初始化:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackInit</span><span class="params">(Stack* s)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//为栈申请空间</span></span><br><span class="line">  s-&gt;base=(DataType*)<span class="built_in">malloc</span>(length*<span class="keyword">sizeof</span>(DataType));</span><br><span class="line">  <span class="comment">//判断是否申成功</span></span><br><span class="line">  <span class="keyword">if</span>(!s-&gt;base)&#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//初始化栈数组空间</span></span><br><span class="line">  s-&gt;top = s-&gt;base;<span class="comment">//最开始栈顶等于栈底</span></span><br><span class="line">  s-&gt;stackSize = length;<span class="comment">//Stacksize表示栈的最大长度</span></span><br><span class="line">  <span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>入栈:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPush</span> <span class="params">(Stack* s,DataType x)</span></span>&#123;</span><br><span class="line">  <span class="comment">//断言</span></span><br><span class="line">  assert(s);</span><br><span class="line">  <span class="keyword">if</span>(s-&gt;stackSize==s-&gt;top-s-&gt;base)&#123;<span class="comment">//栈的顶部减底部就是栈的长度 ,判断是否满栈 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"空间已满，追加空间"</span>);</span><br><span class="line">    s-&gt;base = (DataType*)<span class="built_in">realloc</span>(s-&gt;base,(s-&gt;stackSize+length)*<span class="keyword">sizeof</span>(DataType));</span><br><span class="line">    <span class="comment">//为栈扩容，重新分配地址,最大容量在加length</span></span><br><span class="line">    <span class="keyword">if</span>(!s-&gt;base)&#123;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    s-&gt;top = s-&gt;base+s-&gt;stackSize;<span class="comment">//将top向上移动stacksize个元素单位 </span></span><br><span class="line">    s-&gt;stackSize+=length;<span class="comment">//记录当前的栈的最大长度 </span></span><br><span class="line">  &#125; </span><br><span class="line">  *(s-&gt;top)=x;<span class="comment">//赋值 </span></span><br><span class="line">  s-&gt;top++;<span class="comment">//top移向上一个元素，为下一个赋值 </span></span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>出栈:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DataType <span class="title">StackPop</span><span class="params">(Stack* s)</span></span>&#123;</span><br><span class="line">  assert(s);</span><br><span class="line">  <span class="keyword">if</span>(StackEmpty(s))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈为空"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *--(s-&gt;top);</span><br><span class="line"><span class="comment">//优先级 '.' &gt; "--" = '*'</span></span><br><span class="line"><span class="comment">//s.top有两种可能</span></span><br><span class="line"><span class="comment">//一是指向栈顶元素的指针</span></span><br><span class="line"><span class="comment">//二是指向比栈顶元素更高一层的空元素</span></span><br><span class="line"><span class="comment">//从这里的实际情况来看，我判断是第二种情况，当s.top==0时，栈为空。</span></span><br><span class="line"><span class="comment">//--s.top是递减指针，这时s.top就指向真正的栈顶元素了</span></span><br><span class="line"><span class="comment">//*--s.top是是该元素，返回给e</span></span><br><span class="line"><span class="comment">//这样e就得到了真正的栈顶元素，同时栈内元素数目减一</span></span><br><span class="line"><span class="comment">//说白了就是e=stack.pop()操作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>查看栈的大小<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DataType <span class="title">StackSize</span><span class="params">(Stack* s)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (s-&gt;top-s-&gt;base);<span class="comment">//顶部-底部就是元素个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>查看栈顶元素<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DataType <span class="title">StackTop</span><span class="params">(Stack* s)</span></span>&#123;</span><br><span class="line">  assert(s);</span><br><span class="line">  <span class="keyword">if</span>(StackEmpty(s))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈为空"</span>);</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *(s-&gt;top<span class="number">-1</span>);<span class="comment">//s.top指向的是比栈顶更高一层的空间,因此要先-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>判空<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(Stack* s)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>==(s-&gt;top-s-&gt;base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>##受限线性表(队列)</p>
<ol>
<li><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E9%98%9F%E5%88%97.png" alt></li>
</ol>
<p>#树形结构(二叉树)<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p>
<ol>
<li>二叉树的表示法有三种：图形法，文字法，和左孩子右兄弟表示法，前两种并不重要，第三种比较重要，他能将多叉树转为二叉树。<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E5%B7%A6%E5%AD%A9%E5%AD%90%E5%8F%B3%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt></li>
<li>二叉树的基本特征：每个节点的度不大于2，是有序树（左右子树不能颠倒）</li>
<li>二叉树的基本性质：</li>
</ol>
<ul>
<li>对层而言:第i层最多右2^(i-1)个节点，例如第3层有2^(3-1)=2*2=4</li>
<li>对深度而言:深度为K的树最多有2^K-1,例如第3层有2^3-1=7个节点</li>
<li>对任一颗二叉树而言，如果度为2的节点数有n2个，则叶子数有(n0)必定为n2+1（即n0=n2+1）</li>
<li>满二叉树：满足第二条的树就是满二叉树</li>
<li>完全二叉树：除最后一层外，上面的树是完全二叉树，并且最底层的节点尽量靠左（如果底层的节点有的只有右孩子没有左孩子，那这棵树就不是完全二叉树，反之，只有左孩子没有有孩子，那他还是完全二叉树）。</li>
<li>具有n个节点的完全二叉树的深度必为logn/log2+1，例如深度为4的完全二叉树上只有9个节点，则深度=log9/log2+1=3+1=4，小数都是向下取整的，假如是深度为4的满二叉树，深度=log15/log2+1=3+1=4</li>
<li>对完全二叉树，如果从上到下，从左到右依次编号，那么编号为i的节点的左孩子的编号一定是2i，有孩子是2i+1，双亲是i/2（i=1时例外）</li>
</ul>
<p>##二叉数的基本操作</p>
<ol>
<li>二叉树的遍历有三种，分别是先序遍历(DLR)，中序遍历(LDR)，后序遍历(LRD)<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt><br>其中D是根节点，L和R分别是左子树和右子树，最常见的遍历方法有两种，分别是递归法和非递归法</li>
<li></li>
</ol>
<ul>
<li><p>递归法：递归法很容易理解，只需要改变对根节点的操作就可以转换方式，但相对来说数据大时会因为递归层数太大，调用的栈多，造成运算时间过长，占用内存过多。<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E9%80%92%E5%BD%92.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Tree e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(t)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,e-&gt;data);<span class="comment">//先输出e节点的值</span></span><br><span class="line">    PreOrder(e-&gt;Lchild);<span class="comment">//进入左子树，一直遍历至左子树为NULL；</span></span><br><span class="line">    PreOrder(e-&gt;Rchild);<span class="comment">//进入右子树，一直遍历至左子树为NULL；</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Tree e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(t)&#123;</span><br><span class="line">    PreOrder(e-&gt;Lchild);<span class="comment">//进入左子树，一直遍历至左子树为NULL；</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,e-&gt;data);<span class="comment">//先输出e节点的值</span></span><br><span class="line">    PreOrder(e-&gt;Rchild);<span class="comment">//进入右子树，一直遍历至左子树为NULL；</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Tree e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(t)&#123;</span><br><span class="line">    PreOrder(e-&gt;Lchild);<span class="comment">//进入左子树，一直遍历至左子树为NULL；</span></span><br><span class="line">    PreOrder(e-&gt;Rchild);<span class="comment">//进入右子树，一直遍历至左子树为NULL；</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,e-&gt;data);<span class="comment">//先输出e节点的值</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>非递归算法，使用手动出栈和入栈来实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preTraverse_int</span><span class="params">(pBinaryNode root)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//初始化栈</span></span><br><span class="line">  seqStack myStack = init_stack();</span><br><span class="line">  <span class="comment">//将根节点入栈</span></span><br><span class="line">  pBinaryNode <span class="keyword">new</span> = <span class="literal">NULL</span>;</span><br><span class="line">  push_stack(myStack, root);</span><br><span class="line">  <span class="comment">//当栈不为空循环</span></span><br><span class="line">  <span class="keyword">while</span> (isEmpty_stack(myStack)==<span class="number">0</span>)<span class="comment">//注意这里=0是指的假，即不为空</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//出栈，不管符不符合</span></span><br><span class="line">    <span class="keyword">new</span>=top_stack(myStack);</span><br><span class="line">    pop_stack(myStack);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>-&gt;flag1==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c:"</span>, <span class="keyword">new</span>-&gt;ch);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="keyword">new</span>-&gt;flag);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">new</span>-&gt;flag1 = <span class="number">1</span>;<span class="comment">//将其置为1</span></span><br><span class="line">      <span class="comment">//按照遍历的顺序选择，注意栈的顺序是先进后出，就是说如果要先序遍历，就要后序入栈</span></span><br><span class="line">      push_stack(myStack,<span class="keyword">new</span>-&gt;rChild);</span><br><span class="line">      push_stack(myStack,<span class="keyword">new</span>-&gt;lChild);</span><br><span class="line">      push_stack(myStack,<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li><p>二叉树的插入,插入需要符合一定的规律，就是比根节点小的数据插入左子树，相等或大于就插入右子树。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_tree</span><span class="params">(pBinaryNode root,pBinaryNode node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//当前节点</span></span><br><span class="line">  pBinaryNode current = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(binaryNode));</span><br><span class="line">  pBinaryNode parent = <span class="literal">NULL</span>;<span class="comment">//父节点不需要分配空间，因为它并不对数据进行增删改，下面的parent-&gt;lchild其实指向的是上一个current，而current是已经分配好空间的。</span></span><br><span class="line">  current = root;<span class="comment">//当前节点指向根节点</span></span><br><span class="line">  <span class="comment">//进入循环，互相比较值</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>)<span class="comment">//如果根节点为空就直接赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">      root = node;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//存储当前节点的值，作为当前节点的父节点</span></span><br><span class="line">      parent = current;</span><br><span class="line">      <span class="keyword">if</span> (node-&gt;flag &lt; current-&gt;flag)<span class="comment">//如果小于当前节点的值,就进入左子树进行下一轮比较</span></span><br><span class="line">      &#123;</span><br><span class="line">        current = current-&gt;lChild;</span><br><span class="line">        <span class="keyword">if</span> (current==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          parent-&gt;lChild = node;<span class="comment">//如果当前节点为空，那么就给它的父节点的左子树赋值。下面同理</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        current = current-&gt;rChild;</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="literal">NULL</span>)<span class="comment">//</span></span><br><span class="line">        &#123;</span><br><span class="line">          parent-&gt;rChild = node;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉树的查找，需要树满足3的插入规律，否则会报错</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">pBinaryNode <span class="title">serach_binaryTree</span><span class="params">(pBinaryNode root,<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  pBinaryNode current = root;<span class="comment">//只需要指针，就相当于数据库中的查询，不需要对数据进行增删改时就可以只使用指针</span></span><br><span class="line">  <span class="keyword">while</span> (current-&gt;flag1!=data)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (data&lt;current-&gt;flag1)<span class="comment">//如果比根节点的数据小，就向左子树找</span></span><br><span class="line">    &#123;</span><br><span class="line">      current = current-&gt;lChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//如果比根节点的数据大，就像右找</span></span><br><span class="line">      current = current-&gt;rChild;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;<span class="comment">//返回current，如果没有找到，那么返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E5%85%88%E5%BA%8F%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.jpg" alt></p>
<ol start="3">
<li>函数传递参数中带&amp;与不带&amp;号区别<br>首先引用只有c++能使用，c不能使用引用</li>
</ol>
<ul>
<li>C++ 引用<br>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</li>
<li>C++ 引用 vs 指针<br>引用很容易与指针混淆，它们之间有三个主要的不同：</li>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
<li>C++ 中创建引用<br>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，可以通过原始变量名称或引用来访问变量的内容</li>
</ul>
<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p>二叉树的算法都包括递归与非递归，递归易于理解，非递归利于效率，现在出学，只要求了解递归算法</p>
<ol>
<li>递归算法：左子树和右子树的最大值+1(+1是根节点)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(Tree t)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!t)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> depth(t-&gt;lchild)&gt;depth(t-&gt;rchild)?depth(t-&gt;lchild)+<span class="number">1</span>:depth(t-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>##二叉树的叶子节点个数</p>
<ol>
<li>原理其实很简单，正如xxx所说树的一切操作都源于三种遍历方式，计算叶子数就是利用的先序遍历，叶子的特征就是左右孩子都是空，那么只需要首先判断根节点是否满足条件，如果根节点满足条件，就可以直接判断了，另外，二叉树都是从最小的那一棵子树看的，基本操作是一样的。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计叶子数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calucateLeafNum</span><span class="params">(pBinaryNode root, <span class="keyword">int</span>* num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (root-&gt;lChild==<span class="literal">NULL</span>&amp;&amp;root-&gt;rChild==<span class="literal">NULL</span>)<span class="comment">//确定是上面遍历方式就是看要确定的条件是那种方式的</span></span><br><span class="line">  &#123;</span><br><span class="line">    (*num)++;<span class="comment">//一定要先取值在++，不然会变成下一个地址的值，原因在我之前的博客里有讲。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  calucateLeafNum(root-&gt;lChild,num);</span><br><span class="line">  calucateLeafNum(root-&gt;rChild,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>##二叉树的高度</p>
<ol>
<li>原理就是假设叶子的高度是1，那么叶子的双亲的节点就是1+1=2（有两种情况，左右孩子高度都是1，或者有一个孩子节点为0），就可以总结除规律，节点的高度=左右孩子的最大值+1，用最小子树模型，就是说根的高度只有在左右孩子的高度都确定的情况下才能确定，也就是后序遍历。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(pBinaryNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> lheight = <span class="built_in">height</span>(root-&gt;lChild);</span><br><span class="line">  <span class="keyword">int</span> rheight = <span class="built_in">height</span>(root-&gt;rChild);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = lheight &gt; rheight ? lheight + <span class="number">1</span> : rheight + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">height</span>;<span class="comment">//这个一定要写，我就是没有写导致出现了随机的层数，这个就相当于记录每层的层数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>##二叉树的拷贝</p>
<ol>
<li>掌握原理其实很简单，还是最小子树模型，要想复制一颗完整的树首先需要复制左右子树在递归回上层，复制节点，有点像上面的求高度，都是后序遍历<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">pBinaryNode <span class="title">duplicate</span><span class="params">(pBinaryNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pBinaryNode lchild = duplicate(root-&gt;lChild);</span><br><span class="line">  pBinaryNode rchild = duplicate(root-&gt;rChild);</span><br><span class="line">  pBinaryNode root1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(binaryNode));</span><br><span class="line">  root1-&gt;lChild = lchild;</span><br><span class="line">  root1-&gt;rChild = rchild;</span><br><span class="line">  root1-&gt;ch = root-&gt;ch;<span class="comment">//一定记得把这个写上，我忘写了之后输出屯屯屯屯屯屯。</span></span><br><span class="line">  <span class="keyword">return</span> root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>##二叉树的释放</p>
<ol>
<li>最小子树，首先先释放左子树在释放右子树，最后释放节点，就是后序遍历。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果是在测试方法中手动定义的二叉树，首先要复制才能进行释放，因为定义在函数体中的是临时变量，分配在栈上，而经过复制之后是在内存上进行的分配，可以读写，在栈上释放失败，可能有的内存只读不能写。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeTree</span><span class="params">(pBinaryNode root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  freeTree(root-&gt;lChild);</span><br><span class="line">  freeTree(root-&gt;rChild);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%c被释放了"</span>, root-&gt;ch);</span><br><span class="line">  <span class="built_in">free</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>##二叉树的节点删除</p>
<ol>
<li></li>
</ol>
<p>##二叉树的插入</p>
<ol>
<li>二叉树是一个有序树，数据的排列规则是插入值比根节点大就插入右边，比根节点小就插入左边。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>##二叉树的删除</p>
<p>#图形结构<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E5%9B%BE%E5%9E%8B%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3.png" alt></p>
<p>#算法<br>##查找算法</p>
<ol>
<li>二分查找<br>二分查找法：<br>特点：数据必须要有序排列。<br>优点：运行时间比顺序查找法少，数据大时有优势。<br>缺点：数据必须有序，先得排序，空间复杂度比顺序查找法高，思路不容易想到。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> low,high,mid;</span><br><span class="line">  low=<span class="number">0</span>;<span class="comment">//low和high表示的下标区间，因此high要在数组个数上减去1</span></span><br><span class="line">  high=<span class="number">10</span><span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(low&lt;=high)&#123;<span class="comment">//注意=号，因为可能就是中值为目标</span></span><br><span class="line">    mid=(high+low)/<span class="number">2</span>;<span class="comment">//这里不需要考虑除不尽，取整和下面的操作会取到所有的下标</span></span><br><span class="line">        <span class="keyword">if</span>(a[mid]==x);<span class="comment">//x为目标值</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&gt;x)&#123;<span class="comment">//说明目标值在中值的左边,就要把右区间设为mid-1</span></span><br><span class="line">             high=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//找不到返回-1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>##排序算法</p>
<ol>
<li><p>选择排序法<br>两次循环,每次将最小的放在第一个,然后将第二最小的数放在第二个,以此类推,期间调用交换函数，复杂度是n*(n-1)=O(n^2)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> N;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">  <span class="keyword">int</span>* num = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * N);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, num + i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**选择排序**/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> k = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;N; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (num[j]&lt;num[k]) &#123;</span><br><span class="line">        k = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = num[i];</span><br><span class="line">    num[i] = num[k];</span><br><span class="line">    num[k] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, num[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>插入排序<br>原理如图:<img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> N;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">  <span class="keyword">int</span>* num = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * N);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, num + i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**选择排序**/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)<span class="comment">//进行N-1次循环，因为是从第一个开始算起的</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">    <span class="keyword">int</span> temp = num[i];</span><br><span class="line">    <span class="keyword">while</span> (temp&lt;num[j<span class="number">-1</span>]&amp;&amp;j&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      num[j] = num[j - <span class="number">1</span>];<span class="comment">//将排序好的数组逐个向后移，</span></span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    num[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, num[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>冒泡排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* num, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (num[j] &lt; num[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = num[i];</span><br><span class="line">        num[i] = num[j];</span><br><span class="line">        num[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以上三种(冒泡，选择，插入)都是简单排序，下面介绍几种复杂点的排序，简单排序的复杂度都是O(n^2)级别的，这次介绍的是希尔排序，希尔排序基于插入排序的，但是解决了插入排序的缺点，插入排序的缺点就是大量的移动，而数组最不擅长的就是移动，假如一个很小的数据的在数组最右端，那么要移动到左边就需要把中间的元素全部向后移动，非常耗费时间，希尔排序通过加大插入排序中的元素的间隔，并对这些间隔的元素进行插入排序，从而减少的数据的大面积移动，当完成改间隔的排序之后会缩小间隔继续移动。<br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt></p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>c语言，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础</title>
    <url>/2019/12/19/java/</url>
    <content><![CDATA[<h1 id="常用的命令提示符"><a href="#常用的命令提示符" class="headerlink" title="常用的命令提示符"></a>常用的命令提示符</h1><ol>
<li>切换磁盘：盘符(不区分大小写)+:(英文)，例如d:</li>
<li>在磁盘中进入文件夹:cd + 文件夹名,例如cd ppt论文</li>
<li>查看当前目录下所有内容：dir(directory的缩写)</li>
<li>返回上一级目录：cd..</li>
<li>返回磁盘根目录：cd\</li>
<li>清屏：cls(clean screen的缩写)</li>
</ol>
<h1 id="jdk-jre-jvm"><a href="#jdk-jre-jvm" class="headerlink" title="jdk,jre,jvm"></a>jdk,jre,jvm</h1><ol>
<li><img src="/2019/12/19/java/%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt></li>
<li>jre(java runtime environment),java运行所需的环境，包扩一些基本的jar包之类的，如果只需要运行java程序，安装jre就够了，但是如果需要编写Java程序就需要jdk(Java development kit)，两者的核心都是jvm(Java virtual machine)，java虚拟机，这也是java跨平台特性的保证，但是正因为虚拟机的存在，在理论上执行效率不如c++等直接调用硬件执行的高级语言高，但是经过jdk的不断升级，在一般的应用场景下，效率和c++差距非常小。</li>
<li>java版本更新的大版本是1.5和1.8，而目前使用最为广泛的是1.8版本，所以接下来的所有内容都是基于1.8版本的，另外，由于jdk1.5版本之后的命名方式有所改变，把1.5叫成jdk5，以后每一代更新都直接是+1，所以jdk8和jdk1.8是一样的，现在的jdk最新已经到了jdk13。</li>
</ol>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ol>
<li>局部变量(local variable):方法或语句块内的变量，其生命周期是从声明位置开始到方法或语句块结束为止。(和c的函数局部变量一样)。<a id="more"></a></li>
<li>成员变量(member variable)：也叫实例变量，方法外，类的内部的变量，其生命周期伴随对象始终。并且成员变量在定义时如果没有手动赋值，会默认赋初始值，数字是0，字符是null，布尔是false。</li>
<li>静态变量(类变量 static variable):用static关键字表示，从属于类，生命周期从类加载到卸载，伴随类的始终。</li>
<li>周期比较(小到大)：局部变量(从属于方法)&lt;成员变量(从属于对象)&lt;静态变量(从属于类)。而c中类似的只有局部变量和静态变量的概念。(c是面向过程编程，不同于面向对象，没有对象的概念)。</li>
</ol>
<h1 id="变量和常量的命名规范"><a href="#变量和常量的命名规范" class="headerlink" title="变量和常量的命名规范"></a>变量和常量的命名规范</h1><ol>
<li>所有变量和方法名都是首字母小写和驼峰原则。</li>
<li>常量是大写字母和下划线。</li>
<li>类名大写字母和驼峰原则。</li>
</ol>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ol>
<li>Java的数据类型有两种大的分类，一种是基本数据类型，另一种是引用数据类型<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本数据类型</span></span><br><span class="line">整数 <span class="keyword">byte</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">long</span> </span><br><span class="line">浮点数 <span class="keyword">float</span> <span class="keyword">double</span></span><br><span class="line">布尔 <span class="keyword">boolean</span></span><br><span class="line">字符 <span class="keyword">char</span></span><br><span class="line"><span class="comment">//引用数据类型</span></span><br><span class="line">字符串</span><br><span class="line">数组</span><br><span class="line">类</span><br><span class="line">接口</span><br><span class="line">lambda</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="自动转化"><a href="#自动转化" class="headerlink" title="自动转化"></a>自动转化</h1><ol>
<li>指容量小的数据类型自动转为容量大的数据类型，容量指的是表示范围，例如short a = 12 合法，但short a = 1234567不合法，超出了short的表示范围。<br>其中实线表示可以不损失精度直接转换，虚线是可能会有精度损失。<br><img src="/2019/12/19/java/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt></li>
</ol>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ol>
<li>有两种初始化方式，一种是动态初始化（指定长度），另一种是静态初始化（指定内容）<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] list = new <span class="built_in">int</span>[<span class="number">300</span>];<span class="comment">//动态</span></span><br><span class="line"><span class="built_in">int</span>[] list = new <span class="built_in">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>&#125;;<span class="comment">//静态</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><ol>
<li>使用枚举类型时，要另外定义一个新的public类，因为一个Java文件只能有一个public类，常用于switch结构里(用来定义常量)，可以防止case越界引起程序的混乱。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hhh</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Season s: Season.Values())&#123;</span><br><span class="line">			System.out.println(s);<span class="comment">//增强型循环，变量类型+中间变量+要输出的内容</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在另外一个文件里定义枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season&#123;</span><br><span class="line">	SPRING,SUMMER,AUTUMN,WINTER<span class="comment">//没有分号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="IDEA的常用快捷键"><a href="#IDEA的常用快捷键" class="headerlink" title="IDEA的常用快捷键"></a>IDEA的常用快捷键</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">alt+enter 导入包，自动修正代码</span><br><span class="line">ctrl+y 删除当前光标所在行</span><br><span class="line">ctrl+d 复制光标所在行的内容，插入当前光标位置下面</span><br><span class="line">ctrl+alt+L 格式话代码</span><br><span class="line">ctrl+/ 单行注释，再次按取消注释</span><br><span class="line">ctrl+shift+/ 多行注释</span><br><span class="line">alt+ins 自动生成代码，构造函数，getSet方法</span><br><span class="line">alt+shift+上下箭头 移动当前代码行</span><br></pre></td></tr></table></figure>
<h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><ol>
<li>使用static关键字进行修饰之后，变量就不属于自己，而是属于类，即多个对象可以共享同一个数据<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">student</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> classRoom;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student stu1 = <span class="keyword">new</span> student();</span><br><span class="line">Student stu2 = <span class="keyword">new</span> student();</span><br><span class="line">stu1.setName(<span class="string">"ads"</span>);</span><br><span class="line">stu1.setcalssRoom(<span class="string">"111"</span>);</span><br><span class="line">stu1.setName(<span class="string">"ad"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//只设置了stu1的classroom，但是stu2的classroom是和stu1相同的，即这两个学生共享同一个教室</span></span><br></pre></td></tr></table></figure></li>
<li>用static修饰方法之后，该方法就成为了静态方法，静态方法属于类而不属于对象，这也就是为什么没有static修饰的方法必须先new对象才能调用成员方法，对于本类中的静态方法，可以直接写方法名，不用写类名，因为编译器会自动加上类名。</li>
<li>static的注意事项：首先，静态只能访问静态，不能访问非静态，比如成员方法可以访问成员变量，也可以访问静态变量。但是静态方法只能访问静态变量，不能访问成员变量，因为在内存中是先加载静态在加载成员，如果在静态方法中调用成员变量，此时成员变量没有加载，是找不到的，自然会出错。第二点，静态方法中不能使用this，因为this表示调用自己的对象，但是静态和对象没有关系，静态是通过类来访问的。</li>
<li>静态代码块：当类第一次被new时执行，只执行一次，并且在构造方法执行之前执行(静态内容总是优先非静态内容)，主要用途是给类中的静态变量一次性赋值</li>
</ol>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ol>
<li>主类中方法前加static，表名该方法是类的共享成员，可以被该类所有的实例化对象访问，当类加载时，static方法就被加载，其声明周期从属于类。若是不定义static，也可以通过对象调用普通方法。（简单的说就是static修饰的方法不需要实例化对象就可以调用，没有static修饰的需要先实例化对象在使用）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testmethod</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">	<span class="keyword">int</span> m = scanner.nextInt();</span><br><span class="line">	<span class="keyword">int</span> x = sum(n,m);</span><br><span class="line">	System.out.println(<span class="string">"n+m="</span>+x);<span class="comment">//直接调用</span></span><br><span class="line">	</span><br><span class="line">	Testmethod th = <span class="keyword">new</span> Testmethod();</span><br><span class="line">	<span class="keyword">int</span> a = th.sum(<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">	System.out.println(a);<span class="comment">//对象调用</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">int</span> m)</span> </span>&#123; 	<span class="comment">//static 修饰的函数可以在主类中直接调用</span></span><br><span class="line">	<span class="keyword">return</span> m+n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//没有static要先创建对象，在通过对象调用方法</span></span><br><span class="line">	<span class="keyword">return</span> n+m+x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法的重载(overload)：函数名相同但参数列表不同(参数个数，顺序，类型)，只有返回值和形参名称不构成重载。</li>
</ol>
<h1 id="对象-object-instance"><a href="#对象-object-instance" class="headerlink" title="对象(object,instance)"></a>对象(object,instance)</h1><ol>
<li>对象是具体的事物;类是对对象的抽象;</li>
<li>类可以看成一类对象的模板，对象可以看成该类的一个具体实例。</li>
<li>类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性</li>
</ol>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ol>
<li>每个文件都只能由一个public class，且类名必须与文件名一致。可以定义多个普通类</li>
<li>类里由三个成员，属性(field),方法(method),构造方法(constructor)</li>
<li>类可以相互引用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testclass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line">	 grade ge;<span class="comment">//类名+属性名</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	grade g1 = <span class="keyword">new</span> grade();</span><br><span class="line">	Testclass stu1 = <span class="keyword">new</span> Testclass();</span><br><span class="line">	g1.grade = <span class="number">2</span>;</span><br><span class="line">	stu1.ge = g1;</span><br><span class="line">	System.out.printf(<span class="string">"年级"</span>+stu1.ge);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grade</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> grade;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>主类名唯一，其他类不能与主类重名，否则会报错找不到主类</li>
<li>传入一个类类型，在方法内进行改动，会对方法外的参数造成影响。<br>24行的引用 teemo与 第17行的引用hero，是不同的引用<br>通过调用garen.attack(teemo, 100); 使得这两个引用都指向了同一个对象<br>所以在第18行hero.hp = hero.hp - damage; 就使得该对象的hp值，发生了变化<br>因此第25行，打印该对象的Hp值就是变化后的值<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    String name; <span class="comment">// 姓名</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">float</span> hp; <span class="comment">// 血量</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">float</span> armor; <span class="comment">// 护甲</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> moveSpeed; <span class="comment">// 移动速度</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String name, <span class="keyword">float</span> hp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.hp = hp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 攻击一个英雄，并让他掉damage点血</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero hero, <span class="keyword">int</span> damage)</span> </span>&#123;</span><br><span class="line">        hero.hp = hero.hp - damage;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">"提莫"</span>, <span class="number">383</span>);</span><br><span class="line">        Hero garen = <span class="keyword">new</span> Hero(<span class="string">"盖伦"</span>, <span class="number">616</span>);</span><br><span class="line">        garen.attack(teemo, <span class="number">100</span>);</span><br><span class="line">        System.out.println(teemo.hp);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>类方法： 又叫做静态方法(加载类时和类一起加载),对象方法： 又叫实例方法，非静态方法(只有当对象调用是才会用)<br>访问一个对象方法，必须建立在有一个对象的前提的基础上.访问类方法，不需要对象的存在，直接就访问</li>
</ol>
<h1 id="构造方法-constructor"><a href="#构造方法-constructor" class="headerlink" title="构造方法(constructor)"></a>构造方法(constructor)</h1><ol>
<li>用于对象的初始化，在对象创建时被调用，构造器的名称应该与类的名称一致，    虽然有返回值，但不能加return(返回值必然时本类)，即public+类名(不用加返回值类型名)</li>
<li>构造方法同样可以重载，但是当形参和实参重复时，就要用this关键字，this指代正在创建的对象。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hero</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> hp ;</span><br><span class="line">   <span class="keyword">int</span> speed;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">hero</span> <span class="params">(<span class="keyword">int</span> hp,<span class="keyword">int</span> speed)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.hp = hp;  <span class="comment">//this.hp 指代创建对象的hp，等号后面的hp是形参hp</span></span><br><span class="line">		<span class="keyword">this</span>.speed = speed;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><ol>
<li>类和类之间的关系有5种，分别是：<br><img src="/2019/12/19/java/%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt></li>
</ol>
<ul>
<li>自身：hero类</li>
<li>同包子类：charactor包里继承了hero包的类(ADhero)</li>
<li>不同包子类：charactor1和property包里的继承了hero的类(support)</li>
<li>同包类：charactor包里除了hero的所有类</li>
<li>其他类：除上述类外的所有类</li>
</ul>
<ol start="2">
<li>修饰符类型：</li>
</ol>
<ul>
<li>private只能自己访问，其余任何类都不能访问或继承<br><img src="/2019/12/19/java/private.png" alt></li>
<li>package/friendly/default,没有修饰符是的默认修饰符，同包的子类和其他类可以继承和访问，但其他类的子类和类就不能访问和继承。<br><img src="/2019/12/19/java/default.png" alt></li>
<li>protected，除其他类不能访问外，同包和不同包都可以继承。<br><img src="/2019/12/19/java/protected.png" alt></li>
<li>public，任何地方，都可以访问<br><img src="/2019/12/19/java/public.png" alt></li>
</ul>
<ol start="3">
<li>适用范围：</li>
</ol>
<ul>
<li>属性通常使用private封装起来</li>
<li>方法一般使用public用于被调用</li>
<li>会被子类继承的方法，通常使用protected</li>
<li>package用的不多，一般新手会用package,因为还不知道有修饰符这个东西</li>
</ul>
<p>-再就是作用范围最小原则<br>  简单说，能用private就用private，不行就放大一级，用package,再不行就用protected，最后用public。这样就能把数据尽量的封装起来，没有必要露出来的，就不用露出来了</p>
<h1 id="单例，多例模式"><a href="#单例，多例模式" class="headerlink" title="单例，多例模式"></a>单例，多例模式</h1><ol>
<li>又叫singleton，一个类在一个JVM里只有一个实例村在。有两种办法，两种办法的步骤都是</li>
</ol>
<ul>
<li>将构造方法私有化，使其不能被外部方法更改</li>
<li>将类属性实例化(二者主要区别就在这里)</li>
<li>写public static(类方法)，返回instance(实例)</li>
</ul>
<ol start="2">
<li>多例模式</li>
</ol>
<h1 id="两种加载模式-应该放在多表查询的地方讲"><a href="#两种加载模式-应该放在多表查询的地方讲" class="headerlink" title="两种加载模式(应该放在多表查询的地方讲)"></a>两种加载模式(应该放在多表查询的地方讲)</h1><p>懒汉式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	giantDragon g1 = giantDragon.getInstance();</span><br><span class="line">	giantDragon g2 = giantDragon.getInstance();</span><br><span class="line">	System.out.println(g1==g2);<span class="comment">//返回true，两者是同一对象</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">giantDragon</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">giantDragon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;<span class="comment">//构造器私有化</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> giantDragon instance;<span class="comment">//定义一个类属性，</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> giantDragon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;<span class="comment">//调用getIstance函数，如果没有实例，就新建一个</span></span><br><span class="line">			instance = <span class="keyword">new</span> giantDragon();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;<span class="comment">//如果已经有的话就返回实例</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	giantDragon g1 = giantDragon.getInstance();</span><br><span class="line">	giantDragon g2 = giantDragon.getInstance();</span><br><span class="line">	System.out.println(g1==g2);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">giantDragon</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">giantDragon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> giantDragon instance = <span class="keyword">new</span> giantDragon();<span class="comment">//二者差别就在于此，饿汉式是加载类的时侯就加载完成的，即不管是否调用getInstance，类属性都被被实例化，而懒汉式只有当调用时才会实例化</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> giantDragon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>饿汉式是立即加载的方式，无论是否会用到这个对象，都会加载。<br>如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。</li>
</ol>
<p>懒汉式，是延迟加载的方式，只有使用的时候才会加载。 并且有线程安全的考量。<br>使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。</p>
<p>看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式</p>
<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="Scanner获取键盘输入"><a href="#Scanner获取键盘输入" class="headerlink" title="Scanner获取键盘输入"></a>Scanner获取键盘输入</h2><ol>
<li>首先要导入Scanner所在包</li>
<li>新建Scanner对象</li>
<li>建立变量存储键盘输入的值<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner<span class="comment">//引进包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">               Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//in是io流</span></span><br><span class="line">               System.out.println(<span class="string">"请输入名字"</span>);</span><br><span class="line">               String name = Scanner.nextline();<span class="comment">//字符串是nextline</span></span><br><span class="line">               System.out.println(<span class="string">"请输入爱好"</span>);</span><br><span class="line">               String favor = Scanner.nextline();</span><br><span class="line">               System.out.println(<span class="string">"请输入年龄"</span>);</span><br><span class="line">               <span class="keyword">int</span> age = Scanner.nextInt();<span class="comment">//数字是nextInt</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><ol>
<li>只new一个对象，但是不把他赋给另一个对象。</li>
<li>使用场景，只需要使用对象一次的地方，比如从文件中读取，Scanner scanner = new Scanner(new File(“a.txt”));</li>
<li>匿名类做方法的参数，就是我上面写的那种方式</li>
</ol>
<h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><ol>
<li>nextInt(int bound),指定生成0(包含)到bound(不含)之间的数，就是左闭右开，[0,3)</li>
</ol>
<h2 id="ArrayList-大小可变的数组"><a href="#ArrayList-大小可变的数组" class="headerlink" title="ArrayList(大小可变的数组)"></a>ArrayList(大小可变的数组)</h2><ol>
<li>ArrayList<E>,其中E表示泛型，注意泛型只能是引用类型，不能是基本类型。</E></li>
<li>jdk1.7之后new ArrayList&lt;&gt;()，尖括号中可以不写数据类型，但是尖括号必须有。</li>
<li>print直接答应ArrayList是直接打印ArrayList的内部内容，而不是打印ArrayList的地址。</li>
<li>虽然不能直接装基本类型，但是可以装包装类型<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  Integer</span><br><span class="line"><span class="keyword">char</span> Character</span><br><span class="line"><span class="keyword">short</span> Short</span><br><span class="line"><span class="keyword">long</span> Long</span><br><span class="line"><span class="keyword">double</span> Double</span><br><span class="line"><span class="keyword">byte</span> Byte </span><br><span class="line"><span class="keyword">float</span> Float</span><br><span class="line"><span class="keyword">boolean</span> Boolean</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## String</span><br><span class="line"><span class="number">1</span>. 字符串是常量，不可更改</span><br><span class="line"><span class="number">2</span>. 字符串的效果上是字符数组，但是底层实现是字符串数组</span><br><span class="line"><span class="number">3</span>. 有三种构造函数创建方式，有一种直接创建方式，</span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span><span class="comment">//无参构造函数，创建空白字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> [] array </span>= <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'d'</span>,<span class="string">'d'</span><span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(array)</span><span class="comment">//将字符数组作为参数</span></span></span><br><span class="line"><span class="function"><span class="keyword">byte</span> [] array1 </span>= <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(array1)</span><span class="comment">//将字节数组作为参数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String str </span>= <span class="string">"dsa"</span>;</span><br></pre></td></tr></table></figure></li>
<li>字符串的常量池<br><img src="/2019/12/19/java/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0.png" alt><br>而引用类型进行值得比较使用.equals()方法进行比较</li>
<li>当常量和变量进行比较时，把常量放在前面，变量放在后面是推荐得写法，不推荐变量在前，常量在后<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"dasf"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>,<span class="string">'s'</span>,<span class="string">'s'</span>&#125;);</span><br><span class="line"></span><br><span class="line">System.out,println(str1.equals(str2));<span class="comment">//推荐</span></span><br><span class="line">System.out,println(str2.equals(str1));<span class="comment">//不推荐,因为变量的可能为null，这样调用null的方法时就会报空指针异常</span></span><br><span class="line">.equalsIgnoreCase()<span class="comment">//这样是忽略大小写</span></span><br></pre></td></tr></table></figure></li>
<li>常用方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.length()<span class="comment">//计算字符串的长度</span></span><br><span class="line">.concat(String str2)<span class="comment">//将str2拼接在str1的后面，拼接出来的字符串是新的字符串，而前面两个字符串是不会变的</span></span><br><span class="line">.charAt(<span class="keyword">int</span> index)<span class="comment">//查找index索引的字符</span></span><br><span class="line">.indexOf(String str)<span class="comment">//查找小字符串第一次在大字符串中出现的索引值</span></span><br><span class="line">.substring(<span class="keyword">int</span> index)<span class="comment">//截取出从index位到字符串结尾的子字符串</span></span><br><span class="line">.substring(<span class="keyword">int</span> beginIndex,<span class="keyword">int</span> endIndex)<span class="comment">//截取出从beginindex位到endindex的子字符串,[begin,end),含左不含右</span></span><br><span class="line">.toCharArray()<span class="comment">//将当前字符串拆分为字符数组并返回</span></span><br><span class="line">.getBytes()<span class="comment">//将当前字符串转为字节数组并返回</span></span><br><span class="line">.replace(String oldString,String newString)<span class="comment">//将老的子字符串用新字符串代替</span></span><br><span class="line">.split(String regex)<span class="comment">//regex实际上是正则表达式，注意用.进行分割时，要在前面加上\\，表示将特殊字符.转义普通字符</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Arrays工具类-静态方法直接使用"><a href="#Arrays工具类-静态方法直接使用" class="headerlink" title="Arrays工具类(静态方法直接使用)"></a>Arrays工具类(静态方法直接使用)</h2><ol>
<li>toString(),将数组转换为字符串，默认格式([str1,str2,str3])</li>
<li>sort(),将传入数组进行排序，数字是升序，如果自定义类型，需要实现comparable或者comparator接口</li>
</ol>
<h2 id="Math工具类"><a href="#Math工具类" class="headerlink" title="Math工具类"></a>Math工具类</h2><ol>
<li>abs()，取绝对值</li>
<li>ceil(),向上取整(ceil是天花板)</li>
<li>floor()，向下取整(floor是地板)</li>
<li>round()，四舍五入</li>
</ol>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><ol>
<li>object类是所有类的祖宗类，就是说object中的方法，所有类都能使用，因为所有类都是object的子类</li>
<li>比较常用的就是toString和equals方法</li>
</ol>
<h2 id="DateFormat和SimpleDateFormat"><a href="#DateFormat和SimpleDateFormat" class="headerlink" title="DateFormat和SimpleDateFormat"></a>DateFormat和SimpleDateFormat</h2><ol>
<li>DateFormat类是抽象类，需要使用子类继承才能使用，作用是指定某种日期格式，jdk中的提供好的类就是SimpleDateFormat，这个子类中主要的方法就是format和parse，前者将Date转为指定字符串，后者将字符串转为对象。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日  HH时:mm分:ss秒"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(simpleDateFormat.format(<span class="keyword">new</span> Date()));</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h2><ol>
<li>这个类是用来取代Date类的，Date类的许多过时方法的功能移植到了Calendar中。</li>
<li>Calendar是一个抽象类，里面提供了许多操作日历字段的方法，不需要手动创建子类，只要使用静态方法getInstance()就能获得可使用的子类对象(使用了多态)，其实就是得到了GregorianCalendar类。常用方法可以查询API</li>
</ol>
<h2 id="基本类型和包装类"><a href="#基本类型和包装类" class="headerlink" title="基本类型和包装类"></a>基本类型和包装类</h2><ol>
<li>有些类只能使用引用类型，不能使用基本类型，因此就可以将基本类型包装成应用类型(对象)，这样其他类就可以使用了</li>
<li></li>
</ol>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ol>
<li>面向过程的三大特性：封装性，继承性，多态性，继承是多态的前提</li>
<li>子类继承父类，拥有父类的所有方法和属性，并且可以拥有自己的方法和属性</li>
<li>继承中访问成员变量：如果是直接通过子类对象访问，那么=左边是谁就优先用谁，没有则向上找，如果是通过子类的方法去访问，那么这个方法定义在哪就用谁的成员变量。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Person</span> </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Student</span> <span class="title">stu</span> </span>= <span class="keyword">new</span> Student();</span><br><span class="line">stu.num<span class="comment">//访问的是子类的num</span></span><br><span class="line">Person.num<span class="comment">//父类的</span></span><br><span class="line">stu.methodzi()<span class="comment">//方法定义在子类中，访问的就是子类的变量</span></span><br><span class="line">stu.methodFu()<span class="comment">//方法定义在父类中，访问的就是父类的变量</span></span><br></pre></td></tr></table></figure></li>
<li>但是我们是不会使用上面的方法去区分的，访问父类的变量使用super关键字，访问当前的子类用this</li>
<li>方法重写(override)：将父类中的方法名一样，参数列表也一样的方法进行覆盖，而重载是方法名一样，参数列表不同。</li>
<li>子类的返回值必须小于等于父类的返回值，比如String的返回值就是String类型，它的父类是Object(最大的类型)，String&lt;Object，可以返回，如果String返回Object也是可以的，Object=Object，并且子类方法的权限必须大于等于父类的权限。</li>
<li>子类的构造方法中有一个默认的super()，这是用来调用父类的构造方法的。因为只有先有父类才能创建子类，但平时是不加的，编译器自动加上了，并且super必须是构造方法的第一句，不能出现多个super(),如果要使用父类的重载构造方法，就要写出super(参数)。</li>
<li>继承的三个特点：java是单继承的，即一个类只能继承一个父类，虽然不能多继承，但是可以多级继承。子类只能有一个父类，但是父类可以有多个子类</li>
</ol>
<h1 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h1><ol>
<li>概念：一定有某种行为或属性，但是具体对应到不同的对象有不同的实现，那么这种行为或属性就是抽象，比如动物吃东西，都会吃，但是不同的动物吃的东西不同，那么吃东西就是一种抽象</li>
<li>抽象方法只能定义在抽像方法中。</li>
<li>抽象类不能直接new，必须使用子类继承抽象类并实现抽象类中的所有方法。(因为抽象类是抽象的，并不知道你要实例化什么，就像创建一个动物，但不知道创建什么动物)。</li>
</ol>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ol>
<li>接口是一种规范，只要实现了这个接口就具有了某种功能</li>
<li>接口中可以包含的内容:java7 中可以有常量和抽象方法，java8可以额外有默认方法和静态方法，java9有私有方法</li>
<li>接口中的抽象方法的修饰符固定两个关键字:public abstract void method()，两个修饰符可以选择性的省略<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//上面的都是抽象方法</span></span></span><br></pre></td></tr></table></figure></li>
<li>java8开始，支持接口内默认方法，是为了解决接口升级的问题，比如，接口升级后，有原来的一个抽象方法变成了两个抽象方法，之前的实现类就必须实现两个接口，如果不想实现两个接口，就可以用默认方法，默认方法可以在接口内定义，可以有自己的方法体，接口的默认方法可以由实现类直接调用，也可以被实现类覆盖。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"默认方法执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>java8之后，接口内可以写静态方法，但是不能通过实现类直接调用，而是要和其他类一样直接使用接口名调用。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"静态方法执行"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>java9之后，可以使用私有化方法，用来解决重复代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;<span class="comment">//这样在上面的两个默认方法中就可以使用重复代码，我的是java8，不支持私有方法，java9之后支持</span></span><br><span class="line">        System.out.println(<span class="string">"私有方法执行"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>接口当中也可以定义”成员变量”,但是必须使用public static final 这三个关键字修饰，这三个修饰符可以省略，但是常量一定要赋值。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">231</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h1><ol>
<li>继承是多态的前提</li>
<li>一个对象拥有多种形态就是多态性，比如继承Person的Student类既是学生也是人</li>
<li>代码当中体现多态性就是父类引用指向子类对象，<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类引用 变量名 = <span class="keyword">new</span> 子类对象</span><br><span class="line">接口 变量名 = <span class="keyword">new</span> 子类对象</span><br><span class="line"><span class="comment">//比如获取spring配置文件</span></span><br><span class="line">applicationContext factory = <span class="keyword">new</span> classPathApllicationContext;</span><br></pre></td></tr></table></figure></li>
<li>成员变量的访问规则是编译看左边，运行还看左，成员方法是编译看左边，运行看右边，<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类方法"</span>);</span><br><span class="line">		System.out.println(<span class="string">"num"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodFu</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类特有方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">20</span>;</span><br><span class="line">	<span class="keyword">int</span> age=<span class="number">17</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"num"</span>);</span><br><span class="line">		System.out.println(<span class="string">"子类方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodZi</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类特有方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Fu obj = <span class="keyword">new</span> Zi();</span><br><span class="line"><span class="comment">//1.通过对象直接访问成员变量，左边定义的是谁就是谁的成员变量，</span></span><br><span class="line">obj.num<span class="comment">//是10，编译看左就是由于左边写的是父类，因此写代码时就只能写num，不能写age，因为是父类的而父类和父类的父类没有age这个属性，就是看左</span></span><br><span class="line"></span><br><span class="line">obj.method()<span class="comment">//通过方法访问变量和成员方法是一样就是看方法属于哪个对象就是哪个成员变量，这个new的对象是子类，优先从子类中找，没有则向上找，编译时写methodZi是错误的，因为左边是Fu，而父类中没有methodZi这个方法，这就是编译看左</span></span><br></pre></td></tr></table></figure></li>
<li>对象的向上转型<br>就是多态写法，右侧创建一个子类对象，将其当成父类来使用。向上转型一定是安全的，但是子类特有的方法是不能运行的。</li>
<li>对象的向下转型<br>将父类对象还原成原来的子类，注意要还原的对象必须原来就是这个对象<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Animal animal = <span class="keyword">new</span> Cat();</span><br><span class="line">Cat cat = (Cat)animal;<span class="comment">//本来就是猫是可以还原的，</span></span><br><span class="line">Dog dog = (Dog)animal;<span class="comment">//错误，因为本来不是狗，非得当初狗</span></span><br></pre></td></tr></table></figure></li>
<li>instanceof关键字<br>是为了解决父类本来的引用类型是什么类型的问题，方便父类引用调用子类的独有方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">	Cat cat = (Cat)animal;<span class="comment">//是猫类型就可以转为猫</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">	Dog dog = (Dog)animal;<span class="comment">//是狗就可以转为狗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><ol>
<li>final代表最终，不可改变</li>
<li>当前类使用final时，就表示当前类没有子类，但是又父类，final类中的方法是不能覆盖重写的，因为没有子类，但是可以覆盖重写父类的方法</li>
<li>final修饰方法时，表示该方法是最终方法，不能被重写</li>
<li>final修饰局部变量，表示该变量不可变，必须保证变量有一次赋值，对于基本类型而言，不能变的是其中的数据，但对于引用数据而言，不能改变的是其中的地址值。但是引用类型中的数据是可变的。</li>
<li>final修饰成员变量，由于成员变量有默认值，因此final修饰的成员变量必须要手动赋值，不然默认值一赋值，就不能修改了，而赋值的方法，可以用构造函数赋值，也可以直接赋值，但是使用构造函数必须保证所有构造函数都能给final变量赋值，并且使用final修饰之后，set方法可以取消了，因为值是不能修改的</li>
</ol>
<h1 id="四种修饰符"><a href="#四种修饰符" class="headerlink" title="四种修饰符"></a>四种修饰符</h1><p>|—-||public|protexted|(default,不是关键字default，是不写)|private|<br>|同一个类(我自己)|yes|yes|yes|yes|<br>|同一个包(我邻居)|yes|yes|yes|no|<br>|不同包的子类(我儿子)|yes|yes|no|no|<br>|不同包的不同类(陌生人)|yes|no|no|no|no|</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><ol>
<li>分为成员内部类和局部内部类(包扩匿名内部类)</li>
<li>内部类使用外部类的东西随意使用，外部类使用内部类需要使用内部类对象</li>
<li>访问内部类可以通过在外部类的方法中使用内部类，在main方法中调用外部类方法(间接方法)，另一种是直接使用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">body.heart heart = <span class="keyword">new</span> body().<span class="keyword">new</span> heart();</span><br><span class="line"><span class="comment">//外部类.内部类 变量名 = new 外部类().new 内部类</span></span><br></pre></td></tr></table></figure></li>
<li>访问内部类的局部变量，直接写变量名，访问内部类的成员变量写this.变量名，访问外部类的成员变量使用outer.this.变量名</li>
<li>局部内部类只能在方法中使用，其他任何地方都无法使用，类的权限修饰符：外部类(public/(default)),成员内部类(四种修饰符都可以写),局部内部类(什么都不能写，与default不写是不同的，局部不写是因为只能方法中访问内部类)。</li>
<li>局部类的final：局部内部类访问局部变量需要局部变量保证是final不可变，从java8之后，只要保证局部变量事实不变就行，不需要手动写final，原因是局部变量的生命周期是随着方法结束而销毁的，但是内部类是new出来的存在堆区的，如果内部类想使用局部变量，就需要复制一份，但是复制的这份如果经常变化肯定是不行的，因此局部变量需要定义成final类型。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tes1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">9</span>;<span class="comment">//只赋值了一次，事实上不可变</span></span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">test3</span></span>&#123;</span><br><span class="line">			System.out.println(num);<span class="comment">//</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>匿名内部类，用于只想使用一次的地方<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyInterface obj = <span class="keyword">new</span> MyInterface()&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"匿名内部类"</span>)</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.method();</span><br><span class="line"></span><br><span class="line"><span class="comment">//整个大括号就是一个类，但是这个类是没有名字的所以是匿名的，而内部类可以覆盖重写接口中的抽象方法。这样方便调用</span></span><br></pre></td></tr></table></figure></li>
<li>匿名内部类的注意事项<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*new 接口名称()&#123;....&#125;</span></span><br><span class="line"><span class="comment">new就是创建对象的动作</span></span><br><span class="line"><span class="comment">接口名称就是匿名内部类需要实现哪个接口</span></span><br><span class="line"><span class="comment">&#123;....&#125;才是内部类的内容</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">匿名内部类，在创建对象时只能使用一次，如果希望多次创建对像，并且类的内容一样的话，就要使用单独的实现类</span></span><br><span class="line"><span class="comment">匿名对象，在调用方法的时候只能调用一次，如果希望同一个对象多次调用方法就必须给对象起个名字,</span></span><br><span class="line"><span class="comment">匿名内部类是省略了实现类/子类名称，但是匿名对象是省略了对象名称，匿名对象和匿名内部类不是一个东西</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		MyInterface objA = <span class="keyword">new</span> MyInterface()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"匿名内部类A"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		objA.method();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyInterface objB = <span class="keyword">new</span> MyInterface()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"匿名内部类B"</span>);<span class="comment">//创建对象只能创建一次</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		objB.method();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> MyInterface()&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"匿名对象"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;.method();<span class="comment">//只能使用一次方法，匿名对象</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><ol>
<li>字符串是常量，值不可以改变的，但是字符串缓冲区是可以改变的。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"a"</span>+<span class="string">"b"</span>+<span class="string">"c"</span> = <span class="string">"abc"</span>;</span><br><span class="line">String 在底层是一个被<span class="keyword">final</span>修饰的字符数组，长度不可变</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> [] value;</span><br><span class="line">这样的话会产生<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,三个初始字符串，接着拼接<span class="string">"ab"</span>+<span class="string">"c"</span> = <span class="string">"abc"</span>,又会产生<span class="number">2</span>个多余的字符串，非常占用内存空间</span><br><span class="line">但是StringBuilder底层是一个没有被<span class="keyword">final</span>修饰的字符数组，长度可变，默认长度是<span class="number">16</span></span><br><span class="line">这样就变成了<span class="string">"a"</span>+<span class="string">"b"</span>+<span class="string">"c"</span>=<span class="string">"abc"</span>,都存放在一个数组中，大大减少了内存占用。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="collection集合"><a href="#collection集合" class="headerlink" title="collection集合"></a>collection集合</h1><ol>
<li>集合长度可变，而数组的长度是不变的</li>
<li>数组中存储的是同一类型的数据，可以存储基本类型数据值，集合存储的都是对象，而且对象的类型可以不一致，开发中一般当对象多的时候，使用集合进行存储。</li>
<li>Iterator迭代器：为了遍历集合的接口，获取这个接口的实现类可以使用collection的Iterator方法来返回迭代器对象。</li>
<li>增前for循环的内部实现原理就是一个迭代器，专门用来遍历集合元素，写法:for(变量类型 变量名 : 集合或数组)</li>
</ol>
<h2 id="List-就是数据结构中的线性结构"><a href="#List-就是数据结构中的线性结构" class="headerlink" title="List(就是数据结构中的线性结构)"></a>List(就是数据结构中的线性结构)</h2><ol>
<li>ArrayList底层就是新建容量更大的数组，就是动态数组，只适合查询和遍历，不适合增删</li>
<li>LinkedList，就是链表，增删块，查询慢，但是头尾的增删操作非常块</li>
<li>Vector集合：底层也是动态数组，但是是同步的(单线程)，速度比上面两个不同步的慢(他是最早的list)</li>
</ol>
<h2 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h2><ol>
<li>hashset。是无序集合，底层是哈希表，查询非常快</li>
<li>jdk1.8之前，哈希表 = 数组+链表，1.8之后哈希表 = 数组 + 链表 + 红黑树，底层哈希表的结构就是初始化容量16的数组，保存16个哈希值，将冲突的哈希值，用链表(链地址法)连起来，当链表的长度超过8位时，就将链表转为红黑树存储</li>
<li>如果使用hashSet存储自定义元素，必须重写自己hashcode和equals方法，才能保证不存储重复元素。</li>
<li>LinkdedHashSet:是hashSet的子类，底层结构是哈希表+链表，多出来的链表是用来记录元素插入的顺序，从而实现有序集合</li>
</ol>
<h1 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h1><ol>
<li>和collection的单列集合不同，map是双列集合</li>
<li>Map&lt;k,v&gt;,k是键，v是值，一个元素包含两个元素。</li>
<li>key不能重复，v可以重复</li>
</ol>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ol>
<li>底层也是哈希表</li>
<li>是无序集合</li>
</ol>
<h2 id="LInkedHashmap"><a href="#LInkedHashmap" class="headerlink" title="LInkedHashmap"></a>LInkedHashmap</h2><ol>
<li>底层是哈希表+链表</li>
<li>是有序集合</li>
</ol>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><ol>
<li>底层也是哈希表</li>
<li>不允许存储空键或空值</li>
<li>他是最早期的set，是同步的，和vector的经历有点像</li>
</ol>
<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><ol>
<li>1.5之后出现的，使用前提是相同的数据类型，但是传入参数的个数不确定</li>
<li>底层就是使用一个数组将传入的参数存入数组<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>...arr)</span></span>&#123;<span class="comment">//int类型的可变参数</span></span><br><span class="line">	<span class="keyword">int</span> sum =<span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> a : arr ) &#123;</span><br><span class="line">		sum+=a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意事项：一个方法参数列表中只能所有一个可变参数，如果参数列表中有多个参数，那么可变参数必须放在最后</li>
</ol>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ol>
<li>泛型是一种未知的数据类型，可以用来接受各种类型的数据</li>
<li>不适用泛型，集合中元素都会向上转型成object类型，但是会出现类型转换错误，并且类型转换较为繁琐，使用泛型，能够知道存入的是上面数据类型，不会出现错误，提高安全性，但是只能存储单一类型的数据</li>
<li>泛型通配符：使用?来代表任意的数据类型，但是创建对象时不能使用只有在作为方法的参数时才能使用。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//错误，这样写是错误的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(ArrayList&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">	<span class="comment">//正确，这样写是表示可以接受任意类型的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>泛型的高级使用，受限泛型<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">? extends E<span class="comment">//代表使用的泛型只能是E的子类</span></span><br><span class="line">? <span class="keyword">super</span> E<span class="comment">//代表使用的泛型只能是E的父类</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="debug常用快捷键"><a href="#debug常用快捷键" class="headerlink" title="debug常用快捷键"></a>debug常用快捷键</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">f8逐行调试程序</span><br><span class="line">f7进入方法</span><br><span class="line">shift+f8跳出方法</span><br><span class="line">f9跳到下一个断点</span><br><span class="line">ctrl+f2退出debug模式，并停止程序</span><br><span class="line">console切换到控制台</span><br></pre></td></tr></table></figure>

<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ol>
<li>顶层Throwable有两个子类，error和exception，其中error是无法解决的，只能实现避免，exception是可以处理，处理之后可以正常运行的</li>
<li>异常分为编译期异常和运行期异常，编译期异常有两种处理方式，一种是throws抛出给jvm处理，另一种是trycatch自己捕获异常处理，jvm处理是异常产生时直接停止程序，而trycatch是把异常抛出后继续执行程序。</li>
<li>产生异常时，jvm会根据异常产生的原因位置和内容包装成一个对象，如果方法中没有trycatch进行处理，就会抛出异常给方法的调用者main函数，如果main函数中没有trycatch进行处理，就会继续抛出给main的调用者jvm，jvm拿到异常之后首先用红色字体在控制台上打印错误信息，接着终止当前运行的程序。</li>
</ol>
<h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><ol>
<li>throw关键字必须写在方法的内部，通过throw去抛出指定的异常，throw new xxxException</li>
<li>throw出异常之后必须处理异常，如果后面是RuntimeException及其子类对象，那么就会交给jvm去处理，打印错误信息，终止程序，如果是编译异常，就要么trycatch或者throws。</li>
<li>throws要在方法后面写，方法中有几个异常就要throws几个异常，throws是抛出给方法的调用者处理，trycatch是自己处理。</li>
</ol>
<h1 id="file类"><a href="#file类" class="headerlink" title="file类"></a>file类</h1><ol>
<li>操作文件夹和文件的类，对文件进行创建删除，增加等操作</li>
<li>相对路径和绝对路径：相对路径是相对与当前项目的路径，绝对路径是带盘符的路径(不是URL，URL是全世界互联网中的唯一路径)</li>
</ol>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><ol>
<li>用于抽象路径名的过滤器，找到我们想要找的文件或目录</li>
</ol>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>MySQL数据库</p>
<ol>
<li>驱动程序包名：mysql-connector-Java-3.1.11-bin.jar</li>
</ol>
<ul>
<li>驱动类的名字：com.mysql.jdbc.Driver</li>
<li>JDBC URL：jdbc:mysql://dbip:port/databasename</li>
<li>说明：驱动程序包名有可能会变</li>
<li>JDBC URL其中各个部分含义如下：</li>
<li>dbip –为数据库服务器的IP地址，如果是本地可写：localhost或127.0.0.1。</li>
<li>port –为数据库的监听端口，需要看安装时的配置，缺省为3306。</li>
<li>databasename –数据库的名字。</li>
</ul>
<p>例如我的数据库就是jdbc:mysql://127.0.0.1:3306/how2java</p>
<ol start="2">
<li>数据库的增删改：</li>
</ol>
<ul>
<li>增加：insert into table_name (指定的列) values (值)<br>数据库不区分大小写，<br>ex：``` insert into hero values (null,”+”‘提莫’”+”，”+312+”,”+50+”)<br>insert into hero (hp) values (320)<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 删除：<span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> ...(<span class="keyword">where</span> 是用来定位用的)</span><br><span class="line">删除表内全部内容：<span class="keyword">delete</span> *<span class="keyword">from</span> table_name</span><br><span class="line">-改 ：<span class="keyword">UPDATE</span> 表名称 <span class="keyword">SET</span> 列名称 = 新值 <span class="keyword">WHERE</span> 列名称 = 某值</span><br><span class="line"><span class="symbol">``</span><span class="symbol">` update hero set id = 2 where hp = 59</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h1><ol>
<li>操作数据库的步骤：</li>
</ol>
<ul>
<li>根据how2j的教程将sql的jar包下好并导入</li>
<li>导入sql操作必要的包<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;<span class="comment">//创建数据库与Java的连接对象</span></span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;<span class="comment">//驱动管理类，用来获取数据库的连接</span></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;<span class="comment">//用于报告与数据库相关的错误信息</span></span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;<span class="comment">//建立statement才能对数据库进行操作，statement对象：用来进行一些简单的无参查询sql语句</span></span><br></pre></td></tr></table></figure></li>
<li>建立Connection和Statement对象，并赋空值<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection c=<span class="keyword">null</span>;</span><br><span class="line">Statement s = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li>
<li>try-catch语句，首先加载驱动类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(com.mysql.jdbc.Driver);</span><br></pre></td></tr></table></figure>
Class.forName(className)可以简单的理解为：获得字符串参数中指定的类，并初始化该类。返回与给定的字符串名称相关联类或接口的Class对象。</li>
</ul>
<p>Class.forName是一个静态方法，同样可以用来加载类。<br>该方法有两种形式：Class.forName(String name, boolean initialize,ClassLoader loader)和 Class.forName(String className)</p>
<p>第一种形式的参数 name表示的是类的全名；<br>initialize表示是否初始化类；loader表示加载时使用的类加载器。<br>第二种形式则相当于设置了参数 initialize的值为 true，loader的值为当前类的类加载器。</p>
<ul>
<li>用DriverManager.getConnection(…..)连接数据库，并赋给可操作对象S<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">		Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		 c = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8"</span>,</span><br><span class="line">				<span class="string">"root"</span>,<span class="string">"admin"</span>);</span><br><span class="line">	    	</span><br><span class="line">		  s = c.createStatement();</span><br></pre></td></tr></table></figure></li>
<li>写sql语句，并用execute函数执行sql语句<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">"delete from hero where id = 8"</span>;</span><br><span class="line">		execute(sql);</span><br></pre></td></tr></table></figure></li>
<li>由于数据库资源有限，需要结束时关闭数据库<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(s!=<span class="keyword">null</span>) </span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				s.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">try</span> &#123;</span><br><span class="line">        	    c.close();	</span><br><span class="line">        	&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">        		e.printStackTrace();</span><br><span class="line">        	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>或者用try流自动关闭，将操作写在try后的()内，这样在结束后会自动关闭括号内的操作。</p>
<ul>
<li>printStackTrace()和普通print(e)的区别在于普通报错只会提醒错了，而printStackTrace会指出错误行和错误信息。</li>
</ul>
<p>完整版</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testjdbc</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">"delete from hero where id = 8"</span>;</span><br><span class="line">		execute(sql);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="comment">//*************************************************</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">	Connection c=<span class="keyword">null</span>;</span><br><span class="line">	Statement s = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		 c = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8"</span>,</span><br><span class="line">				<span class="string">"root"</span>,<span class="string">"admin"</span>);</span><br><span class="line">	    	</span><br><span class="line">		  s = c.createStatement();</span><br><span class="line">		 </span><br><span class="line">			</span><br><span class="line">			 s.execute(sql);</span><br><span class="line">		 </span><br><span class="line">	&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(s!=<span class="keyword">null</span>) </span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				s.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">try</span> &#123;</span><br><span class="line">        	    c.close();	</span><br><span class="line">        	&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">        		e.printStackTrace();</span><br><span class="line">        	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**********************************************</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数据库的增删改：只要将sql语句改写即可，详见上一篇数据库的操作。</li>
<li>sql的查询：用ResultSet 结果集来收集来自数据库的信息，这样可以通过对结果集的操作来查询数据，方便操作。</li>
</ol>
<ul>
<li>首先导入结果集包：<code>import java.sql.ResultSet</code></li>
<li>写sql语句，即将表中所有数据都收集到结果集中</li>
<li>创建结果集对象，并用get函数得到所需信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">"select *form hero "</span>;</span><br><span class="line">ResultSet rs = s.executeQuery(sql);</span><br><span class="line"><span class="keyword">while</span> (rs.next())&#123;<span class="comment">//rs.next()是判断数据库内是否还有数据，有就执行，无就退出</span></span><br><span class="line">	<span class="keyword">int</span> hp = rs.getInt(<span class="number">4</span>);</span><br><span class="line">	String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用查询语句来验证账号密码是否正确：</li>
</ul>
<ol>
<li>将数据表中数据全部加载到结果集中，在查找，但是数据一旦大了之后，内存都放不下，不推荐这种放法</li>
<li>将账号密码写入sql语句中，在数据库中查找含有关键字的数据。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = <span class="string">"haha"</span>;</span><br><span class="line">String password = <span class="string">"thisispassword"</span>;</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">"select *from hero where name = '"</span>+name+<span class="string">"' and password = '"</span>+password+<span class="string">"';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ResultSet rs = s.executeQuery(sql);</span></span><br><span class="line"><span class="string">if(rs.next())&#123;</span></span><br><span class="line"><span class="string">	System.out.println("</span>账号密码正确<span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">else&#123;</span></span><br><span class="line"><span class="string">	System.out.println("</span>账号密码错误<span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>统计表中有多少条数据<code>select count(*)from hero</code></li>
<li>分页查询：<code>select form hero limit 0,5</code>每5个数据为一页查询。</li>
</ol>
<h1 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h1><ol>
<li>array.sort:</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode周赛题目</title>
    <url>/2019/12/02/leetcode/</url>
    <content><![CDATA[<h1 id="164周赛第1题"><a href="#164周赛第1题" class="headerlink" title="164周赛第1题"></a>164周赛第1题</h1><p> 访问所有点的最小时间（切比雪夫距离）</p>
<p>平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。请你计算访问所有这些点需要的最小时间（以秒为单位）。</p>
<p>你可以按照下面的规则在平面上移动：</p>
<p>每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。<br>必须按照数组中出现的顺序来访问这些点。</p>
<p>在二维坐标中，二个点之间的距离定义为其各座标数值差绝对值的最大值。以(x1,y1)和(x2,y2)二点为例，其切比雪夫距离为max(|x2-x1|,|y2-y1|)。</p>
<a id="more"></a>

<p><img src="/2019/12/02/leetcode/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB.png" alt><br><img src="/2019/12/02/leetcode/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB1.png" alt><br>points.length是点的个数，范围是[1,100]，points[i].length是坐标长度，为2（x，y）。x，y距离都是-1000，1000</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(<span class="keyword">int</span>** points, <span class="keyword">int</span> pointsSize, <span class="keyword">int</span>* pointsColSize)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!points)   <span class="comment">//是points（点个数）为0的特殊情况</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i;i&lt;pointsSize<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">a=<span class="built_in">abs</span>(points[i][<span class="number">0</span>]-points[i+<span class="number">1</span>][<span class="number">0</span>]);<span class="comment">//x的最大值，i表示第几个点，0是每个元素的第一个值，即横坐标</span></span><br><span class="line">b=<span class="built_in">abs</span>(points[i][<span class="number">1</span>]-points[i+<span class="number">1</span>][<span class="number">1</span>]);<span class="comment">//y的最大值，i表示第几个点，1是每个元素的第一个值，即纵坐标</span></span><br><span class="line"><span class="keyword">if</span> (a&gt;=b)    <span class="comment">//a的差值大，就加a</span></span><br><span class="line">&#123;</span><br><span class="line">sum=sum+a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sum=sum+b;  <span class="comment">//b的差值大，就加b</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="164周赛第2题"><a href="#164周赛第2题" class="headerlink" title="164周赛第2题"></a>164周赛第2题</h1><p> 统计参与通信的服务器（逆向思维，从反面，减法出发）<br> 类似求某种存在多少符合条件的结果时，有时用逆向思维，用总数减去不符合的结果可能更简便。</p>
<p> 这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。</p>
<p>如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。</p>
<p>请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。</p>
<p>示例 1：<br><img src="/2019/12/02/leetcode/%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4.jpg" alt></p>
<p>输入：grid = [[1,0],[0,1]]<br>输出：0<br>解释：没有一台服务器能与其他服务器进行通信。<br>示例 2：<br><img src="/2019/12/02/leetcode/%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B41.jpg" alt></p>
<p>输入：grid = [[1,0],[1,1]]<br>输出：3<br>解释：所有这些服务器都至少可以与一台别的服务器进行通信。<br>示例 3：</p>
<p><img src="/2019/12/02/leetcode/%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B42.jpg" alt></p>
<p>输入：grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]<br>输出：4<br>解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。</p>
<p>提示：<br>m == grid.length   //行数<br>n == grid[i].length  //列数<br>1 &lt;= m &lt;= 250<br>1 &lt;= n &lt;= 250<br>grid[i][j] == 0 or 1  //存在or不存在</p>
<p>思路：</p>
<ol>
<li>由第一题启发，先遍历数组，将服务器位置输入，在统计能通信的（先遍历行，存在两个以上的服务器就是一台，列同理，但是缺点明显，会有重复的不好甄别）。</li>
<li>因此选用第二种方法，统计总服务器数目，减去不合结果的服务器（就是那台服务器所在行和列都只有一个1。<br>建立row数组用来存放每行服务器的数目，col数组用来存放每列服务器的数目，遍历数组，如果grid[row][col]存在服务器，且row=1，col=1.则此服务器无法与其他服务器通信，总数减一。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计所有服务器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">			row[i]++;</span><br><span class="line">			col[j]++;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除不能通信的服务器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>&amp;&amp;col[j]==<span class="number">1</span>&amp;&amp;row[i]==<span class="number">1</span>)&#123;</span><br><span class="line">			count--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="leetcode数组算法"><a href="#leetcode数组算法" class="headerlink" title="leetcode数组算法"></a>leetcode数组算法</h1><ol>
<li>删除数组中重复元素：</li>
</ol>
<ul>
<li>复杂算法：对数组进行遍历，找出重复元素个数，并并将其后的元素依次覆盖。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span> <span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">//p是数组首元素的地址，即数组名，size是数组大小</span></span><br><span class="line">	<span class="keyword">int</span> i,count=<span class="number">0</span>,j,i1;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;<span class="built_in">size</span>;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]==a[j])&#123;</span><br><span class="line">			count++;</span><br><span class="line">			<span class="keyword">for</span> (i1=i;i1&lt;<span class="built_in">size</span><span class="number">-1</span>;i1++)&#123;</span><br><span class="line">                    a[i1]=a[i1+<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">size</span>-count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>循环比较前后两个数字，如果相同就跳过，如果不同就将这个数字存进当前数组(数组下标从0开始)，并且len++；<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span> <span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="异或的使用-自反性"><a href="#异或的使用-自反性" class="headerlink" title="异或的使用(自反性)"></a>异或的使用(自反性)</h1><ol>
<li>异或的自反性是指：a ^ b ^ a = b。即对给定的数A，用同样的运算因子（B）作两次异或运算后仍得到A本身。</li>
<li>所有的程序教科书都会向初学者指出，要交换两个变量的值，必须要引入一个中间变量。但如果使用异或，就可以节约一个变量的存储空间：<br>设有A,B两个变量，存储的值分别为a，b，则以下三行表达式将互换他们的值 表达式（值）：<br>A=A^B(a^b)<br>B=B^A(b^a^b=a)<br>A=A^B(a^b^a=b)</li>
<li>落单的数</li>
</ol>
<p>给出2*n + 1 个的数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。<br>样例<br>给出 [1,2,2,1,3,4,3]，返回 4<br>此题可以用异或的性质做：一个数与自身异或的结果为0。我们只需遍历数组中的每一个元素，并将其进行异或。因为，异或满足交换律，所以最终的异或结果将仅仅包含只出现一次的那个数。<br>如：1 ^ 2 ^ 2 ^ 1 ^3 ^ 4 ^ 3 = 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 = 4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param A: An integer array</span></span><br><span class="line"><span class="comment">     * @return: An integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="comment">//采用异或的操作可以解决这个问题</span></span><br><span class="line">        <span class="keyword">if</span>(A.empty())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i != A.size();++i)&#123;</span><br><span class="line">            n = n^A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="当需要根据输入n来决定几位数时"><a href="#当需要根据输入n来决定几位数时" class="headerlink" title="当需要根据输入n来决定几位数时"></a>当需要根据输入n来决定几位数时</h1><ol>
<li>根据输入n来确定位数是先设start和end，用pow赋值<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> start = <span class="built_in">pow</span>(<span class="number">10</span>,n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">end</span> = <span class="built_in">pow</span>(<span class="number">10</span>,n);</span><br><span class="line"><span class="keyword">for</span>(i=start;i&lt;<span class="built_in">end</span>;i++)&#123;</span><br><span class="line">	..........</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="字符与出现次数一一对应的数组-特定法则"><a href="#字符与出现次数一一对应的数组-特定法则" class="headerlink" title="字符与出现次数一一对应的数组(特定法则)"></a>字符与出现次数一一对应的数组(特定法则)</h1><ol>
<li>将字符顺序与出现次数一一对应(仅限于字符种类已知的情况下，改进方法是创立127位数组，一位ASCII码就是127)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出0代表没有满足条件的</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">findFirstNoRepeatChar</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(str == <span class="keyword">null</span> || str.trim().length()==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> []counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">		str = str.toLowerCase(); <span class="comment">//防止出现大小写混乱的情况</span></span><br><span class="line">		<span class="keyword">int</span> len = str.length();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">			counts[str.charAt(i) - <span class="string">'a'</span>]++;<span class="comment">//charAt函数是根据索引位置返回索引位置的字符值，索引范围是[0,length-1]</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(counts[str.charAt(i) - <span class="string">'a'</span>] == <span class="number">1</span>)&#123;<span class="comment">//就是通过字符与a的相对位置，来确定次数数组的位置</span></span><br><span class="line">				<span class="keyword">return</span> str.charAt(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(findFirstNoRepeatChar(<span class="string">"abaccdeff"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUnique3</span><span class="params">(<span class="built_in">string</span> &amp;str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">127</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        c[str[i]]++;</span><br><span class="line">        <span class="keyword">if</span> (c[str[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>解法2：挑战中有提到不使用额外存储空间，能想到的解法是循环两次，内循环中遇到相同字母则结束，返回false。</li>
</ol>
<p>时间复杂度O(n^2),空间复杂度O(1)。</p>
<p>代码如下：</p>
<p>bool isUnique2(string &amp;str) {<br>    if (str.size() == 0 || str.size() == 1) {<br>        return true;<br>    }</p>
<pre><code>for (int i = 0; i &lt; str.size() - 1; i++) {
    for (int j = i+1; j &lt; str.size(); j++) {
        if (str[i] == str[j]) {
            return false;
        }
    }
}
return true;</code></pre><p>}</p>
<ul>
<li>变式：先排序，然后比较当前字符与前后两个字符是否相同，若不同就是答案</li>
</ul>
<ol start="3">
<li>用哈希表，键值对</li>
<li>7-2 求整数序列中出现次数最多的数 (15分)<br>本题要求统计一个整型序列中出现次数最多的整数及其出现次数。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret =<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line"><span class="keyword">int</span> a[number],temp[number];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">	count=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;number;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]==a[j])&#123;</span><br><span class="line">			count++;</span><br><span class="line">			temp[i]=count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = temp[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(temp[i]&gt;<span class="built_in">max</span>)&#123;</span><br><span class="line">		<span class="built_in">max</span>=temp[i];</span><br><span class="line">		ret = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d"</span>,a[ret],temp[ret]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>各种工具的问题和解决办法</title>
    <url>/2019/12/01/problem/</url>
    <content><![CDATA[<h1 id="devc-中文乱码"><a href="#devc-中文乱码" class="headerlink" title="devc++中文乱码"></a>devc++中文乱码</h1><p>是因为dev采用ANCI编码，不是用UTF-8编码<br>解决办法： </p>
<ul>
<li><p>用notpadc++打开，选择ANCI编码。</p>
<a id="more"></a>
<p><img src="/2019/12/01/problem/devc++.png" alt></p>
<ul>
<li>直接在dev中编辑</li>
</ul>
</li>
</ul>
<hr>
<h1 id="dev中斜杠报错"><a href="#dev中斜杠报错" class="headerlink" title="dev中斜杠报错"></a>dev中斜杠报错</h1><p>是不支持c++注释语法，误点击编辑器选项<br>解决办法：将<code>支持所有ANCI标准设置为NO</code><br><img src="/2019/12/01/problem/devc++1.png" alt></p>
<hr>
<h1 id="hexo中出现的中文乱码现象"><a href="#hexo中出现的中文乱码现象" class="headerlink" title="hexo中出现的中文乱码现象"></a>hexo中出现的中文乱码现象</h1><p> 第一步： 首先找到根目录下_config.yml文件，将langue字段设为zh-Hans或者zh-CN（简体中文），具体何种类型取决于theme主题中source文件中的language文件夹中有何种语言文件。<br><img src="/2019/12/01/problem/config_language.png" alt></p>
<p><img src="/2019/12/01/problem/theme_language.png" alt><br> 第二步： 出现乱码可能是因为用记事本编辑没有使用UTF-8编码，解决办法：下载文本编辑器（例如sublime）进行编辑。</p>
<p><img src="/2019/12/01/problem/sublime_encode.png" alt><br> 第三步： 点击sublime中file下的save with Encoding，选择UTF-8，<br> 直接点击save可能会出现警告.</p>
<hr>
<h1 id="hexo的图片上传"><a href="#hexo的图片上传" class="headerlink" title="hexo的图片上传"></a>hexo的图片上传</h1><p>  在根目录下建立与文章同名的文件夹，将图片放进去引用即可，或者用网络地址引用。<br> <img src="/2019/12/01/problem/image_post.png" alt></p>
<hr>
<h1 id="图标点击显示找不到页面。"><a href="#图标点击显示找不到页面。" class="headerlink" title="图标点击显示找不到页面。"></a>图标点击显示找不到页面。</h1><p><img src="/2019/12/01/problem/icon.png" alt><br>第一步：打开主题目录设置文件，找到menu。<br><img src="/2019/12/01/problem/menu.png" alt><br>第二步：将每个图标斜杠/后的空格删去。<br><img src="/2019/12/01/problem/menu1.png" alt></p>
<hr>
<h1 id="文章添加多个tags"><a href="#文章添加多个tags" class="headerlink" title="文章添加多个tags"></a>文章添加多个tags</h1><p>不能直接在tags标签后用空格隔开标签，应该用方括号中间用逗号隔开,<br>否则会出现文章无法上传的问题。</p>
<hr>
<h1 id="hexo页面上传"><a href="#hexo页面上传" class="headerlink" title="hexo页面上传"></a>hexo页面上传</h1><ol>
<li>标签和其他页面的格式要符合hexo的表准，单个标签用双引号，多个用方括号，中间不用双引号，否则页面无法上传。</li>
</ol>
<hr>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><ol>
<li>navicat 10061(MySQL服务未开启，无法连接到数据库)，是由于再金山毒霸里开启了开机加速，导致MySQL被禁止开机自启动，取消限制后任然没有作用，就可以通过手动启动来解决。</li>
</ol>
<ul>
<li>win + R启动运行程序，输入services.msc<br><img src="/2019/12/01/problem/mysql.png" alt></li>
<li>找到mysql服务打开即可<br><img src="/2019/12/01/problem/mysql1.png" alt></li>
</ul>
<h1 id="复制代码时会有大量？号或者其他乱码太多不好删除"><a href="#复制代码时会有大量？号或者其他乱码太多不好删除" class="headerlink" title="复制代码时会有大量？号或者其他乱码太多不好删除"></a>复制代码时会有大量？号或者其他乱码太多不好删除</h1><p>用ctrl+f，利用替换，选择范围从头开始而不是从当前光标开始，将乱码替换为空格，比用手更快捷</p>
<h1 id="IDEA导入文件"><a href="#IDEA导入文件" class="headerlink" title="IDEA导入文件"></a>IDEA导入文件</h1><p>一种是直接将文件移动到project目录下，另一种是拖动到IDEA界面中，自动移动</p>
<h1 id="servlet无法部署"><a href="#servlet无法部署" class="headerlink" title="servlet无法部署"></a>servlet无法部署</h1><ol>
<li>这是因为tomcat的版本一定要和jdk版本对应，不然就会报错，一般用default项目默认的jdk不会报错，但是万一仍然报错，就可以手动添加与tomcat相适应的jdk版本路径<br><img src="/2019/12/01/problem/Servlet.png" alt><br>我这里的是1.8版本，路径看自己放在那里，可以百度cmd命令查找</li>
</ol>
<h1 id="servlet访问资源不到"><a href="#servlet访问资源不到" class="headerlink" title="servlet访问资源不到"></a>servlet访问资源不到</h1><ol>
<li>这里是因为在部署好的war包里可以更改虚拟目录，教程是默认目录，而我的IDEA是自动项目名加war命名的，因此直接访问资源是不行的，但是项目多时，推荐<br>使用IDEA的默认方法，这样好区分。<br><img src="/2019/12/01/problem/%E8%99%9A%E6%8B%9F%E7%9B%AE%E5%BD%95.png" alt><br>这里访问资源时就要加上红线部分的虚拟目录</li>
</ol>
<h1 id="maven使用mvn-v命令显示不是内部或外部命令"><a href="#maven使用mvn-v命令显示不是内部或外部命令" class="headerlink" title="maven使用mvn -v命令显示不是内部或外部命令"></a>maven使用mvn -v命令显示不是内部或外部命令</h1><ol>
<li>确定maven的环境变量配置完成后，将maven下的bin命令加载path的%MAVEN_HOME%\bin之后作为补充路径<br><img src="/2019/12/01/problem/maven.png" alt></li>
</ol>
<h1 id="maven下载依赖包速度慢"><a href="#maven下载依赖包速度慢" class="headerlink" title="maven下载依赖包速度慢"></a>maven下载依赖包速度慢</h1><ol>
<li>使用镜像<br>在pom.xml中添加maven依赖包时，使用阿里的maven镜像就可以了<br>如果已经下载了一半退出，那就要先将c盘中user(用户)中的.m2文件删除，再在右键项目选中maven选项，然后选择“open settings.xml”或者 “create settings.xml”，然后把如下代码粘贴进去就可以了。重启IDE。(要将原来的内容覆盖掉)。</li>
</ol>
<p>复制代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mirror</span></span><br><span class="line"><span class="comment">         | Specifies a repository mirror site to use instead of a given repository. The repository that</span></span><br><span class="line"><span class="comment">         | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</span></span><br><span class="line"><span class="comment">         | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.</span></span><br><span class="line"><span class="comment">         |</span></span><br><span class="line"><span class="comment">        &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">          &lt;id&gt;mirrorId&lt;/id&gt;</span></span><br><span class="line"><span class="comment">          &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">          &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</span></span><br><span class="line"><span class="comment">          &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;</span></span><br><span class="line"><span class="comment">        &lt;/mirror&gt;</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>uk<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://uk.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>CN<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>OSChina Central<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.oschina.net/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>internal nexus repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;url&gt;http://192.168.1.100:8081/nexus/content/groups/public/&lt;/url&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果有需要联网的依赖包需要下载，可以到官网上找到所需的包的信息，将其复制到xml中即可，(注意，使用框架搭建好webapp后，<dependencies>标签已经创建好了，不需要再额外创建)<br><img src="/2019/12/01/problem/maven1.png" alt><br>将其粘贴到pom.xml中的<dependencies>中<br><img src="/2019/12/01/problem/maven2.png" alt></dependencies></dependencies></li>
</ol>
]]></content>
      <categories>
        <category>problem solution</category>
      </categories>
      <tags>
        <tag>解决办法，工具软件</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2019/11/23/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="scanf与gets的区别"><a href="#scanf与gets的区别" class="headerlink" title="scanf与gets的区别"></a>scanf与gets的区别</h1><ol>
<li>gets的分割符只有回车，而scanf的分隔符是所以空白字符(空格，制表符，回车)，因此gets能够读入空格，scanf不能<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">23</span>];</span><br><span class="line">gets(str);<span class="comment">//输入hello world，会原样输出，</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);<span class="comment">//scanf遇到空格会停止读入，输出hello</span></span><br></pre></td></tr></table></figure></li>
<li>对待buffer(缓冲区)里的空白字符不同：scanf在读取非空白字符之前会忽略掉空白字符(被忽略的空白字符会被scanf移走)，当读取结束后，会将分割符留在缓冲区中，而gets遇到回车就会结束输出，并将回车从缓冲区中移走，例如输入”\nhello\n”,scanf会先忽略\n，读入hello，遇到\n输入完成，将\n留在缓冲区，这是缓冲区里什么也没有，而gets遇到第一个\n就会停止输入，这时缓冲区里只剩hello\n，gets读入的是一个空串，即首字符为’\0’的字符串</li>
<li>gets读走分隔符后会用’\0’来代替分隔符</li>
<li>在程序中有时会遇到scanf，gets连用的，就会出先scanf留在缓冲区的空白字符是\n，导致gets只能读入空白字符串的情况，这时就可以用scanf(“%s”,str)来读走最后一个空表字符前的所有空表字符，再用getchar读入一个空白字符就可以解决问题</li>
<li>用gets读取是无上限的，但要保证缓冲区足够大，才不会发生内存溢出</li>
</ol>
<hr>
<h1 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h1><ol>
<li>用二维数组定义。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">3</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str1[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,str1[<span class="number">1</span>]);  <span class="comment">//输出第二个字符串</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>字符串数组第一个[]存储的是一位字符数组的地址，如果想获取具体某一个字符的话，就要加上列指针<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">3</span>][<span class="number">23</span>];</span><br><span class="line">str[<span class="number">2</span>];<span class="comment">//指向最后一行</span></span><br><span class="line">str[<span class="number">2</span>][<span class="number">0</span>];<span class="comment">//指向最后一行第一个字符</span></span><br></pre></td></tr></table></figure></li>
<li>二维数组名实际上是一个二级指针，而字符指针只是一个指向字符串的指针</li>
</ol>
<hr>
<h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><ol>
<li>puts函数：函数中可以加入转义符，且在输出结束字符串后会自动转行<br><code>char str[]={&quot;hello\nworld!&quot;};</code></li>
<li>strcat函数：<code>strcat(str1,str2);</code>是将两个字符串连接起来，返回值是字符串数组1的地址，并且注意字符串1的长度必须足够大。</li>
<li>strcpy：字符串复制函数<code>strcpy(str1,str2)</code>若是采用数组元素一个个赋值不方便，直接用函数赋值。<br>strcpy可以是数组名复制，也可以是字符串常量<code>strcpy(str1,&quot;china!&quot;);</code></li>
<li>strcmp：字符串比较函数（strcmp（str1，str2）），若str1&lt; str2，返回值小于0，若str1&gt;str2,返回值大于0.若str1==str2，则返回0（用来判断字符串的结束标志）。</li>
</ol>
<h1 id="字符串数组与函数名做参"><a href="#字符串数组与函数名做参" class="headerlink" title="字符串数组与函数名做参"></a>字符串数组与函数名做参</h1><ol>
<li>当要通过某个特定值来确定函数是否结束时，用strcmp==0来判断，而不    用srt[i]==’#’或者str [i] [j]=’#’来判断,即使特 定符号已经出现程序也会直接跳过(具体原因不知，有空再说)。</li>
<li>给字符串数组赋结束标志’\0’时，不能用str[i]==’\0’，而是应用str<br>[i][j]==’\0’来赋值(可能因为一个字符只能放一个数组格)</li>
<li>数组名做参：定义函数时，如果定义二维数组，那么列的值不能为空<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> fet (<span class="built_in">int</span> han[][<span class="number">20</span>])&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>注意形参要带变量类型，但是调用函数时不需要，尤其是字符串数组，只要带入数组名即可不需要包括后面[]的大小<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">fet(<span class="name">han</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>strcmp中，字符串数组和常量比较，常量字符串是用双引号，单个字符是用单引号</li>
</ol>
<h1 id="删除字符串中指定类型-由删除字符串中数字衍生而来"><a href="#删除字符串中指定类型-由删除字符串中数字衍生而来" class="headerlink" title="删除字符串中指定类型(由删除字符串中数字衍生而来)"></a>删除字符串中指定类型(由删除字符串中数字衍生而来)</h1><ol>
<li>通过循环将后面一个元素一直赋给前一个元素(小技巧，非数字可以用&lt;0or&gt;9)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span> <span class="params">(<span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">	gets(str);</span><br><span class="line">    del(str);</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span> <span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>,j;</span><br><span class="line">      <span class="keyword">for</span> (i=<span class="number">0</span>;*(str+i)!=<span class="string">'\0'</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">      	<span class="keyword">if</span>((*(str+i)&gt;=<span class="string">'0'</span>)&amp;&amp;(*(str+i)&lt;=<span class="string">'9'</span>))&#123;</span><br><span class="line">      		<span class="keyword">for</span> (j=i;*(str+j+<span class="number">1</span>)!=<span class="string">'\0'</span>;j++)</span><br><span class="line">      		&#123;</span><br><span class="line">      			*(str+j)=*(str+j+<span class="number">1</span>);	</span><br><span class="line">      		&#125;</span><br><span class="line">      		*(str+j)=<span class="string">'\0'</span>;<span class="comment">//每次向前移，就将结束标志前移 </span></span><br><span class="line">      		i=<span class="number">0</span>;<span class="comment">//不用双重循环就得将i置0，从头开始继续判断 </span></span><br><span class="line">      	&#125;</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
或者<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteString</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">char</span> str[<span class="number">15</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">15</span>];</span><br><span class="line">gets(str); </span><br><span class="line">deleteString(str,str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteString</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">char</span> str[<span class="number">15</span>])</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line">	<span class="keyword">char</span> *p1;</span><br><span class="line">	<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(p=a;p&lt;a+<span class="built_in">strlen</span>(str);p++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!(<span class="number">65</span>&lt;=*p&amp;&amp;*p&lt;=<span class="number">90</span>||<span class="number">97</span>&lt;=*p&amp;&amp;*p&lt;=<span class="number">122</span>))&#123;</span><br><span class="line">		          <span class="keyword">for</span>(p1=p;*p1!=<span class="string">'\0'</span>;p1++)&#123;</span><br><span class="line">		          	*p1=*(p1+<span class="number">1</span>);</span><br><span class="line">		          	 p--;</span><br><span class="line">				  &#125;</span><br><span class="line">		   &#125;</span><br><span class="line">		      </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(p=a;p&lt;a+<span class="built_in">strlen</span>(str);p++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>,*p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将符合要求的字符存入对应的位置<br>遇到符合条件的就可以按从头之尾的顺序输进原数组<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span> <span class="params">(<span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">23</span>];</span><br><span class="line">	gets(str);</span><br><span class="line">	del(str);</span><br><span class="line">	<span class="built_in">puts</span>(str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span> <span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,k=<span class="number">0</span>;</span><br><span class="line">     for (i=0;*(str+i)!='\0;i++)</span><br><span class="line">     &#123;</span><br><span class="line">     	<span class="keyword">if</span> (*(str+i)&lt;<span class="string">'0'</span>||*(str+i)&gt;<span class="string">'9'</span>)<span class="comment">//想要保留的字符</span></span><br><span class="line">     	&#123;</span><br><span class="line">     		*(str+(k++))=*(str+i);<span class="comment">//k每次自加</span></span><br><span class="line">     	&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     *(str+k)=<span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>建立新数组，将符合与不符合的分离，但是需要开辟新的数据空间</li>
</ol>
<h1 id="复制部分字符串"><a href="#复制部分字符串" class="headerlink" title="复制部分字符串"></a>复制部分字符串</h1><ol>
<li>指针要移动到目标位置-1处，因为基数不同</li>
<li>要一对一的赋值，不能因为s和t传进来的是指针，而不是数组，s并不会向后自动输出直到’\0’。</li>
<li>记得加上结束标志<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strmcpy</span><span class="params">( <span class="keyword">char</span> *t, <span class="keyword">int</span> m, <span class="keyword">char</span> *s )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t+=m<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(*t)</span><br><span class="line">        *s++=*t++;<span class="comment">//要一步步赋值，</span></span><br><span class="line">    <span class="comment">//因为s和t传进来的是指针，而不是数组，s并不会向后自动输出直到'\0'</span></span><br><span class="line">    *s=<span class="number">0</span>;<span class="comment">//加上结束标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="键盘输入字符串，并将其地址存入指针数组中"><a href="#键盘输入字符串，并将其地址存入指针数组中" class="headerlink" title="键盘输入字符串，并将其地址存入指针数组中"></a>键盘输入字符串，并将其地址存入指针数组中</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">3</span>][<span class="number">34</span>];</span><br><span class="line"><span class="keyword">char</span> *p[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	gets(str);</span><br><span class="line">	p[i]=str[i];<span class="comment">//关键就在这，str[i]实际上是二维数组每行的首地址，而</span></span><br><span class="line">	<span class="comment">//字符串正好就是按行地址输出的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串数组和指针数组区别"><a href="#字符串数组和指针数组区别" class="headerlink" title="字符串数组和指针数组区别"></a>字符串数组和指针数组区别</h1><ol>
<li></li>
</ol>
<ul>
<li>数组法占用空间大，必须开辟可以容纳最大字符串长度的空间，会造从内存的浪费，而指针数组存放的是指针，空间占用小。</li>
<li>数组法操作运行次数多，每次进行字符串的交换都要进入strcpy函数，耗费时间比指针法多，指针法只需要交换指针所指的值就可以</li>
<li>字符数组做形参时，数组大小要标出</li>
<li>指针数组，使用时需要进行初始化赋值，或者需要指向具体的内存单元后，才能作为函数实参进行调用</li>
<li>指针数组 作为函数形参时，数组大小可以不指定</li>
</ul>
<ol start="2">
<li><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    <span class="keyword">char</span> str[N][<span class="number">30</span>],tmp[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(str[j],str[j+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(tmp,str[j]);</span><br><span class="line">                <span class="built_in">strcpy</span>(str[j],str[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">strcpy</span>(str[j+<span class="number">1</span>],tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After sorted:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> *p,<span class="keyword">char</span> *p1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N,j,i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">	<span class="keyword">char</span> str[N][<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> *p[N];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		p[i]=str[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">          	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(p[j],p[j+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">          		swap(p[j],p[j+<span class="number">1</span>]);</span><br><span class="line">          	&#125;</span><br><span class="line">          &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="built_in">puts</span>(str[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> *p,<span class="keyword">char</span> *p1)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *t=<span class="literal">NULL</span>；</span><br><span class="line">	t=p;</span><br><span class="line">	p=p1;</span><br><span class="line">	p1=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="使用命令行输主函数参数"><a href="#使用命令行输主函数参数" class="headerlink" title="使用命令行输主函数参数"></a>使用命令行输主函数参数</h1><ol>
<li>int main(int argc, char * argv[]){}<br>argc 是命令行输入的参数字符串个数，argv是字符指针数组，元素按顺序指向命令行的参数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">c.exe <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">argc=<span class="number">4</span>;</span><br><span class="line">argv[0]='c.exe';</span><br><span class="line">argv[<span class="number">1</span>]=<span class="string">'1'</span>;</span><br><span class="line">argv[<span class="number">2</span>]=<span class="string">'+'</span>;</span><br><span class="line">argv[<span class="number">3</span>]=<span class="string">'2'</span>;</span><br><span class="line">``` </span><br><span class="line"><span class="number">2.</span> 使用命令行首先要生成可执行文件，然后通过dos命令转到可执行文件所在目录，再输入参数</span><br><span class="line">```c</span><br><span class="line"><span class="comment">//假设可执行文件在D：\test</span></span><br><span class="line"></span><br><span class="line">d:</span><br><span class="line">cd test</span><br><span class="line">c.exe <span class="number">1</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li>字符串数组第一个[]存储的是一位字符数组的地址，如果想获取具体某一个字符的话，就要加上列指针<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">3</span>][<span class="number">23</span>];</span><br><span class="line">str[<span class="number">2</span>];<span class="comment">//指向最后一行</span></span><br><span class="line">str[<span class="number">2</span>][<span class="number">0</span>];<span class="comment">//指向最后一行第一个字符</span></span><br><span class="line"><span class="comment">//比如这里要判断是什么数学符号，就要用argv[2][0],而不是argv[2]</span></span><br><span class="line"><span class="comment">//因为字符数组形式和字符不等价</span></span><br></pre></td></tr></table></figure></li>
<li>字符化为整型数<br>用aoti函数化整数，aotf化浮点数<br>iota将整数化为字符，fota将浮点数化为字符<br>传入字符的指针即可<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">char *p='afsudiijsa';</span><br><span class="line">aoti(p);</span><br><span class="line"><span class="comment">//在主函数中，就是argv【1】和argv【3】，而不是*argv【1】</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="在printf函数中输出"><a href="#在printf函数中输出" class="headerlink" title="在printf函数中输出%"></a>在printf函数中输出%</h1><p>%是格式符，想要输出文本，就得用两个%%</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d%%%d=%d\n"</span>,a,b,a%b);</span><br></pre></td></tr></table></figure>

<h1 id="给字符数组赋值"><a href="#给字符数组赋值" class="headerlink" title="给字符数组赋值"></a>给字符数组赋值</h1><p>main()<br>{<br>char s[30];<br>strcpy(s, “Good News!”); /<em>给数组赋字符串</em>/<br>.<br>.<br>.<br>}<br>上面程序在编译时, 遇到char s[30]这条语句时, 编译程序会在内存的某处留<br>出连续30个字节的区域, 并将第一个字节的地址赋给s。当遇到strcpy( strcpy 为<br>Turbo C2.0的函数)时, 首先在目标文件的某处建立一个”Good News!/0” 的字符串。<br>其中/0表示字符串终止, 终止符是编译时自动加上的, 然后一个字符一个字符地复<br>制到s所指的内存区域。因此定义字符串数组时, 其元素个数至少应该比字符串的<br>长度多1。<br>注意:</p>
<ol>
<li>字符串数组不能用”=”直接赋值, 即s=”Good News!”是不合法的。所以应分<br>清字符串数组和字符串指针的不同赋值方法。</li>
<li>对于长字符串, Turbo C2.0允许使用下述方法:<br>例如:<br>main()<br>{<br>char s[100];<br>strcpy(s, “The writer would like to thank you for”<br>“your interest in his book. He hopes you”<br>“can get some helps from the book.”);<br>.<br>.<br>.<br>}</li>
</ol>
<p>指针数组赋值
　</p>
<p>例如:<br>main()<br>{<br>char <em>f[2];<br>int <em>a[2];<br>f[0]=”thank you”; /</em>给字符型数组指针变量赋值</em>/<br>f[1]=”Good Morning”;<br><em>a[0]=1, <em>a[1]=-11; /</em>给整型数数组指针变量赋值</em>/<br>.<br>.<br>.<br>}</p>
<p>无论是静态，局部还是全局数组只有在定义时才能初始话，否则必须通过其它方法，比如循环操作实现。</p>
<p>任何<br>int a[3];<br>static int b[3];<br>a[3] = {1, 2, 3};<br>b[3] = {1, 2, 3};<br>没有在定义时初始化都是错误的！</p>
<hr>
<p>以下是转载：<br>学了这么多年的C语言，突然发现连字符串赋值都出错，真的很伤心。</p>
<p>char a[10];<br>怎么给这个数组赋值呢？<br>1、定义的时候直接用字符串赋值<br>char a[10]=”hello”;<br>注意：不能先定义再给它赋值，如char a[10]; a[10]=”hello”;这样是错误的！<br>2、对数组中字符逐个赋值<br>char a[10]={‘h’,’e’,’l’,’l’,’o’};<br>3、利用strcpy<br>char a[10]; strcpy(a, “hello”);</p>
<p>易错情况：<br>1、char a[10]; a[10]=”hello”;//一个字符怎么能容纳一个字符串？况且a[10]也是不存在的！<br>2、char a[10]; a=”hello”;//这种情况容易出现，a虽然是指针，但是它已经指向在堆栈中分配的10个字符空间，现在这个情况a又指向数据区中的hello常量，这里的指针a出现混乱，不允许！</p>
<p>还有：不能使用关系运算符“＝＝”来比较两个字符串，只能用strcmp() 函数来处理。</p>
<p>C语言的运算符根本无法操作字符串。在C语言中把字符串当作数组来处理，因此，对字符串的限制方式和对数组的一样，特别是，它们都不能用C语言的运算符进行复制和比较操作。</p>
<p>直接尝试对字符串进行复制或比较操作会失败。例如，假定str1和str2有如下声明：</p>
<p>char str1[10], str2[10];</p>
<p>利用=运算符来把字符串复制到字符数组中是不可能的：</p>
<p>str1 = “abc”;     /<strong>* WRONG *</strong>/</p>
<p>str2 = str1;       /<strong>* WRONG *</strong>/</p>
<p>C语言把这些语句解释为一个指针与另一个指针之间的（非法的）赋值运算。但是，使用=初始化字符数组是合法的：</p>
<p>char str1[10] = “abc”;</p>
<p>这是因为在声明中，=不是赋值运算符。</p>
<p>试图使用关系运算符或判等运算符来比较字符串是合法的，但不会产生预期的结果：</p>
<p>if (str1==str2) …    /<strong>* WRONG *</strong>/<br>这条语句把str1和str2作为指针来进行比较，而不是比较两个数组的内容。因为str1和str2有不同的地址，所以表达式str1 == str2的值一定为0。</p>
<ol start="2">
<li><p>C语言 谭浩强课本讲的很清楚：</p>
<p>符号常量 与普通变量的区别：</p>
</li>
</ol>
<p>符号常量 不占用存储空间，所以就没有内地址 了哦。</p>
<p>大家都懂 C语言的基本语法，但是 很多细节问题，就只有不同深入学习才懂的。</p>
<p>c和指针还是c专家编程上讲过，const修饰的是一个只读变量，所以可以用&amp;取得一个const变量的地址。</p>
<h1 id="用指针指向字符串"><a href="#用指针指向字符串" class="headerlink" title="用指针指向字符串"></a>用指针指向字符串</h1><ol>
<li>在结构体中，不能用字符串指针来代替结构体中的变量名<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> math,english,computer;</span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Stu s;</span><br><span class="line"><span class="keyword">char</span> *p=<span class="string">"math"</span>;</span><br><span class="line"><span class="keyword">char</span> *p1=<span class="string">"english"</span>;</span><br><span class="line"><span class="keyword">char</span>* p2=<span class="string">"computer"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,s.*p);<span class="comment">//这样写法是错误的，就是这么规定的</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>字符串指针所指向的是字符串常量，复制后就不能进行更改</li>
<li>输出字符串时要用%s，用%c想输出单个字符会输出乱码</li>
<li>字符串指针是可以移动的，可以用移动的指针来指定输出的位置<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p=<span class="string">"sfjalsafs"</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,(p+<span class="number">3</span>) );<span class="comment">//从a开始输出</span></span><br></pre></td></tr></table></figure></li>
<li>字符指针数组中存放的是字符串第一个字符的地址，而不是将字符串存放进去，字符指针也是</li>
<li>字符串的判断结束要用<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(*s)</span><br><span class="line"><span class="keyword">while</span>(*s!=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span>(s)<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>字符串，c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
