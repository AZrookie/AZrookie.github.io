<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构与算法实战</title>
    <url>/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ol>
<li>通过指针引用数组元素，<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a [<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p=&amp;a;</span><br><span class="line">(p+i)<span class="comment">//第i个元素的地址</span></span><br><span class="line">*(p+i)<span class="comment">//第i个元素</span></span><br></pre></td></tr></table></figure>
！！！！数组名为第一个元素a[i]的地址，是一个指针常量，不能进行a++运算，<br>要用a+1进行运算(递归注意，就是这里错的)。但是用<code>int *p=a</code>之后就可以用p++。</li>
</ol>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><ol>
<li><p>概念：递归算法的思想实质就是分治策略，将一个问题拆解成不能再拆解的最小问题(递推分解)，再将最小问题的解返回给上一级(回归分治)。并且在运行到最小问题的时候一定要给出结束的条件，否则会无线递归，占用完内存最终导致程序崩溃。</p>
</li>
<li><p>递归与循环的区别：递归在底层实际上是对线程栈的压栈和出栈(递归是先调用的函数最后运算)，每调用一次都会压栈一次，并记录相关的局部变量信息，无限的递归耗用的是内存资源，而死循耗用的是CPU资源，死循环并不会引起程序的异常，但递归耗完内存就会引发程序的崩溃。</p>
</li>
<li><p>与循环十分类似，但是递归是通过不断打开新函数来运算的，效率上明显不如循环，实际上也是经常用循环而不是用递归。</p>
</li>
<li><p>实例：求n!阶乘</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factrial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//设立的终止条件</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n*factrial(n<span class="number">-1</span>);<span class="comment">//重复的步骤</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题分析：首先找出问题的重复步骤，此题中是n!=1<em>2</em>3<em>….n,那么可见每次n+1就是重复步骤。但是递归是由大问题向小问题分解，就变成了n!=n</em>n-1<em>n-1….</em>1(这也符合栈先进后出的特点)。终止条件显而易见，就是n==1，return 1。<br>程序分析：当n&gt;1时，程序运行到<code>return n*factrial(n-1)</code>时，会打开factrial(n-1)函数，以此类推，最后变为：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">n<span class="number">*fac</span>trial(n-1)<span class="number">*fac</span>trial(n-2)<span class="built_in">..</span><span class="built_in">..</span><span class="number">*fac</span>trial(1)</span><br></pre></td></tr></table></figure>
<p>其中<code>factrial(1) return 1</code>，那么返回上一级函数是2，在上一级就是3。</p>
</li>
</ol>
<p><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E9%80%92%E5%BD%921.jpeg" alt><br><img src="/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/%E9%80%92%E5%BD%922.jpeg" alt></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>c语言，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title>java复习</title>
    <url>/2019/12/19/java/</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ol>
<li>局部变量(local variable):方法或语句块内的变量，其生命周期是从声明位置开始到方法或语句块结束为止。(和c的函数局部变量一样)。<a id="more"></a></li>
<li>成员变量(member variable)：也叫实例变量，方法外，类的内部的变量，其生命周期伴随对象始终。并且成员变量在定义时如果没有手动赋值，会默认赋初始值，数字是0，字符是null，布尔是false。</li>
<li>静态变量(类变量 static variable):用static关键字表示，从属于类，生命周期从类加载到卸载，伴随类的始终。</li>
<li>周期比较(小到大)：局部变量(从属于方法)&lt;成员变量(从属于对象)&lt;静态变量(从属于类)。而c中类似的只有局部变量和静态变量的概念。(c是面向过程编程，不同于面向对象，没有对象的概念)。</li>
</ol>
<hr>
<h1 id="变量和常量的命名规范"><a href="#变量和常量的命名规范" class="headerlink" title="变量和常量的命名规范"></a>变量和常量的命名规范</h1><ol>
<li>所有变量和方法名都是首字母小写和驼峰原则。</li>
<li>常量是大写字母和下划线。</li>
<li>类名大写字母和驼峰原则。</li>
</ol>
<hr>
<h1 id="自动转化"><a href="#自动转化" class="headerlink" title="自动转化"></a>自动转化</h1><ol>
<li>指容量小的数据类型自动转为容量大的数据类型，容量指的是表示范围，例如short a = 12 合法，但short a = 1234567不合法，超出了short的表示范围。<br>其中实线表示可以不损失精度直接转换，虚线是可能会有精度损失。<br><img src="/2019/12/19/java/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt></li>
</ol>
<h1 id="Scanner获取键盘输入"><a href="#Scanner获取键盘输入" class="headerlink" title="Scanner获取键盘输入"></a>Scanner获取键盘输入</h1><ol>
<li>首先要导入Scanner所在包</li>
<li>新建Scanner对象</li>
<li>建立变量存储键盘输入的值<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner<span class="comment">//引进包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">               Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//in是io流</span></span><br><span class="line">               System.out.println(<span class="string">"请输入名字"</span>);</span><br><span class="line">               String name = Scanner.nextline();<span class="comment">//字符串是nextline</span></span><br><span class="line">               System.out.println(<span class="string">"请输入爱好"</span>);</span><br><span class="line">               String favor = Scanner.nextline();</span><br><span class="line">               System.out.println(<span class="string">"请输入年龄"</span>);</span><br><span class="line">               <span class="keyword">int</span> age = Scanner.nextInt();<span class="comment">//数字是nextInt</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ol>
<li>主类中方法前加static，表名该方法是类的共享成员，可以被该类所有的实例化对象访问，当类加载时，static方法就被加载，其声明周期从属于类。若是不定义static，也可以通过对象调用普通方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testmethod</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">	<span class="keyword">int</span> m = scanner.nextInt();</span><br><span class="line">	<span class="keyword">int</span> x = sum(n,m);</span><br><span class="line">	System.out.println(<span class="string">"n+m="</span>+x);<span class="comment">//直接调用</span></span><br><span class="line">	</span><br><span class="line">	Testmethod th = <span class="keyword">new</span> Testmethod();</span><br><span class="line">	<span class="keyword">int</span> a = th.sum(<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">	System.out.println(a);<span class="comment">//对象调用</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">int</span> m)</span> </span>&#123; 	<span class="comment">//static 修饰的函数可以在主类中直接调用</span></span><br><span class="line">	<span class="keyword">return</span> m+n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//没有static要先创建对象，在通过对象调用方法</span></span><br><span class="line">	<span class="keyword">return</span> n+m+x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法的重载(overload)：函数名相同但参数列表不同(参数个数，顺序，类型)，只有返回值和形参名称不构成重载。</li>
</ol>
<h1 id="对象-object-instance"><a href="#对象-object-instance" class="headerlink" title="对象(object,instance)"></a>对象(object,instance)</h1><ol>
<li>对象是具体的事物;类是对对象的抽象;</li>
<li>类可以看成一类对象的模板，对象可以看成该类的一个具体实例。</li>
<li>类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性</li>
</ol>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ol>
<li>每个文件都只能由一个public class，且类名必须与文件名一致。可以定义多个普通类</li>
<li>类里由三个成员，属性(field),方法(method),构造方法(constructor)</li>
<li>类可以相互引用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testclass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line">	 grade ge;<span class="comment">//类名+属性名</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	grade g1 = <span class="keyword">new</span> grade();</span><br><span class="line">	Testclass stu1 = <span class="keyword">new</span> Testclass();</span><br><span class="line">	g1.grade = <span class="number">2</span>;</span><br><span class="line">	stu1.ge = g1;</span><br><span class="line">	System.out.printf(<span class="string">"年级"</span>+stu1.ge);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grade</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> grade;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="构造方法-constructor"><a href="#构造方法-constructor" class="headerlink" title="构造方法(constructor)"></a>构造方法(constructor)</h1><ol>
<li><p>用于对象的初始化，在对象创建时被调用，构造器的名称应该与类的名称一致，    虽然有返回值，但不能加return(返回值必然时本类)，即public+类名(不用加返回值类型名)</p>
</li>
<li><p>构造方法同样可以重载，但是当形参和实参重复时，就要用this关键字，this指代正在创建的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hero</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> hp ;</span><br><span class="line">   <span class="keyword">int</span> speed;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">hero</span> <span class="params">(<span class="keyword">int</span> hp,<span class="keyword">int</span> speed)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.hp = hp;  <span class="comment">//this.hp 指代创建对象的hp，等号后面的hp是形参hp</span></span><br><span class="line">		<span class="keyword">this</span>.speed = speed;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><ol>
<li>类和类之间的关系有5种，分别是：</li>
</ol>
<p><img src="/2019/12/19/java/%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt></p>
<ul>
<li>自身：hero类</li>
<li>同包子类：charactor包里继承了hero包的类(ADhero)</li>
<li>不同包子类：charactor1和property包里的继承了hero的类(support)</li>
<li>同包类：charactor包里除了hero的所有类</li>
<li>其他类：除上述类外的所有类</li>
</ul>
<ol start="2">
<li>修饰符类型：</li>
</ol>
<ul>
<li>private只能自己访问，其余任何类都不能访问或继承<br><img src="/2019/12/19/java/private.png" alt></li>
<li>package/friendly/default,没有修饰符是的默认修饰符，同包的子类和其他类可以继承和访问，但其他类的子类和类就不能访问和继承。<br><img src="/2019/12/19/java/default.png" alt></li>
<li>protected，除其他类不能访问外，同包和不同包都可以继承。<br><img src="/2019/12/19/java/protected.png" alt></li>
<li>public，任何地方，都可以访问<br><img src="/2019/12/19/java/public.png" alt></li>
</ul>
<ol start="3">
<li>适用范围：</li>
</ol>
<ul>
<li>属性通常使用private封装起来</li>
<li>方法一般使用public用于被调用</li>
<li>会被子类继承的方法，通常使用protected</li>
<li>package用的不多，一般新手会用package,因为还不知道有修饰符这个东西</li>
</ul>
<p>-再就是作用范围最小原则<br>  简单说，能用private就用private，不行就放大一级，用package,再不行就用protected，最后用public。这样就能把数据尽量的封装起来，没有必要露出来的，就不用露出来了</p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ol>
<li>又叫singleton，一个类在一个JVM里只有一个实例村在。有两种办法，两种办法的步骤都是</li>
</ol>
<ul>
<li>将构造方法私有化，使其不能被外部方法更改</li>
<li>将类属性实例化(二者主要区别就在这里)</li>
<li>写public static(类方法)，返回instance(实例)</li>
</ul>
<p>懒汉式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	giantDragon g1 = giantDragon.getInstance();</span><br><span class="line">	giantDragon g2 = giantDragon.getInstance();</span><br><span class="line">	System.out.println(g1==g2);<span class="comment">//返回true，两者是同一对象</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">giantDragon</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">giantDragon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;<span class="comment">//构造器私有化</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> giantDragon instance;<span class="comment">//定义一个类属性，</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> giantDragon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;<span class="comment">//调用getIstance函数，如果没有实例，就新建一个</span></span><br><span class="line">			instance = <span class="keyword">new</span> giantDragon();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;<span class="comment">//如果已经有的话就返回实例</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	giantDragon g1 = giantDragon.getInstance();</span><br><span class="line">	giantDragon g2 = giantDragon.getInstance();</span><br><span class="line">	System.out.println(g1==g2);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">giantDragon</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">giantDragon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> giantDragon instance = <span class="keyword">new</span> giantDragon();<span class="comment">//二者差别就在于此，饿汉式是加载类的时侯就加载完成的，即不管是否调用getInstance，类属性都被被实例化，而懒汉式只有当调用时才会实例化</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> giantDragon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>饿汉式是立即加载的方式，无论是否会用到这个对象，都会加载。<br>如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。</li>
</ol>
<p>懒汉式，是延迟加载的方式，只有使用的时候才会加载。 并且有线程安全的考量。<br>使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。</p>
<p>看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式</p>
<h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><ol>
<li>使用枚举类型时，要另外定义一个新的public类，因为一个Java文件只能有一个public类，常用于switch结构里(用来定义常量)，可以防止case越界引起程序的混乱。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hhh</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Season s: Season.Values())&#123;</span><br><span class="line">			System.out.println(s);<span class="comment">//增强型循环，变量类型+中间变量+要输出的内容</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在另外一个文件里定义枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season&#123;</span><br><span class="line">	SPRING,SUMMER,AUTUMN,WINTER<span class="comment">//没有分号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode周赛题目</title>
    <url>/2019/12/02/leetcode/</url>
    <content><![CDATA[<h1 id="164周赛第1题"><a href="#164周赛第1题" class="headerlink" title="164周赛第1题"></a>164周赛第1题</h1><p> 访问所有点的最小时间（切比雪夫距离）</p>
<p>平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。请你计算访问所有这些点需要的最小时间（以秒为单位）。</p>
<p>你可以按照下面的规则在平面上移动：</p>
<p>每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。<br>必须按照数组中出现的顺序来访问这些点。</p>
<p>在二维坐标中，二个点之间的距离定义为其各座标数值差绝对值的最大值。以(x1,y1)和(x2,y2)二点为例，其切比雪夫距离为max(|x2-x1|,|y2-y1|)。</p>
<a id="more"></a>

<p><img src="/2019/12/02/leetcode/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB.png" alt><br><img src="/2019/12/02/leetcode/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB1.png" alt><br>points.length是点的个数，范围是[1,100]，points[i].length是坐标长度，为2（x，y）。x，y距离都是-1000，1000</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(<span class="keyword">int</span>** points, <span class="keyword">int</span> pointsSize, <span class="keyword">int</span>* pointsColSize)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!points)   <span class="comment">//是points（点个数）为0的特殊情况</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i;i&lt;pointsSize<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">a=<span class="built_in">abs</span>(points[i][<span class="number">0</span>]-points[i+<span class="number">1</span>][<span class="number">0</span>]);<span class="comment">//x的最大值，i表示第几个点，0是每个元素的第一个值，即横坐标</span></span><br><span class="line">b=<span class="built_in">abs</span>(points[i][<span class="number">1</span>]-points[i+<span class="number">1</span>][<span class="number">1</span>]);<span class="comment">//y的最大值，i表示第几个点，1是每个元素的第一个值，即纵坐标</span></span><br><span class="line"><span class="keyword">if</span> (a&gt;=b)    <span class="comment">//a的差值大，就加a</span></span><br><span class="line">&#123;</span><br><span class="line">sum=sum+a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sum=sum+b;  <span class="comment">//b的差值大，就加b</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="164周赛第2题"><a href="#164周赛第2题" class="headerlink" title="164周赛第2题"></a>164周赛第2题</h1><p> 统计参与通信的服务器（逆向思维，从反面，减法出发）<br> 类似求某种存在多少符合条件的结果时，有时用逆向思维，用总数减去不符合的结果可能更简便。</p>
<p> 这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。</p>
<p>如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。</p>
<p>请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。</p>
<p>示例 1：<br><img src="/2019/12/02/leetcode/%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4.jpg" alt></p>
<p>输入：grid = [[1,0],[0,1]]<br>输出：0<br>解释：没有一台服务器能与其他服务器进行通信。<br>示例 2：<br><img src="/2019/12/02/leetcode/%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B41.jpg" alt></p>
<p>输入：grid = [[1,0],[1,1]]<br>输出：3<br>解释：所有这些服务器都至少可以与一台别的服务器进行通信。<br>示例 3：</p>
<p><img src="/2019/12/02/leetcode/%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B42.jpg" alt></p>
<p>输入：grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]<br>输出：4<br>解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。</p>
<p>提示：<br>m == grid.length   //行数<br>n == grid[i].length  //列数<br>1 &lt;= m &lt;= 250<br>1 &lt;= n &lt;= 250<br>grid[i][j] == 0 or 1  //存在or不存在</p>
<p>思路：</p>
<ol>
<li>由第一题启发，先遍历数组，将服务器位置输入，在统计能通信的（先遍历行，存在两个以上的服务器就是一台，列同理，但是缺点明显，会有重复的不好甄别）。</li>
<li>因此选用第二种方法，统计总服务器数目，减去不合结果的服务器（就是那台服务器所在行和列都只有一个1。<br>建立row数组用来存放每行服务器的数目，col数组用来存放每列服务器的数目，遍历数组，如果grid[row][col]存在服务器，且row=1，col=1.则此服务器无法与其他服务器通信，总数减一。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计所有服务器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">			row[i]++;</span><br><span class="line">			col[j]++;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除不能通信的服务器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>&amp;&amp;col[j]==<span class="number">1</span>&amp;&amp;row[i]==<span class="number">1</span>)&#123;</span><br><span class="line">			count--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>各种工具的问题和解决办法</title>
    <url>/2019/12/01/problem/</url>
    <content><![CDATA[<h1 id="devc-中文乱码"><a href="#devc-中文乱码" class="headerlink" title="devc++中文乱码"></a>devc++中文乱码</h1><p>是因为dev采用ANCI编码，不是用UTF-8编码<br>解决办法： </p>
<ul>
<li><p>用notpadc++打开，选择ANCI编码。</p>
<a id="more"></a>
<p><img src="/2019/12/01/problem/devc++.png" alt></p>
<ul>
<li>直接在dev中编辑</li>
</ul>
</li>
</ul>
<hr>
<h1 id="dev中斜杠报错"><a href="#dev中斜杠报错" class="headerlink" title="dev中斜杠报错"></a>dev中斜杠报错</h1><p>是不支持c++注释语法，误点击编辑器选项<br>解决办法：将<code>支持所有ANCI标准设置为NO</code><br><img src="/2019/12/01/problem/devc++1.png" alt></p>
<hr>
<h1 id="hexo中出现的中文乱码现象"><a href="#hexo中出现的中文乱码现象" class="headerlink" title="hexo中出现的中文乱码现象"></a>hexo中出现的中文乱码现象</h1><p> 第一步： 首先找到根目录下_config.yml文件，将langue字段设为zh-Hans或者zh-CN（简体中文），具体何种类型取决于theme主题中source文件中的language文件夹中有何种语言文件。<br><img src="/2019/12/01/problem/config_language.png" alt></p>
<p><img src="/2019/12/01/problem/theme_language.png" alt><br> 第二步： 出现乱码可能是因为用记事本编辑没有使用UTF-8编码，解决办法：下载文本编辑器（例如sublime）进行编辑。</p>
<p><img src="/2019/12/01/problem/sublime_encode.png" alt><br> 第三步： 点击sublime中file下的save with Encoding，选择UTF-8，<br> 直接点击save可能会出现警告.</p>
<hr>
<h1 id="hexo的图片上传"><a href="#hexo的图片上传" class="headerlink" title="hexo的图片上传"></a>hexo的图片上传</h1><p>  在根目录下建立与文章同名的文件夹，将图片放进去引用即可，或者用网络地址引用。<br> <img src="/2019/12/01/problem/image_post.png" alt></p>
<hr>
<h1 id="图标点击显示找不到页面。"><a href="#图标点击显示找不到页面。" class="headerlink" title="图标点击显示找不到页面。"></a>图标点击显示找不到页面。</h1><p><img src="/2019/12/01/problem/icon.png" alt><br>第一步：打开主题目录设置文件，找到menu。<br><img src="/2019/12/01/problem/menu.png" alt><br>第二步：将每个图标斜杠/后的空格删去。<br><img src="/2019/12/01/problem/menu1.png" alt></p>
<hr>
<h1 id="文章添加多个tags"><a href="#文章添加多个tags" class="headerlink" title="文章添加多个tags"></a>文章添加多个tags</h1><p>不能直接在tags标签后用空格隔开标签，应该用方括号中间用逗号隔开,<br>否则会出现文章无法上传的问题。</p>
<hr>
<h1 id="hexo页面上传"><a href="#hexo页面上传" class="headerlink" title="hexo页面上传"></a>hexo页面上传</h1><ol>
<li>标签和其他页面的格式要符合hexo的表准，单个标签用双引号，多个用方括号，中间不用双引号，否则页面无法上传。</li>
</ol>
<hr>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><ol>
<li>navicat 10061(MySQL服务未开启，无法连接到数据库)，是由于再金山毒霸里开启了开机加速，导致MySQL被禁止开机自启动，取消限制后任然没有作用，就可以通过手动启动来解决。</li>
</ol>
<ul>
<li>win + R启动运行程序，输入services.msc<br><img src="/2019/12/01/problem/mysql.png" alt></li>
<li>找到mysql服务打开即可<br><img src="/2019/12/01/problem/mysql1.png" alt></li>
</ul>
]]></content>
      <categories>
        <category>problem solution</category>
      </categories>
      <tags>
        <tag>解决办法，工具软件</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希函数和哈希表（其他查找函数）</title>
    <url>/2019/11/29/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>定义：根据哈希函数和冲突处理办法将数据存储在一段连续的空间中。</p>
<p>不同于其他查找函数需要对值进行匹配，哈希表在建立时为每一个数据建立一个独一无二的关键字，这样查找时可以根据关键字直接找到数据。</p>
<a id="more"></a>

<hr>
<h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><p>哈希函数需要满足两个条件，假设哈希表有m个关键字，则取值范围是<br>[0，m-1]。</p>
<ol>
<li>哈希函数的值域必须在[0，m-1]的范围内。</li>
<li>保证哈希函数的每个值在[0,m-1]内的概率相等。</li>
</ol>
<hr>
<h1 id="哈希函数的几种办法"><a href="#哈希函数的几种办法" class="headerlink" title="哈希函数的几种办法"></a>哈希函数的几种办法</h1><ol>
<li>直接定址法：适用与线性数据，比如年龄，日期等</li>
<li>数字分析法：适用与某些数据中有大量重复字段，且可以预知全部的可能出现的值，取其中若干的字段作为关键字。</li>
<li>平方取中法：适用与字段较短，可以先平方，再取中间的字段作为关键字，因为中间的字段与每个数据都有关系，可以增加概率的平均性。</li>
<li>折叠法：将关键值分割为几个位数相同的部分，取这几个部分的叠加和作为哈希地址。</li>
</ol>
<ul>
<li>移位叠加<br>   各部分按照最低位对齐（舍去进位，即相加后多出切割位的数字），然后相加。</li>
<li>间界叠加<br>   关键字值从一端向另一端沿分界线来回折叠，然后对齐相加。</li>
</ul>
<ol start="5">
<li>除留余数法：被除数必须是素数，否则会出现关键字大量重复。（最大公倍数原理）</li>
</ol>
<hr>
<h1 id="处理冲突方法"><a href="#处理冲突方法" class="headerlink" title="处理冲突方法"></a>处理冲突方法</h1><p>当哈希函数值相同时，位置已经被其他数据占用，则按照冲突处理方法寻找下一个位置。</p>
<ol>
<li>开放定址法：令Hi=(H(key)+di)%m,其中H(key)时哈希函数，di是增量序列。</li>
</ol>
<ul>
<li>若di取1，2，3，4….m-1，则为线性探测再散列。</li>
<li>若di取1^2,-1^2,2^2,-2^2..+k^2,-k^2,则为二次探测再散列。</li>
<li>若di取伪随机数序列，则称伪随机探测再散列。</li>
</ul>
<ol start="2">
<li>链表寻址法： 对重复数据建立链表，并且将每个链表有序排列，</li>
<li>公共溢出区法： 将哈希表的一部分作为公共区，重复数据依次放入。</li>
</ol>
<hr>
<h1 id="哈希表中查找元素"><a href="#哈希表中查找元素" class="headerlink" title="哈希表中查找元素"></a>哈希表中查找元素</h1><p>  与插入的方法差不多，按关键字寻找，遇到冲突按照法则寻找。</p>
<hr>
<h1 id="链表-哈希表的基础"><a href="#链表-哈希表的基础" class="headerlink" title="链表(哈希表的基础)"></a>链表(哈希表的基础)</h1><ol>
<li><p>链表的实质就是由结构体转变而来，不过多了一个指针域。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; node ;<span class="comment">//重命名结构体变量，方便下一步</span></span><br></pre></td></tr></table></figure>
<p>重命名typedef可以避免字母打错等错误。</p>
</li>
<li><p>头节点：是链表的第一个节点，一般不存放数据(用来指向整个链表)。</p>
</li>
<li><p>malloc函数(动态内存分配，链表创建的基础)：其函数原型为void <em>malloc(unsigned int size)，size是输入数据的长度，返回类型是void</em>类型，需要指定类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Head = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));<span class="comment">//定义头节点</span></span><br><span class="line"><span class="comment">//node是重命名后的结构体变量名(即相当与指定int*类型指针一样，sizeof()*n用来计算n个结构体的长度。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>！！！链表建立时都是建的结构体指针，而不是结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node *Head;</span><br><span class="line">node *pend;</span><br><span class="line">node *pnew;</span><br></pre></td></tr></table></figure></li>
<li><p>建立流程：</p>
<ul>
<li>定义头节点(Head)，尾节点(pend)，新节点(pnew)<br>由于要用头节点来指向整个链表，数据域不赋值，因此需要一个节点来代替头节点进行节点的更替。</li>
<li>确定输入多少个值(由具体情况而定)，每次输入都要为pnew动态分配内存，输入值赋给新节点的数据域，旧节点的指针域指向新节点，新节点变为旧节点。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node *Head;<span class="comment">//创建头节点</span></span><br><span class="line">    Head = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">	Head-&gt;next = <span class="literal">NULL</span>;<span class="comment">// 头节点后面没有新节点，所以是NULL</span></span><br><span class="line">	node *pnew,*pend;</span><br><span class="line">	pend = Head;<span class="comment">// 当输入数据为0个时，尾节点就等于头节点，用尾节点代替头节点进行连接操作</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">for</span>(;n!=<span class="number">-1</span>;)&#123;</span><br><span class="line">		pnew = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));<span class="comment">//为新节点分配内存</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		pnew-&gt;data = n;<span class="comment">// 新节点的数据域赋值为n</span></span><br><span class="line">		pend-&gt;next = pnew; <span class="comment">//旧节点的指针域指向新节点，不然下一步无法完成，因为旧节点没有新节点的地址，没有办法找到新节点</span></span><br><span class="line">		pend = pnew; <span class="comment">//新节点变为旧节点</span></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">pend-&gt;next = <span class="literal">NULL</span>;<span class="comment">// 尾节点的指针域赋为NULL，表示后面没有新元素</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<hr>
<h1 id="顺序查找法"><a href="#顺序查找法" class="headerlink" title="顺序查找法"></a>顺序查找法</h1><p>顺序查找法：<br>特点：对每一个数据进行比较，如果符合就返回。<br>优点：空间复杂度小，数据小时处理有优势，思路简单。<br>缺点：时间复杂度大，数据一大运行时间会大大增加。<br>时间复杂度：最好是找1次就可以，最坏是找n次，平均是（n+1）/2.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">顺序查找法：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">200</span>];</span><br><span class="line">	<span class="keyword">int</span> number,i;</span><br><span class="line">	<span class="keyword">int</span> target;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);                <span class="comment">//输入数组</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;target);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]==target)&#123;                  <span class="comment">//判断是否相等</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d is in the list\n"</span>,target);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"target's location is %d(从1开始计数)"</span>,i+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找法：<br>特点：数据必须要有序排列。<br>优点：运行时间比顺序查找法少，数据大时有优势。<br>缺点：数据必须有序，先得排序，空间复杂度比顺序查找法高，思路不容易想到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s[<span class="number">200</span>];</span><br><span class="line">	<span class="keyword">int</span> number,i,j;</span><br><span class="line">	<span class="keyword">int</span> target,t,flag=<span class="number">0</span>,a,b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;number-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[j+<span class="number">1</span>]&lt;s[j])&#123;                  <span class="comment">//冒泡排序，对输入数组进行升序</span></span><br><span class="line">				t=s[j];</span><br><span class="line">				s[j]=s[j+<span class="number">1</span>];</span><br><span class="line">				s[j+<span class="number">1</span>]=t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	a=s[<span class="number">0</span>];</span><br><span class="line">	b=s[number<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;target);	</span><br><span class="line">		<span class="keyword">while</span>(a&lt;=b)&#123;</span><br><span class="line">			<span class="keyword">if</span>(target==(a+b)/<span class="number">2</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d is in the list"</span>,target);<span class="comment">//target与中间值相等则输出。</span></span><br><span class="line">				flag++;   <span class="comment">//在数组中则为1，不在则为0，输出notfind</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;(a+b)/<span class="number">2</span>)&#123;</span><br><span class="line">				b=(a+b)/<span class="number">2</span><span class="number">-1</span>;             <span class="comment">//如果target在中值的左边，则a不变，将中值-1作为b，即在中值左边的区间内查找 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;(a+b)/<span class="number">2</span>)&#123;</span><br><span class="line">				a=(a+b)/<span class="number">2</span>+<span class="number">1</span>;          <span class="comment">//同上，在中值右边查找</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"not find"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="选择排序法"><a href="#选择排序法" class="headerlink" title="选择排序法"></a>选择排序法</h1>]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c语言，数据结构，查找算法，链表</tag>
      </tags>
  </entry>
  <entry>
    <title>函数输出水仙花数（求各位数之和新解）</title>
    <url>/2019/11/24/pta/</url>
    <content><![CDATA[<h1 id="求各位数之和新解"><a href="#求各位数之和新解" class="headerlink" title="求各位数之和新解"></a>求各位数之和新解</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">          temp=x%<span class="number">10</span>;<span class="comment">//取出最后一位数</span></span><br><span class="line">          x=x/<span class="number">10</span>;<span class="comment">//去掉最后一位数</span></span><br><span class="line">          y=temp+y*<span class="number">10</span>;<span class="comment">//在还原</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是求出未知数各个位置的和。<br>与之前从第一位开始求不同，这种更方便，无需根据具体位数设置相应个数的变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* run this program using the console pauser or add your own getch, system("pause") or input loop */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line"><span class="keyword">int</span> i,a,b,c,d,e,f,g,t; </span><br><span class="line"><span class="keyword">if</span>(N==<span class="number">3</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">100</span>;i&lt;=<span class="number">999</span>;i++)&#123;</span><br><span class="line">		a=i/<span class="number">100</span>;</span><br><span class="line">		b=(i%<span class="number">100</span>)/<span class="number">10</span>;</span><br><span class="line">		c=(i%<span class="number">100</span>)%<span class="number">10</span>;</span><br><span class="line">	t=a*a*a+b*b*b+c*c*c;</span><br><span class="line">    <span class="keyword">if</span>((a*<span class="number">100</span>+b*<span class="number">10</span>+c)==t)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a*<span class="number">100</span>+b*<span class="number">10</span>+c);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(N==<span class="number">4</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1000</span>;i&lt;=<span class="number">9999</span>;i++)&#123;</span><br><span class="line">		a=i/<span class="number">1000</span>;</span><br><span class="line">		b=i%<span class="number">1000</span>/<span class="number">100</span>;</span><br><span class="line">		c=i%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">		d=i%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">	t=a*a*a*a+b*b*b*b+c*c*c*c+d*d*d*d;</span><br><span class="line">    <span class="keyword">if</span>((a*<span class="number">1000</span>+b*<span class="number">100</span>+c*<span class="number">10</span>+d)==t)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line"> <span class="keyword">if</span>(N==<span class="number">5</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">10000</span>;i&lt;<span class="number">99999</span>;i++)&#123;</span><br><span class="line">		a=i/<span class="number">10000</span>;</span><br><span class="line">		b=(i%<span class="number">10000</span>)/<span class="number">1000</span>;</span><br><span class="line">		c=(i%<span class="number">10000</span>)%<span class="number">1000</span>/<span class="number">100</span>;</span><br><span class="line">		d=(i%<span class="number">10000</span>)%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">		e=(i%<span class="number">10000</span>)%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">	t=a*a*a*a*a+b*b*b*b*b+c*c*c*c*c+d*d*d*d*d+e*e*e*e*e;</span><br><span class="line">    <span class="keyword">if</span>(a*<span class="number">10000</span>+b*<span class="number">1000</span>+c*<span class="number">100</span>+d*<span class="number">10</span>+e==t)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">if</span>(N==<span class="number">6</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">100000</span>;i&lt;<span class="number">999999</span>;i++)&#123;</span><br><span class="line">		a=i/<span class="number">100000</span>;</span><br><span class="line">		b=i%<span class="number">100000</span>/<span class="number">10000</span>;</span><br><span class="line">		c=i%<span class="number">100000</span>%<span class="number">10000</span>/<span class="number">1000</span>;</span><br><span class="line">		d=i%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>/<span class="number">100</span>;</span><br><span class="line">		e=i%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">		f=i%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">	t=a*a*a*a*a*a+b*b*b*b*b*b+c*c*c*c*c*c+d*d*d*d*d*d+e*e*e*e*e*e+f*f*f*f*f*f;</span><br><span class="line">    <span class="keyword">if</span>((a*<span class="number">100000</span>+b*<span class="number">10000</span>+c*<span class="number">1000</span>+d*<span class="number">100</span>+e*<span class="number">10</span>+f)==t)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a*<span class="number">100000</span>+b*<span class="number">10000</span>+c*<span class="number">1000</span>+d*<span class="number">100</span>+e*<span class="number">10</span>+f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">if</span>(N==<span class="number">7</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1741723</span>;i&lt;<span class="number">9999999</span>;i++)&#123;</span><br><span class="line">		a=i/<span class="number">1000000</span>;</span><br><span class="line">		b=i%<span class="number">1000000</span>/<span class="number">100000</span>;</span><br><span class="line">		c=i%<span class="number">1000000</span>%<span class="number">100000</span>/<span class="number">10000</span>;</span><br><span class="line">		d=i%<span class="number">1000000</span>%<span class="number">100000</span>%<span class="number">10000</span>/<span class="number">1000</span>;</span><br><span class="line">		e=i%<span class="number">1000000</span>%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>/<span class="number">100</span>;</span><br><span class="line">		f=i%<span class="number">1000000</span>%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">		g=i%<span class="number">1000000</span>%<span class="number">100000</span>%<span class="number">10000</span>%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">		t=a*a*a*a*a*a*a+b*b*b*b*b*b*b+c*c*c*c*c*c*c+d*d*d*d*d*d*d+e*e*e*e*e*e*e+f*f*f*f*f*f*f+g*g*g*g*g*g*g;</span><br><span class="line">	<span class="keyword">if</span>((a*<span class="number">1000000</span>+b*<span class="number">100000</span>+c*<span class="number">10000</span>+d*<span class="number">1000</span>+e*<span class="number">100</span>+f*<span class="number">10</span>+g)==t)</span><br><span class="line">	                        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a*<span class="number">1000000</span>+b*<span class="number">100000</span>+c*<span class="number">10000</span>+d*<span class="number">1000</span>+e*<span class="number">100</span>+f*<span class="number">10</span>+g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然上面也可以用for循环+pow函数但还是不够简便。</p>
<hr>
<h1 id="逆序数输出（由末位新解联想）"><a href="#逆序数输出（由末位新解联想）" class="headerlink" title="逆序数输出（由末位新解联想）"></a>逆序数输出（由末位新解联想）</h1><ol>
<li><p>数学法：通过末尾取余将末尾数取出，在依次*10，便能输出逆序数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number,x,t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">	<span class="keyword">while</span>(number!=<span class="number">0</span>)&#123;</span><br><span class="line">		t=t*<span class="number">10</span>+number%<span class="number">10</span>;  <span class="comment">//每次t向前移动一位</span></span><br><span class="line">	    number/=<span class="number">10</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,t);		</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串法：转为字符串逆序输出。。。。。</p>
</li>
</ol>
<hr>
<h1 id="另一种应用-回文数"><a href="#另一种应用-回文数" class="headerlink" title="另一种应用(回文数)"></a>另一种应用(回文数)</h1><ol>
<li><p>存为数组，用a[i]与a[n-i-1]相互比较</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(a[i]!=a[n-i<span class="number">-1</span>])&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"false"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		flag++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"true"</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>反转一半数：用末尾数新解，对输入数后一半进行逆序排序，将它和变化后的number比较。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> number,t=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">	<span class="keyword">if</span>(number&lt;<span class="number">0</span>||(number%<span class="number">10</span>==<span class="number">0</span>&amp;&amp;number!=<span class="number">0</span>))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"false"</span>);         <span class="comment">// 数字为负数或者末尾是0但首位肯定不是0，就不可能是回文数</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(number&gt;t)&#123; <span class="comment">//当number&gt;t时，说明t的位数比number小，即没有到中间，并且中间数肯定等于自身，不需判定。</span></span><br><span class="line">			t=t*<span class="number">10</span>+number%<span class="number">10</span>;</span><br><span class="line">			number/=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(number==t)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"true"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"false"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>求各个位数和新解</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2019/11/23/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="scanf输入字符串"><a href="#scanf输入字符串" class="headerlink" title="scanf输入字符串"></a>scanf输入字符串</h1><p>scanf输入的字符串中不能有空格，而gets()可以，若要用scanf输入多个字符，要先定义n(字符串个数)个字符数组，且在scanf内%s中间不用空格分隔</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">30</span>],str2[<span class="number">30</span>],str3[<span class="number">30</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s%s"</span>,str1,str2,str3); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="字符串存储在一个数组中"><a href="#字符串存储在一个数组中" class="headerlink" title="字符串存储在一个数组中"></a>字符串存储在一个数组中</h1><p>用二维数组定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">3</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str1[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,str1[<span class="number">1</span>]);  <span class="comment">//输出第二个字符串</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><ol>
<li>puts函数：函数中可以加入转义符，且在输出结束字符串后会自动转行<br><code>char str[]={&quot;hello\nworld!&quot;};</code></li>
<li>strcat函数：<code>strcat(str1,str2);</code>是将两个字符串连接起来，返回值是字符串数组1的地址，并且注意字符串1的长度必须足够大。</li>
<li>strcpy：字符串复制函数<code>strcpy(str1,str2)</code>若是采用数组元素一个个赋值不方便，直接用函数赋值。<br>strcpy可以是数组名复制，也可以是字符串常量<code>strcpy(str1,&quot;china!&quot;);</code></li>
<li>strcmp：字符串比较函数（strcmp（str1，str2）），若str1&lt; str2，返回值小于0，若str1&gt;str2,返回值大于0.若str1==str2，则返回0（用来判断字符串的结束标志）。</li>
</ol>
<h1 id="字符串数组与函数名做参"><a href="#字符串数组与函数名做参" class="headerlink" title="字符串数组与函数名做参"></a>字符串数组与函数名做参</h1><ol>
<li>当要通过某个特定值来确定函数是否结束时，用strcmp==0来判断，而不    用srt[i]==’#’或者str [i] [j]=’#’来判断,即使特 定符号已经出现程序也会直接跳过(具体原因不知，有空再说)。</li>
<li>给字符串数组赋结束标志’\0’时，不能用str[i]==’\0’，而是应用str<br>[i][j]==’\0’来赋值(可能因为一个字符只能放一个数组格)</li>
<li>数组名做参：定义函数时，如果定义二维数组，那么列的值不能为空<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> fet (<span class="built_in">int</span> han[][<span class="number">20</span>])&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>注意形参要带变量类型，但是调用函数时不需要，尤其是字符串数组，只要带入数组名即可不需要包括后面[]的大小</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">fet(<span class="name">han</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>字符串，c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
